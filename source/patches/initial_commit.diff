This file is a complete diff of changes of the original sources to the source files
at the time of initial commit to github. 

You need diff syntax highlighting e.g. the Visual Studio addin AnkhSvn



  ================================================
diff --git a/source/ablt/ablmc2.cpp b/source/ablt/ablmc2.cpp
index fa17ce6..2341ac8 100755
--- a/source/ablt/ablmc2.cpp
+++ b/source/ablt/ablmc2.cpp
@@ -6568,7 +6568,7 @@ void ablSymbolFreeCallback (void* memBlock) {
 
 //*****************************************************************************
 
-long ablFileCreateCB (void** file, char* fName) {
+long ablFileCreateCB (void** /* file */, char* /* fName */ ) {
 
 /*	*file = fopen(fNamenew File;
 	if (*file == NULL)
@@ -6586,8 +6586,8 @@ long ablFileCreateCB (void** file, char* fName) {
 long ablFileOpenCB (void** file, char* fName) {
 
 	//Filenames MUST be all lowercase or Hash won't find 'em!
-	for (long i=0;i<strlen(fName);i++)
-		fName[i] = tolower(fName[i]);
+	for (size_t i=0;i<strlen(fName);i++)
+		fName[i] = (char)tolower(fName[i]);
 	*file = fopen(fName, "r");
 	if (*file == NULL) {
 		char errStr[256];
@@ -6655,7 +6655,7 @@ long ablFileReadLineExCB (void* file, unsigned char* buffer, long maxLength) {
 
 //-----------------------------------------------------------------------------
 
-long ablFileWriteCB (void* file, unsigned char* buffer, long length) {
+long ablFileWriteCB (void* /* file */, unsigned char* /* buffer */, long /* length */) {
 
 	//return(((FilePtr)file)->write(buffer, length));
 	return(0);
@@ -6663,7 +6663,7 @@ long ablFileWriteCB (void* file, unsigned char* buffer, long length) {
 
 //-----------------------------------------------------------------------------
 
-long ablFileWriteByteCB (void* file, unsigned char byte) {
+long ablFileWriteByteCB (void* /* file */, unsigned char /* byte */) {
 
 	//return(((FilePtr)file)->writeByte(byte));
 	return(0);
@@ -6671,7 +6671,7 @@ long ablFileWriteByteCB (void* file, unsigned char byte) {
 
 //-----------------------------------------------------------------------------
 
-long ablFileWriteLongCB (void* file, long value) {
+long ablFileWriteLongCB (void* /* file */, long /* value */) {
 
 	//return(((FilePtr)file)->writeLong(value));
 	return(0);
@@ -6679,7 +6679,7 @@ long ablFileWriteLongCB (void* file, long value) {
 
 //-----------------------------------------------------------------------------
 
-long ablFileWriteStringCB (void* file, char* buffer) {
+long ablFileWriteStringCB (void* /* file */, char* /* buffer */) {
 
 	//return(((FilePtr)file)->writeString(buffer));
 	return(0);
@@ -6687,7 +6687,7 @@ long ablFileWriteStringCB (void* file, char* buffer) {
 
 //*****************************************************************************
 
-void ablDebuggerPrintCallback (char* s) {
+void ablDebuggerPrintCallback (char* /* s */) {
 
 	//ABLDebuggerOut->print(s);
 //	char msg[1024];
@@ -6697,14 +6697,14 @@ void ablDebuggerPrintCallback (char* s) {
 
 //*****************************************************************************
 
-void ablDebugPrintCallback (char* s) {
+void ablDebugPrintCallback (char* /* s */) {
 
 //	DEBUGWINS_print(s, 0);
 }
 
 //*****************************************************************************
 
-void ablSeedRandom (unsigned long seed) {
+void ablSeedRandom (unsigned long /* seed */) {
 
 //	gos_srand(seed);
 }


  ================================================
diff --git a/source/ablt/ablt.cpp b/source/ablt/ablt.cpp
index 2fe5387..ecb576e 100755
--- a/source/ablt/ablt.cpp
+++ b/source/ablt/ablt.cpp
@@ -6,12 +6,13 @@
 //
 
 #include "stdafx.h"
-#include "string.h"
+//#include "string.h"
 
 void initABL (void);
 void closeABL (void);
  
-int main(int argc, char* argv[])
+extern "C" int __cdecl 
+main(int argc, char* argv[])
 {
 	if ((argc < 2) || (argc > 3)) {
 		printf("Try again.\n");
@@ -25,6 +26,10 @@ int main(int argc, char* argv[])
 	initABL();
 	unsigned char s[256];
 
+	long handle;
+	long numErrs = 0;
+	long numLines = 0;
+	long numFiles = 0;
 	if (argc == 3) {
 		//------------------------
 		// load the environment...
@@ -39,15 +44,15 @@ int main(int argc, char* argv[])
 			bFile->readString(s);
 			if (s[strlen((char*)s)-1] == 10)
 				s[strlen((char*)s)-1] = NULL;
-			long numErrs = 0;
-			long numLines = 0;
-			long numFiles = 0;
+			numErrs = 0;
+			numLines = 0;
+			numFiles = 0;
 			if ((s[0] == 'l') && (s[1] == ' ')){
-				long handle = (long)ABLi_loadLibrary((char*)&s[2], &numErrs, &numLines, &numFiles, false);
+				handle = (long)ABLi_loadLibrary((char*)&s[2], &numErrs, &numLines, &numFiles, false);
 				printf("     Loaded: %s [%d lines, %d files]\n", &s[2], numLines, numFiles);
 				}
 			else if ((s[0] == 'm') && (s[1] == ' ')) {
-				long handle = ABLi_preProcess((char*)&s[2], &numErrs, &numLines, &numFiles, false);
+				handle = ABLi_preProcess((char*)&s[2], &numErrs, &numLines, &numFiles, false);
 				printf("     Loaded: %s [%d lines, %d files]\n", &s[2], numLines, numFiles);
 			}
 		}
@@ -57,10 +62,10 @@ int main(int argc, char* argv[])
 		printf("\n");
 	}
 
-	long numErrs = 0;
-	long numLines = 0;
-	long numFiles = 0;
-	long handle = ABLi_preProcess(argv[argc-1], &numErrs, &numLines, &numFiles, false);
+	numErrs = 0;
+	numLines = 0;
+	numFiles = 0;
+	handle = ABLi_preProcess(argv[argc-1], &numErrs, &numLines, &numFiles, false);
 	printf("SUCCESS: %s [%d lines, %d files]\n", argv[argc-1], numLines, numFiles);
 	scanf(" ");
 



  ================================================
diff --git a/source/editor/dlgfileopen.cpp b/source/editor/dlgfileopen.cpp
index 93bc0fc..0e529b6 100755
--- a/source/editor/dlgfileopen.cpp
+++ b/source/editor/dlgfileopen.cpp
@@ -87,7 +87,7 @@ void DlgFileOpen::OnOK()
 	strcat( tmpExtension, extension );
 
 	if ( !fileName || (strlen( fileName ) < 4 ||
-		0 != stricmp( tmpExtension, fileName + strlen( fileName ) - 4 )) )
+		0 != _stricmp( tmpExtension, fileName + strlen( fileName ) - 4 )) )
 	{
 		strcat( fileName, "." );
 		strcat( fileName, extension );


  ================================================
diff --git a/source/editor/editor.cpp b/source/editor/editor.cpp
index 98ebb58..d2bf809 100755
--- a/source/editor/editor.cpp
+++ b/source/editor/editor.cpp
@@ -2,17 +2,18 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+
 #include "stdafx.h"
 
 #ifndef EDITORINTERFACE_H
-#include "EditorInterface.h"
+#include "editorinterface.h"
 #endif
 
-#include <GameOS.hpp>
-#include <ToolOS.hpp>
+#include <gameos.hpp>
+#include <toolos.hpp>
 #include <mlr\mlr.hpp>
-#include <Stuff\stuff.hpp>
-#include "EditorData.h"
+#include <stuff\stuff.hpp>
+#include "editordata.h"
 #include "version.h"
 #include "..\resource.h"
 
@@ -668,8 +669,7 @@ void InitializeGameEngine()
 	MOVE_init(30);
 
 	//--------------------------
-	// Create and Load the master Effects File
-	weaponEffects = new WeaponEffects;
+	// Create and Load the master Effects File 	weaponEffects = new WeaponEffects;
 	weaponEffects->init("Effects");
 
 	editor = new Editor();
@@ -731,8 +731,7 @@ void TerminateGameEngine()
 	editor = NULL;
 
 	//--------------------------
-	// master Effects File
-	if (weaponEffects)
+	// master Effects File 	if (weaponEffects)
 		delete weaponEffects;
 	weaponEffects = NULL;
 


  ================================================
diff --git a/source/editor/editordata.cpp b/source/editor/editordata.cpp
index 135e368..281f6ab 100755
--- a/source/editor/editordata.cpp
+++ b/source/editor/editordata.cpp
@@ -29,11 +29,11 @@ typedef enum {
 	NUM_MISSION_TYPES
 } MissionType;
 
-#pragma warning( disable:4201 )
+//#pragma warning( disable:4201 )
 #include "mmsystem.h"
-#pragma warning( default:4201 )
+//#pragma warning( default:4201 )
 
-#pragma warning( disable:4244 )
+//#pragma warning( disable:4244 )
 
 #include <objbase.h>
 
@@ -2625,4 +2625,4 @@ bool CPlayers::Save( FitIniFile* missionFile ) {
 	return true;
 }
 
-#pragma warning( default:4244 )
+//#pragma warning( default:4244 )


  ================================================
diff --git a/source/editor/editorinterface.cpp b/source/editor/editorinterface.cpp
index a5fd3ce..0e5c95c 100755
--- a/source/editor/editorinterface.cpp
+++ b/source/editor/editorinterface.cpp
@@ -6,9 +6,9 @@
 #include "EditorInterface.h"
 #include "dstd.h"
 
-#pragma warning( disable:4201 )
+//#pragma warning( disable:4201 )
 #include "mmsystem.h"
-#pragma warning( default:4201 )
+//#pragma warning( default:4201 )
 
 #ifndef EDITORCAMERA_H
 #include "EditorCamera.h"
@@ -153,7 +153,7 @@ using namespace Microsoft::Xna::Arm;
 IProviderEngine * armProvider;
 
 
-#pragma warning( disable:4244 )
+//#pragma warning( disable:4244 )
 
 //-----------------------------------
 // Frank at work!
@@ -3922,7 +3922,7 @@ void EditorInterface::OnDestroy()
 	}
 }
 
-#pragma warning( default:4244 )
+//#pragma warning( default:4244 )
 
 void EditorInterface::OnForestTool() 
 {


  ================================================
diff --git a/source/editor/editorinterface.h b/source/editor/editorinterface.h
index be7ae98..8477b60 100755
--- a/source/editor/editorinterface.h
+++ b/source/editor/editorinterface.h
@@ -4,7 +4,7 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#pragma warning( disable : 4786 )
+//#pragma warning( disable : 4786 )
 
 
 #ifndef MCLIB_H


  ================================================
diff --git a/source/editor/editorobjectmgr.cpp b/source/editor/editorobjectmgr.cpp
index 0c4f580..45ed5d3 100755
--- a/source/editor/editorobjectmgr.cpp
+++ b/source/editor/editorobjectmgr.cpp
@@ -256,11 +256,11 @@ void EditorObjectMgr::init( const char* bldgListFileName, const char* objectFile
 		// extract the type
 		if ( ExtractNextString( pCur,  tmpBuffer, bufferLength ) )
 		{
-			if ( stricmp( tmpBuffer, "BUILDING" ) == 0 )
+			if ( _stricmp( tmpBuffer, "BUILDING" ) == 0 )
 				bldg.type = BLDG_TYPE;
-			else if ( stricmp( tmpBuffer, "TREE" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "TREE" ) == 0 )
 				bldg.type = TREED_TYPE;
-			else if ( stricmp( tmpBuffer, "VEHICLE" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "VEHICLE" ) == 0 )
 				bldg.type = GV_TYPE;
 			else 
 				bldg.type = MECH_TYPE;
@@ -306,41 +306,41 @@ void EditorObjectMgr::init( const char* bldgListFileName, const char* objectFile
 			{
 				bldg.forestId = atoi( tmpBuffer + 4 );
 			}
-			else if ( stricmp( tmpBuffer, "GATE" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "GATE" ) == 0 )
 				bldg.specialType = EDITOR_GATE;
-			else if ( stricmp( tmpBuffer, "GATE_CONTROL" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "GATE_CONTROL" ) == 0 )
 				bldg.specialType = GATE_CONTROL;
-			else if ( stricmp( tmpBuffer, "POWER_GENERATOR" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "POWER_GENERATOR" ) == 0 )
 				bldg.specialType = POWER_STATION;
-			else if ( stricmp( tmpBuffer, "SENSOR_CONTROL" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "SENSOR_CONTROL" ) == 0 )
 				bldg.specialType = SENSOR_CONTROL;
-			else if ( stricmp( tmpBuffer, "SENSOR" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "SENSOR" ) == 0 )
 				bldg.specialType = SENSOR_TOWER;
-			else if ( stricmp( tmpBuffer, "SPOTLIGHT_CONTROL" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "SPOTLIGHT_CONTROL" ) == 0 )
 				bldg.specialType = SPOTLIGHT_CONTROL;
-			else if ( stricmp( tmpBuffer, "SPOTLIGHT" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "SPOTLIGHT" ) == 0 )
 				bldg.specialType = SPOTLIGHT;
-			else if ( stricmp( tmpBuffer, "LOOKOUT" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "LOOKOUT" ) == 0 )
 				bldg.specialType = LOOKOUT;
-			else if ( stricmp( tmpBuffer, "TURRET_CONTROL" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "TURRET_CONTROL" ) == 0 )
 				bldg.specialType = TURRET_CONTROL;
-			else if ( stricmp( tmpBuffer, "TURRET_GENERATOR" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "TURRET_GENERATOR" ) == 0 )
 				bldg.specialType = TURRET_GENERATOR;
-			else if ( stricmp( tmpBuffer, "BRIDGE_CONTROL" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "BRIDGE_CONTROL" ) == 0 )
 				bldg.specialType = BRIDGE_CONTROL;
-			else if ( stricmp( tmpBuffer, "BRIDGE" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "BRIDGE" ) == 0 )
 				bldg.specialType = EDITOR_BRIDGE;		
-			else if ( stricmp( tmpBuffer, "DROPZONE" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "DROPZONE" ) == 0 )
 				bldg.specialType = DROPZONE;
-			else if ( stricmp( tmpBuffer, "TURRET" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "TURRET" ) == 0 )
 				bldg.specialType = EDITOR_TURRET;
-			else if ( stricmp( tmpBuffer, "NAVMARKER" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "NAVMARKER" ) == 0 )
 				bldg.specialType = NAV_MARKER;
-			else if ( stricmp( tmpBuffer, "WALL" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "WALL" ) == 0 )
 				bldg.specialType = WALL;
-			else if ( stricmp( tmpBuffer, "RPBUILDING" ) == 0 )
+			else if ( _stricmp( tmpBuffer, "RPBUILDING" ) == 0 )
 				bldg.specialType = RESOURCE_BUILDING;
-			else if ( stricmp( tmpBuffer, "HELICOPTER" ) == 0 ) 
+			else if ( _stricmp( tmpBuffer, "HELICOPTER" ) == 0 ) 
 				bldg.specialType = HELICOPTER;
 		}
 


  ================================================
diff --git a/source/editor/editorobjects.cpp b/source/editor/editorobjects.cpp
index 64cdf36..1fe61fd 100755
--- a/source/editor/editorobjects.cpp
+++ b/source/editor/editorobjects.cpp
@@ -698,7 +698,7 @@ bool Brain::load( FitIniFile* file, int warriorNumber )
 	// if not explicitly set, then redo
 	if ( strcmp( brainName, "PBrain" ) == 0 )
 		brainName[0] = 0;
-	else if ( stricmp( brainName, "DredAttack01" ) == 0 )
+	else if ( _stricmp( brainName, "DredAttack01" ) == 0 )
 		brainName[0] = 0;
 
 	if (0 < numCells)
@@ -805,7 +805,7 @@ void Pilot::load( FitIniFile* file, int bGoodGuy )
 	{
 		for ( int i = 0; i < goodCount; i++ )
 		{
-			if ( stricmp( buffer, s_GoodPilots[i].fileName ) == 0 )
+			if ( _stricmp( buffer, s_GoodPilots[i].fileName ) == 0 )
 			{
 				info = &s_GoodPilots[i];
 				bFound = 1;
@@ -817,7 +817,7 @@ void Pilot::load( FitIniFile* file, int bGoodGuy )
 		{
 			for ( int i = 0; i < badCount; i++ )
 			{
-				if ( stricmp( buffer, s_BadPilots[i].fileName ) == 0 )
+				if ( _stricmp( buffer, s_BadPilots[i].fileName ) == 0 )
 				{
 					info = &s_BadPilots[i];
 					bFound = 1;
@@ -947,7 +947,7 @@ void Pilot::setName( const char* newName )
 {
 	for ( int i = 0; i < goodCount; i++ )
 	{
-		if ( stricmp( newName, s_GoodPilots[i].name ) == 0 )
+		if ( _stricmp( newName, s_GoodPilots[i].name ) == 0 )
 		{
 			info = &s_GoodPilots[i];
 			return;
@@ -956,7 +956,7 @@ void Pilot::setName( const char* newName )
 
 	for ( i = 0; i < badCount; i++ )
 	{
-		if ( stricmp( newName, s_BadPilots[i].name ) == 0 )
+		if ( _stricmp( newName, s_BadPilots[i].name ) == 0 )
 		{
 			info = &s_BadPilots[i];
 			return;


  ================================================
diff --git a/source/editor/resource.h b/source/editor/resource.h
index 0086472..7fff25c 100755
--- a/source/editor/resource.h
+++ b/source/editor/resource.h
@@ -1,10 +1,6 @@
-//===========================================================================//
-// Copyright (C) Microsoft Corporation. All rights reserved.                 //
-//===========================================================================//
-
 //{{NO_DEPENDENCIES}}
-// Microsoft Developer Studio generated include file.
-// Used by resource.rc
+// Microsoft Visual C++ generated include file.
+// Used by editor.rc
 //
 #define MBOK                            1
 #define IDC_CHOOSE_UNIT_USING_POINTER_BUTTON 3


  ================================================
diff --git a/source/editor/stdafx.h b/source/editor/stdafx.h
index e722c0a..d2188a8 100755
--- a/source/editor/stdafx.h
+++ b/source/editor/stdafx.h
@@ -7,27 +7,50 @@
 //      are changed infrequently
 //
 
-#if !defined(AFX_STDAFX_H__05FE54C7_36AB_4243_BAB1_3FA8FB6F103F__INCLUDED_)
-#define AFX_STDAFX_H__05FE54C7_36AB_4243_BAB1_3FA8FB6F103F__INCLUDED_
-
-#if _MSC_VER > 1000
 #pragma once
-#endif // _MSC_VER > 1000
 
+#ifndef VC_EXTRALEAN
 #define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
+#endif
+
+#define  _WIN32_WINNT   0x0501	// _WIN32_WINNT_WINXP
+#include <sdkddkver.h>
+
+#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // some CString constructors will be explicit
 
-//include "mclib.h"
+// turns off MFC's hiding of some common and often safely ignored warning messages
+#define _AFX_ALL_WARNINGS
 
 #include <afxwin.h>         // MFC core and standard components
 #include <afxext.h>         // MFC extensions
+#include <afxdisp.h>			// MFC Automation classes
+#ifndef _AFX_NO_OLE_SUPPORT
 #include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
+#endif
 #ifndef _AFX_NO_AFXCMN_SUPPORT
 #include <afxcmn.h>			// MFC support for Windows Common Controls
-#endif // _AFX_NO_AFXCMN_SUPPORT
-#include "MFCPlatform.hpp"
-
-
-//{{AFX_INSERT_LOCATION}}
-// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
-
-#endif // !defined(AFX_STDAFX_H__05FE54C7_36AB_4243_BAB1_3FA8FB6F103F__INCLUDED_)
+#endif
+
+#ifdef _DEBUG
+// WIN32;_DEBUG;_WINDOWS;LAB_ONLY;_ARMOR;WINVER=0x0501
+#define LAB_ONLY 1
+#define _ARMOR 1
+#else 
+// WIN32;NDEBUG;_WINDOWS;WINVER=0x0501
+// WIN32;NDEBUG;_WINDOWS;WINVER=0x0501	- profile
+#endif
+
+
+// MechCommander GameOS
+#include "mfcplatform.hpp"
+
+#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
+
+//..\GameOS\include;..\MCLIB;.\window;"$(VCInstallDir)PlatformSDK\Include\mfc";"$(VCInstallDir)PlatformSDK\Include\atl"
+//..\mclib\$(ConfigurationName)\mclib.lib
+//..\gameos\lib\$(ConfigurationName)\gameos.lib
+//..\gameos\lib\$(ConfigurationName)\mfcplatform.lib 
+//..\mclib\gosfx\$(ConfigurationName)\gosfx.lib
+//..\mclib\mlr\$(ConfigurationName)\mlr.lib
+//..\mclib\stuff\$(ConfigurationName)\stuff.lib
+//..\gameos\lib\$(ConfigurationName)\zlib.lib


  ================================================
diff --git a/source/editor/unitsettingsdlg.cpp b/source/editor/unitsettingsdlg.cpp
index 774e37a..fc96d78 100755
--- a/source/editor/unitsettingsdlg.cpp
+++ b/source/editor/unitsettingsdlg.cpp
@@ -778,7 +778,7 @@ void UnitSettingsDlg::updateMemberVariables()
 
 		const char* tmpName = pPilot->info->fileName;
 
-		if ( stricmp( tmpName, defaultPilot ) != 0 )
+		if ( _stricmp( tmpName, defaultPilot ) != 0 )
 		{
 			defaultPilot = 0;
 			break;
@@ -848,7 +848,7 @@ void UnitSettingsDlg::OnAlign1( UINT whichID )
 
 		const char* tmpName = pPilot->getName();
 
-		if ( stricmp( tmpName, defaultPilot ) != 0 )
+		if ( _stricmp( tmpName, defaultPilot ) != 0 )
 		{
 			defaultPilot = 0;
 			break;


  ================================================
diff --git a/source/gameos/include/3drasterizer.hpp b/source/gameos/include/3drasterizer.hpp
index 8f64893..d041351 100755
--- a/source/gameos/include/3drasterizer.hpp
+++ b/source/gameos/include/3drasterizer.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 3DRasterizer.hpp												 //
 // Contents: Low level 3D rasterizer										 //
@@ -6,160 +5,137 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
 
 
-
-typedef struct _SAVESTATE
-{
-	_SAVESTATE* pNext;
-	DWORD		SaveState[gos_MaxState];
+typedef struct _SAVESTATE {
+	struct _SAVESTATE*	pNext;
+	ULONG				SaveState[gos_MaxState];
 } SAVESTATE;
+typedef SAVESTATE *PSAVESTATE;
 
 extern SAVESTATE*	pStateStack;
-extern DWORD		StackDepth;
-
-
-
+extern ULONG		StackDepth;
 
 //
 // Structure to hold information about vertex buffers created
 //
-typedef struct _VertexBuffer
-{
-	DWORD					Magic;					// Magic number to verify handle valid
+typedef struct _VertexBuffer {
+	ULONG					Magic;					// Magic number to verify handle valid
 	gosVERTEXTYPE			VertexType;				// Type of vertex the buffer contains
-	_VertexBuffer*			pNext;
-	IDirect3DVertexBuffer7*	vBuffer;				// D3D handle
-	#ifdef LAB_ONLY
-	IDirect3DVertexBuffer7*	DebugvBuffer;			// D3D handle to a system memory vertex buffer for debugging D3DTLVERTEX data
-	IDirect3DVertexBuffer7*	CopyvBuffer;			// D3D handle to a system memory vertex buffer for debugging (Readable copy of D3DVERTEX data)
+	struct _VertexBuffer*	pNext;
+	LPDIRECT3DVERTEXBUFFER7	vBuffer;				// D3D handle
+#if defined(LAB_ONLY)
+	LPDIRECT3DVERTEXBUFFER7	DebugvBuffer;			// D3D handle to a system memory vertex buffer for debugging D3DTLVERTEX data
+	LPDIRECT3DVERTEXBUFFER7	CopyvBuffer;			// D3D handle to a system memory vertex buffer for debugging (Readable copy of D3DVERTEX data)
 	#endif
-	DWORD					NumberVertices;			// Number of vertices when created
-	bool					Locked;					// True when locked
-	bool					WantOptimize;			// True to optimize after the next unlock
-	bool					Optimized;				// True once buffer is optimized
-	bool					Lost;					// True when mode changed and buffer invalid
-	void*					Pointer;				// Pointer to start of data when locked
-
+	ULONG					NumberVertices;			// Number of vertices when created
+	UCHAR					Locked;					// True when locked
+	UCHAR					WantOptimize;			// True to optimize after the next unlock
+	UCHAR					Optimized;				// True once buffer is optimized
+	UCHAR					Lost;					// True when mode changed and buffer invalid
+	PVOID					Pointer;				// Pointer to start of data when locked
 } VertexBuffer;
-
-
+typedef VertexBuffer *PVertexBuffer;
 
 //
 // Variables that effect rendering
 //
-extern WORD QuadIndex[192];
-extern DWORD AlphaInvAlpha;			// Set when alpha blend mode is AlphaInvAlpha
-
-extern bool ViewPortChanged;			// Set when game changes viewport
-extern DWORD InUpdateRenderers;		// True when in 'Update Renderers'
-extern DWORD DrawingPolys;			// Current polygon
-extern DWORD gCulledTriangles;		// Number of culled triangles
-extern DWORD CulledMax;
-extern DWORD DrawingMax;			// Maximum polys to draw
-extern DWORD DrawingHighest;
-extern DWORD gForceNoClear;
-extern DWORD VertexBuffersLocked;
-extern DWORD gDisableLinesPoints;
-extern DWORD gDisablePrimitives;
-
+extern USHORT QuadIndex[192];
+extern ULONG AlphaInvAlpha;			// Set when alpha blend mode is AlphaInvAlpha
+
+extern UCHAR ViewPortChanged;			// Set when game changes viewport
+extern ULONG InUpdateRenderers;		// True when in 'Update Renderers'
+extern ULONG DrawingPolys;			// Current polygon
+extern ULONG gCulledTriangles;		// Number of culled triangles
+extern ULONG CulledMax;
+extern ULONG DrawingMax;			// Maximum polys to draw
+extern ULONG DrawingHighest;
+extern ULONG gForceNoClear;
+extern ULONG VertexBuffersLocked;
+extern ULONG gDisableLinesPoints;
+extern ULONG gDisablePrimitives;
 
-//
 // Render to texture variables
-//
-void InitRenderToTexture();
-void DestroyRenderToTexture();
-
+void __stdcall InitRenderToTexture(void);
+void __stdcall DestroyRenderToTexture(void);
 
-
-//
 // RenderStates.cpp
-//
-void FlushRenderStates();
-extern bool DirtyStates;
+extern UCHAR DirtyStates;
 extern BYTE UpdatedState[gos_MaxState];
+void __stdcall FlushRenderStates(void);
 
-
-//
 // 3DRasterizer.hpp
-//
-void InitRenderStates();
-void InitRenderer();
-void Save3DState();
-void Restore3DState();
-void ReInit3D();
-void Destroy3D();
-void CheckVertices( gos_VERTEX* pVertexArray, DWORD NumberVertices, bool PointsLines=0 );
-void CheckVertices2( gos_VERTEX_2UV* pVertexArray, DWORD NumberVertices );
-void CheckVertices3( gos_VERTEX_3UV* pVertexArray, DWORD NumberVertices );
-void DebugTriangle( gos_VERTEX* v1, gos_VERTEX* v2, gos_VERTEX* v3 );
-void DebugTriangle_2UV( gos_VERTEX_2UV* v1, gos_VERTEX_2UV* v2, gos_VERTEX_2UV* v3 );
-void DebugTriangle_3UV( gos_VERTEX_3UV* v1, gos_VERTEX_3UV* v2, gos_VERTEX_3UV* v3 );
-DWORD GetMipmapColor( int Mipmap );
-void gos_ClipDrawQuad( gos_VERTEX* pVertices );
+void __stdcall InitRenderStates(void);
+void __stdcall  InitRenderer(void);
+void __stdcall Save3DState(void);
+void __stdcall Restore3DState(void);
+void __stdcall ReInit3D(void);
+void __stdcall Destroy3D(void);
+void __stdcall CheckVertices( pgos_VERTEX pVertexArray, ULONG NumberVertices, UCHAR PointsLines=0 );
+void __stdcall CheckVertices2( pgos_VERTEX_2UV pVertexArray, ULONG NumberVertices );
+void __stdcall CheckVertices3( pgos_VERTEX_3UV pVertexArray, ULONG NumberVertices );
+void __stdcall DebugTriangle( pgos_VERTEX v1, pgos_VERTEX v2, pgos_VERTEX v3 );
+void __stdcall DebugTriangle_2UV( pgos_VERTEX_2UV v1, pgos_VERTEX_2UV v2, pgos_VERTEX_2UV v3 );
+void __stdcall DebugTriangle_3UV( pgos_VERTEX_3UV v1, pgos_VERTEX_3UV v2, pgos_VERTEX_3UV v3 );
+ULONG __stdcall GetMipmapColor( int Mipmap );
+
+// clipping.cpp
+MECH_IMPEXP void MECH_CALL gos_ClipDrawQuad(pgos_VERTEX pVertices);
 
-
-//
 // Statistics
-//
-extern DWORD	NumSpecular;
-extern DWORD	NumPerspective;
-extern DWORD	NumAlpha;
-extern DWORD	NumTextured;
-extern DWORD	PrimitivesRendered;
-extern DWORD	PointsRendered;
-extern DWORD	LinesRendered;
-extern DWORD	TrianglesRendered;
-extern DWORD	QuadsRendered;
-extern DWORD	IndexedTriangleCalls;
+extern ULONG	NumSpecular;
+extern ULONG	NumPerspective;
+extern ULONG	NumAlpha;
+extern ULONG	NumTextured;
+extern ULONG	PrimitivesRendered;
+extern ULONG	PointsRendered;
+extern ULONG	LinesRendered;
+extern ULONG	TrianglesRendered;
+extern ULONG	QuadsRendered;
+extern ULONG	IndexedTriangleCalls;
 extern float	IndexedTriangleLength;
-extern DWORD	IndexedVBTriangleCalls;
+extern ULONG	IndexedVBTriangleCalls;
 extern float	IndexedVBTriangleLength;
-extern DWORD	LastSpecularPrim;
-extern DWORD	LastPerspectivePrim;
-extern DWORD	LastAlphaPrim;
-extern DWORD	LastTexturePrim;
-extern DWORD	LastFilterPrim;
-extern DWORD	NumPointSampled;
-extern DWORD	NumBilinear;
-extern DWORD	NumTrilinear;
-extern DWORD	LastZComparePrim;
-extern DWORD	NumZCompare;
-extern DWORD	LastZWritePrim;
-extern DWORD	NumZWrite;
-extern DWORD	LastAlphaTestPrim;
-extern DWORD	NumAlphaTest;
-extern DWORD	LastDitheredPrim;
-extern DWORD	NumDithered;
-extern DWORD	LastCulledPrim;
-extern DWORD	NumCulled;
-extern DWORD	LastTextureAddressPrim;
-extern DWORD	NumWrapped;
-extern DWORD	NumClamped;
-extern DWORD	LastShadePrim;
-extern DWORD	NumFlat;
-extern DWORD	NumGouraud;
-extern DWORD	LastBlendPrim;
-extern DWORD	NumDecal;
-extern DWORD	NumModulate;
-extern DWORD	NumModulateAlpha;
-extern DWORD	LastMonoPrim;
-extern DWORD	NumMono;
-extern DWORD	LastFogPrim;
-extern DWORD	NumFog;
-extern DWORD	LastClipped;
-extern DWORD	NumGuardBandClipped;
-extern DWORD	NumClipped;
-
-
-
+extern ULONG	LastSpecularPrim;
+extern ULONG	LastPerspectivePrim;
+extern ULONG	LastAlphaPrim;
+extern ULONG	LastTexturePrim;
+extern ULONG	LastFilterPrim;
+extern ULONG	NumPointSampled;
+extern ULONG	NumBilinear;
+extern ULONG	NumTrilinear;
+extern ULONG	LastZComparePrim;
+extern ULONG	NumZCompare;
+extern ULONG	LastZWritePrim;
+extern ULONG	NumZWrite;
+extern ULONG	LastAlphaTestPrim;
+extern ULONG	NumAlphaTest;
+extern ULONG	LastDitheredPrim;
+extern ULONG	NumDithered;
+extern ULONG	LastCulledPrim;
+extern ULONG	NumCulled;
+extern ULONG	LastTextureAddressPrim;
+extern ULONG	NumWrapped;
+extern ULONG	NumClamped;
+extern ULONG	LastShadePrim;
+extern ULONG	NumFlat;
+extern ULONG	NumGouraud;
+extern ULONG	LastBlendPrim;
+extern ULONG	NumDecal;
+extern ULONG	NumModulate;
+extern ULONG	NumModulateAlpha;
+extern ULONG	LastMonoPrim;
+extern ULONG	NumMono;
+extern ULONG	LastFogPrim;
+extern ULONG	NumFog;
+extern ULONG	LastClipped;
+extern ULONG	NumGuardBandClipped;
+extern ULONG	NumClipped;
 
 extern gos_VERTEX PickZoom[3];
 
-
-//
 // Capabilities of the mode
-//
 extern int HasGuardBandClipping;
 extern float MinGuardBandClip;		// Minimum guard band clip
 extern float MaxGuardBandClip;		// Maximum guard band clip
@@ -179,11 +155,8 @@ extern float MinUCoord;			// The minimum u coord (for current texture)// Various
 extern float MaxVCoord;			// The maximum v coord (for current texture)//
 extern float MinVCoord;			// The minimum v coord (for current texture)// Various renderstates based on the capabilities of the current video card
 
-//
 // Various modes the renderer can be in
-//
-typedef enum
-{
+typedef enum RenderModeType {
 	Normal=0,						// Normal rendering
 	WireframeGlobalColor,			// Only wireframe, no texture, global wireframe color
 	WireframeGlobalTexture,			// Global wireframe color ontop of texture
@@ -202,18 +175,11 @@ typedef enum
 
 extern RenderModeType RenderMode;	// In a special debugger mode
 
+extern ULONG RenderStates[gos_MaxState];			// Current User settings
+extern ULONG PreviousStates[gos_MaxState];			// Previously set renderstates
 
-
-extern DWORD RenderStates[gos_MaxState];			// Current User settings
-extern DWORD PreviousStates[gos_MaxState];			// Previously set renderstates
-
-//
 // Various renderstates based on the capabilities of the current video card
-//
-extern DWORD	ModeMagBiLinear;		// MAG mode for Bilinear
-extern DWORD	ModeMinNone;			// MIN mode for non filtering
-extern DWORD	ModeMinBiLinear;		// MIN mode for bilinear
-extern DWORD	ModeMinTriLinear;		// MIN mode for trilinear
-
-
-
+extern ULONG	ModeMagBiLinear;		// MAG mode for Bilinear
+extern ULONG	ModeMinNone;			// MIN mode for non filtering
+extern ULONG	ModeMinBiLinear;		// MIN mode for bilinear
+extern ULONG	ModeMinTriLinear;		// MIN mode for trilinear


  ================================================
diff --git a/source/gameos/include/acm.hpp b/source/gameos/include/acm.hpp
index 06167de..d4999f6 100755
--- a/source/gameos/include/acm.hpp
+++ b/source/gameos/include/acm.hpp
@@ -1,5 +1,3 @@
-#pragma once
-
 //===========================================================================//
 // File:	 ACM.cpp														 //
 // Contents: Wrappers for the Audio Compression Manager						 //																		 //
@@ -7,10 +5,14 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-MMRESULT wACMStreamPrepareHeader( HACMSTREAM hACMStream, ACMSTREAMHEADER *ACMHeader, DWORD fdwPrepare );
-MMRESULT wACMStreamConvert( HACMSTREAM hACMStream, ACMSTREAMHEADER *ACMHeader, DWORD flags );
-MMRESULT wACMStreamUnprepareHeader( HACMSTREAM hACMStream, ACMSTREAMHEADER *ACMHeader, DWORD fdwPrepare );
-MMRESULT wACMStreamClose( HACMSTREAM hACMStream, DWORD flags );
-MMRESULT wACMStreamOpen( LPHACMSTREAM phas, HACMDRIVER had, LPWAVEFORMATEX pwfxSrc, LPWAVEFORMATEX pwfxDst, LPWAVEFILTER pwfltr, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen );
-MMRESULT wACMStreamSize( HACMSTREAM has, DWORD cbInput, LPDWORD pdwOutputBytes, DWORD fdwSize );
-MMRESULT wACMFormatSuggest( HACMDRIVER had, LPWAVEFORMATEX pwfxSrc, LPWAVEFORMATEX pwfxDst, DWORD cbwfxDst, DWORD fdwSuggest );
+#pragma once
+
+#include <msacm.h>
+
+MMRESULT __stdcall wACMStreamPrepareHeader( HACMSTREAM hACMStream, ACMSTREAMHEADER *ACMHeader, ULONG fdwPrepare );
+MMRESULT __stdcall wACMStreamConvert( HACMSTREAM hACMStream, ACMSTREAMHEADER *ACMHeader, ULONG flags );
+MMRESULT __stdcall wACMStreamUnprepareHeader( HACMSTREAM hACMStream, ACMSTREAMHEADER *ACMHeader, ULONG fdwPrepare );
+MMRESULT __stdcall wACMStreamClose( HACMSTREAM hACMStream, ULONG flags );
+MMRESULT __stdcall wACMStreamOpen( LPHACMSTREAM phas, HACMDRIVER had, LPWAVEFORMATEX pwfxSrc, LPWAVEFORMATEX pwfxDst, LPWAVEFILTER pwfltr, ULONG dwCallback, ULONG dwInstance, ULONG fdwOpen );
+MMRESULT __stdcall wACMStreamSize( HACMSTREAM has, ULONG cbInput, LPDWORD pdwOutputBytes, ULONG fdwSize );
+MMRESULT __stdcall wACMFormatSuggest( HACMDRIVER had, LPWAVEFORMATEX pwfxSrc, LPWAVEFORMATEX pwfxDst, ULONG cbwfxDst, ULONG fdwSuggest );


  ================================================
diff --git a/source/gameos/include/controlmanager.hpp b/source/gameos/include/controlmanager.hpp
index f5f1ad8..725b740 100755
--- a/source/gameos/include/controlmanager.hpp
+++ b/source/gameos/include/controlmanager.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 ControlManager.hpp												 //
 // Contents: Control Manager routines										 //
@@ -6,97 +5,74 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-
-
-
+#pragma once
 
 //
 // Mouse handling functions
 //
-void CMCreateMouse();
-void CMUpdateMouse();
-void ReInitControlManager();
-gosEnum_KeyStatus GetStatus( gosEnum_KeyIndex index );
-
-
-extern DWORD KeyBoardBuffer[256];
-extern DWORD KeyCurrent;				// Where the next key to be read is
-extern DWORD KeyPressed;				// Where the next key pressed will go
-extern DWORD dbKeyBoardBuffer[256];
-extern DWORD dbKeyCurrent;				// Where the next key to be read is
-extern DWORD dbKeyPressed;				// Where the next key pressed will go
-extern DWORD LastWMDown;				// Last WM_KEYDOWN message scan code
-extern void SaveOldKeyState();
-extern void DoKeyReleased( DWORD KeyCode );
-extern void DealWithKey( DWORD wParam, DWORD lParam );
-extern void AddKeyEvent(DWORD KeyEvent);
+void __stdcall CMCreateMouse(void);
+void __stdcall CMUpdateMouse(void);
+void __stdcall ReInitControlManager(void);
+gosEnum_KeyStatus __stdcall GetStatus( gosEnum_KeyIndex index );
+
+
+extern ULONG KeyBoardBuffer[256];
+extern ULONG KeyCurrent;				// Where the next key to be read is
+extern ULONG KeyPressed;				// Where the next key pressed will go
+extern ULONG dbKeyBoardBuffer[256];
+extern ULONG dbKeyCurrent;				// Where the next key to be read is
+extern ULONG dbKeyPressed;				// Where the next key pressed will go
+extern ULONG LastWMDown;				// Last WM_KEYDOWN message scan code
+extern void __stdcall SaveOldKeyState(void);
+extern void __stdcall DoKeyReleased( ULONG KeyCode );
+extern void __stdcall DealWithKey( ULONG wParam, ULONG lParam );
+extern void __stdcall AddKeyEvent(ULONG KeyEvent);
 
 #define MAX_DI_DEVICES 16
 
-typedef struct _cmd
-{
+typedef struct _cmd {
 	LPDIRECTINPUT7	m_lpDirectInput7;
 
 	LPDIRECTINPUTDEVICE7	m_lpSysMouse7;
 	LPDIRECTINPUTDEVICE7	m_lpJoystick7[MAX_DI_DEVICES];
 
-	bool m_disabled[MAX_DI_DEVICES];
-	bool m_validAxis[MAX_DI_DEVICES][12];
-	bool m_pollMe[MAX_DI_DEVICES];
+	UCHAR m_disabled[MAX_DI_DEVICES];
+	UCHAR m_validAxis[MAX_DI_DEVICES][12];
+	UCHAR m_pollMe[MAX_DI_DEVICES];
 	float m_howOften[MAX_DI_DEVICES];
 	double m_nextPoll[MAX_DI_DEVICES];
-	bool m_bForceFeedback[MAX_DI_DEVICES];
-
-	unsigned char
-		m_numJoysticks,
-		m_numMouseButtons,
-		m_numMouseAxes,
-		m_numPOVs[MAX_DI_DEVICES],
-		m_numSliders[MAX_DI_DEVICES],
-		m_numButtons[MAX_DI_DEVICES];
-
-	LONG
-		m_mousePos[3],
-		m_mouseAxis[3],
-		m_joyAxis[MAX_DI_DEVICES][12];
-
-	unsigned char
-		m_joyButton[MAX_DI_DEVICES][64];
-	char
-		m_joyName[MAX_DI_DEVICES][64];
-	gosEnum_KeyStatus
-		m_mouseButton[4];
-	bool
-		m_requiresAcquire;
-	HANDLE
-		m_hMouseEvent;
+	UCHAR m_bForceFeedback[MAX_DI_DEVICES];
+
+	UCHAR 	m_numJoysticks;
+	UCHAR 	m_numMouseButtons;
+	UCHAR 	m_numMouseAxes;
+	UCHAR 	m_numPOVs[MAX_DI_DEVICES];
+	UCHAR 	m_numSliders[MAX_DI_DEVICES];
+	UCHAR 	m_numButtons[MAX_DI_DEVICES];
+	LONG	m_mousePos[3];
+	LONG	m_mouseAxis[3];
+	LONG	m_joyAxis[MAX_DI_DEVICES][12];
+
+	UCHAR	m_joyButton[MAX_DI_DEVICES][64];
+	char	m_joyName[MAX_DI_DEVICES][64];
+	gosEnum_KeyStatus m_mouseButton[4];
+	UCHAR	m_requiresAcquire;
+	HANDLE	m_hMouseEvent;
 } ControlManagerDataStruct;
 
-void CMInstall();
-
-void CMUninstall();
-
-void CMCreateKeyboard();
-
-void CMReadJoystick(DWORD index);
-
-void CMReadKeyboard();
-
-void CMGetKeyState();
-
-void CMRestore();
-
-void CMReleaseControls();
-
-void CMAcquireControls();
-
-void CMUnacquireControls();
-
-void CMUpdate();
-
-void CMCreateJoysticks();
-
-BOOL WINAPI CMCreateJoystick7( LPCDIDEVICEINSTANCE pdinst, LPVOID pvRef );
+void __stdcall CMInstall(void);
+void __stdcall CMUninstall(void);
+void __stdcall CMCreateKeyboard(void);
+void __stdcall CMReadJoystick(ULONG index);
+void __stdcall CMReadKeyboard(void);
+void __stdcall CMGetKeyState(void);
+void __stdcall CMRestore(void);
+void __stdcall CMReleaseControls(void);
+void __stdcall CMAcquireControls(void);
+void __stdcall CMUnacquireControls(void);
+void __stdcall CMUpdate(void);
+void __stdcall CMCreateJoysticks(void);
+BOOL __stdcall CMCreateJoystick7( LPCDIDEVICEINSTANCE pdinst, PVOID pvRef );
 
 // This data structure holds all the information necessary for setting up, using,
 // and uninstalling joysticks, a keyboard, and a mouse.


  ================================================
diff --git a/source/gameos/include/debugger.hpp b/source/gameos/include/debugger.hpp
index a83faf8..ce42fa5 100755
--- a/source/gameos/include/debugger.hpp
+++ b/source/gameos/include/debugger.hpp
@@ -1,64 +1,66 @@
-#pragma once
 //===========================================================================//
 // File:	 Debugger.hpp													 //
 // Contents: Debugger														 //
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+
+#pragma once
+
 //
 // Size of scroll back buffer for spew
 //
 #define DebuggerBufferSize 128*1024
 
 extern gos_VERTEX pTextVertices[80];
-extern DWORD TextVertex;
-extern DWORD WantAA;
-extern DWORD Want32;
-extern DWORD Want32T;
-extern DWORD WantRes;
-extern DWORD WantRVRAM;
-extern DWORD WantSW;
-extern DWORD WantSW1;
-extern DWORD WantHW;
-extern DWORD FrameAdvance;							// Used to step or fast forward through scripts
-extern DWORD OldFreeze;								// Old value of gFreezeLogic
-extern DWORD OldRender;								// Old value of gStopRendering;
-extern DWORD PerfCounterSelected;
+extern ULONG TextVertex;
+extern ULONG WantAA;
+extern ULONG Want32;
+extern ULONG Want32T;
+extern ULONG WantRes;
+extern ULONG WantRVRAM;
+extern ULONG WantSW;
+extern ULONG WantSW1;
+extern ULONG WantHW;
+extern ULONG FrameAdvance;							// Used to step or fast forward through scripts
+extern ULONG OldFreeze;								// Old value of gFreezeLogic
+extern ULONG OldRender;								// Old value of gStopRendering;
+extern ULONG PerfCounterSelected;
 extern int PerfYStart,PerfYEnd;
-extern DWORD DoUpdateWindow;
-extern DWORD DoingAdvance;
-extern DWORD OldgStopSystem;
-extern DWORD OldgGameLogicActive;
-extern bool MenuActive;
-extern bool SubMenuActive;
-extern bool	DebounceMenu;
-extern DWORD OldStop;
-extern DWORD OldRendering;
+extern ULONG DoUpdateWindow;
+extern ULONG DoingAdvance;
+extern ULONG OldgStopSystem;
+extern ULONG OldgGameLogicActive;
+extern UCHAR MenuActive;
+extern UCHAR SubMenuActive;
+extern UCHAR	DebounceMenu;
+extern ULONG OldStop;
+extern ULONG OldRendering;
 extern int AreaL, AreaR, AreaT, AreaB;
-extern DWORD PolygonsInArea;
+extern ULONG PolygonsInArea;
 extern float DebuggerTexelOffset;
 extern int DBWheelDelta;
-extern DWORD gShowMemoryUseage;						// 2=Enable at next frame, 1=show data, 0=Do not show data
-extern DWORD gShowWSUseage;							// 2=Enable at next frame, 1=show data, 0=Do not show data
-extern DWORD gShowFTOLUseage;						// 2=Enable at next frame, 1=show data, 0=Do not show data
-extern DWORD gShowALLUseage;
+extern ULONG gShowMemoryUseage;						// 2=Enable at next frame, 1=show data, 0=Do not show data
+extern ULONG gShowWSUseage;							// 2=Enable at next frame, 1=show data, 0=Do not show data
+extern ULONG gShowFTOLUseage;						// 2=Enable at next frame, 1=show data, 0=Do not show data
+extern ULONG gShowALLUseage;
 extern gos_VERTEX Graph[512];
-extern DWORD gScreenBMP;
+extern ULONG gScreenBMP;
 
-void WalkStack( DWORD* RoutineAddresses, DWORD NumberOfLevels, DWORD IgnoreLevels );
-char* DecodeAddress( DWORD Address, bool brief = true );
-void DrawLines( int X1, int Y1, int X2, int Y2, DWORD Color );
+void	__stdcall WalkStack( ULONG* RoutineAddresses, ULONG NumberOfLevels, ULONG IgnoreLevels );
+PSTR	__stdcall DecodeAddress( ULONG Address, UCHAR brief = true );
+void	__stdcall DrawLines( int X1, int Y1, int X2, int Y2, ULONG Color );
 
 typedef struct _MenuItem
 {
-	_MenuItem*	pNext;
-	_MenuItem* pSubMenu;							// Pointer to sub menu list, or NULL
-	DWORD(__stdcall *Callback)(char* Name, DWORD MenuFunction);
-	void (*Routine)();								// Sub menu list pointer
-	bool (*Greyed)();
-	bool (*CheckMark)();							// 0 When no check mark routine, 1 when sub menu
-	char* FullName;
-	char* Name;
+	struct _MenuItem*	pNext;
+	struct _MenuItem*	pSubMenu;							// Pointer to sub menu list, or NULL
+	ULONG	(__stdcall *Callback)(PSTR Name, ULONG MenuFunction);
+	void	(__stdcall *Routine)(void);								// Sub menu list pointer
+	UCHAR	(__stdcall *Greyed)(void);
+	UCHAR	(__stdcall *CheckMark)(void);							// 0 When no check mark routine, 1 when sub menu
+	PSTR FullName;
+	PSTR Name;
 } MenuItem;
 
 
@@ -71,10 +73,10 @@ extern MenuItem*	pGameMenu;
 extern MenuItem*	CurrentMenu;
 extern MenuItem*	MenuHighlight;
 extern MenuItem**	pCurrentMenu;
-extern void CleanUpDebugger();
-extern void InitDebuggerMenus();
+extern void __stdcall CleanUpDebugger(void);
+extern void __stdcall InitDebuggerMenus(void);
 
-#ifdef LAB_ONLY
+#if defined(LAB_ONLY)
 //
 // Pie chart data
 //
@@ -85,28 +87,25 @@ extern void InitDebuggerMenus();
 //
 // Array of textures in texture heap display
 //
-typedef struct _TextureHeap
-{
-	_TextureHeap*	pNext;
+typedef struct _TextureHeap {
+	struct _TextureHeap*	pNext;
 	int				X1;
 	int				Y1;
 	int				X2;
 	int				Y2;
-	DWORD			Handle;
-
+	ULONG					Handle;
 } TextureHeap;
 
 extern TextureHeap* pTextureHeap;
-extern DWORD SelectedHandle;
-extern DWORD TextureToUnload;
-bool CheckWindow();
+extern ULONG SelectedHandle;
+extern ULONG TextureToUnload;
+UCHAR __stdcall CheckWindow(void);
 
 //
 // Main Debugger Screens
 //
 
-enum EDbgScreen
-{
+typedef enum EDbgScreen {
 	DbgS_Stat,					// 0
 	DbgS_Spew,					// 1
 	DbgS_Texture,				// 2
@@ -130,14 +129,14 @@ enum EDbgScreen
 	DbgS_AllTextureDetail,		// 20
 	DbgS_AllTextureNoUpload,	// 21
 	DbgS_TextureLog,			// 22
-};
+} EDbgScreen;
 extern  EDbgScreen DebugDisplay;
 
 
 //
 // Framegraph information
 //
-typedef enum {
+typedef enum FrameGraphMode {
 	Graph_Chart=0,
 	Graph_30,
 	Graph_Pie30,
@@ -146,84 +145,81 @@ typedef enum {
 } FrameGraphMode;
 
 extern FrameGraphMode GraphMode;
-extern DWORD ShowColorInfo;
-
-
-
+extern ULONG ShowColorInfo;
 
 //
 // True when the debugger window is visible on the display
 //
-extern bool DebuggerActive;
-extern bool InDebugger;						// During debugger rendering
-extern bool ProcessMemorySize;				// When true will calculate each processes memory size in the exception handler (can take about 1 second!)
+extern UCHAR DebuggerActive;
+extern UCHAR InDebugger;						// During debugger rendering
+extern UCHAR ProcessMemorySize;				// When true will calculate each processes memory size in the exception handler (can take about 1 second!)
 extern int ZoomMode;						// Zoom screen around cursor
 extern int BaseZoom;
-extern DWORD gForceNoFlip;					// Force blt instead of flip in fullscreen
-extern DWORD gShowAverage;
-extern DWORD gShowGraphsAsTime;
-extern DWORD gShowGraphBackground;
-extern DWORD gNoGraph;
-extern DWORD WhichImage;					// Original / Special mode image?
+extern ULONG gForceNoFlip;					// Force blt instead of flip in fullscreen
+extern ULONG gShowAverage;
+extern ULONG gShowGraphsAsTime;
+extern ULONG gShowGraphBackground;
+extern ULONG gNoGraph;
+extern ULONG WhichImage;					// Original / Special mode image?
 //
 // Scroll back buffer for Dumplog (128K)
 //
 extern char DebuggerBuffer[DebuggerBufferSize];
-extern DWORD CurrentDebugSpewPos;		// Current position in buffer
-extern DWORD CurrentDebugTopOfScreen;	// Current top of screen
+extern ULONG CurrentDebugSpewPos;		// Current position in buffer
+extern ULONG CurrentDebugTopOfScreen;	// Current top of screen
 //
 // Alpha values to added to debugger window
 //
-extern DWORD DebuggerAlpha;
+extern ULONG DebuggerAlpha;
 //
 // Mouse position
 //
 extern int DBMouseX,DBMouseY;
-extern DWORD DBMouseMoved;
+extern ULONG DBMouseMoved;
 extern int ExMouseX,ExMouseY;
-extern DWORD DBButtons;
-
-extern DWORD gEnableMulti;
-extern DWORD gForceMono;
-extern DWORD gForceFlat;
-extern DWORD gForceBlend;
-extern DWORD gForceGouraud;
-extern DWORD gForcePerspective;
-extern DWORD gForceNoPerspective;
-extern DWORD gForceSpecular;
-extern DWORD gForceNoSpecular;
-extern DWORD gForceAlpha;
-extern DWORD gShowVertexData;
-extern DWORD gForceNoFog;
-extern DWORD gForceNoTextures;
-extern DWORD gForceBiLinear;
-extern DWORD gForceTriLinear;
+extern ULONG DBButtons;
+
+extern ULONG gEnableMulti;
+extern ULONG gForceMono;
+extern ULONG gForceFlat;
+extern ULONG gForceBlend;
+extern ULONG gForceGouraud;
+extern ULONG gForcePerspective;
+extern ULONG gForceNoPerspective;
+extern ULONG gForceSpecular;
+extern ULONG gForceNoSpecular;
+extern ULONG gForceAlpha;
+extern ULONG gShowVertexData;
+extern ULONG gForceNoFog;
+extern ULONG gForceNoTextures;
+extern ULONG gForceBiLinear;
+extern ULONG gForceTriLinear;
 extern int	 gForceMipBias;
-extern DWORD gForceNoFiltering;
-extern DWORD gForceNoDithering;
-extern DWORD gForceDithering;
-extern DWORD gForceChessTexture;
-extern DWORD gForceNoAlphaTest;
-extern DWORD gForceAlphaTest;
-extern DWORD ChessTexture;				// The chess texture
-extern DWORD MipColorTexture;			// The mipmap colored texture
-extern DWORD gForceAlphaBlending;
-extern DWORD gUseGameSpew;
-extern DWORD gControlsActive;					// Allow controls for the game during the debugger
-extern DWORD gGameLogicActive;					// Allow game logic to run when debugger up
-extern DWORD gStopSystem;						// Stop whole system in debugger
-extern DWORD gFrameGraph;
-extern DWORD gStopGameRendering;
-extern DWORD gStopRendering;					// Stop rendering
-extern DWORD gFreezeLogic;						// Stop rendering
-extern DWORD gShowLFControls;
-extern bool NoDebuggerStats;						// When 0 Stats and spews are active during GameOS functions like debugger
-extern DWORD gEnableRS;
-extern DWORD gTextureOverrun;
-extern DWORD gDisableLighting;
-extern DWORD gDisableNormalizing;
-extern DWORD gDisableHardwareTandL;
-extern DWORD gDisableVertexBlending;
+extern ULONG gForceNoFiltering;
+extern ULONG gForceNoDithering;
+extern ULONG gForceDithering;
+extern ULONG gForceChessTexture;
+extern ULONG gForceNoAlphaTest;
+extern ULONG gForceAlphaTest;
+extern ULONG ChessTexture;				// The chess texture
+extern ULONG MipColorTexture;			// The mipmap colored texture
+extern ULONG gForceAlphaBlending;
+extern ULONG gUseGameSpew;
+extern ULONG gControlsActive;					// Allow controls for the game during the debugger
+extern ULONG gGameLogicActive;					// Allow game logic to run when debugger up
+extern ULONG gStopSystem;						// Stop whole system in debugger
+extern ULONG gFrameGraph;
+extern ULONG gStopGameRendering;
+extern ULONG gStopRendering;					// Stop rendering
+extern ULONG gFreezeLogic;						// Stop rendering
+extern ULONG gShowLFControls;
+extern UCHAR NoDebuggerStats;						// When 0 Stats and spews are active during GameOS functions like debugger
+extern ULONG gEnableRS;
+extern ULONG gTextureOverrun;
+extern ULONG gDisableLighting;
+extern ULONG gDisableNormalizing;
+extern ULONG gDisableHardwareTandL;
+extern ULONG gDisableVertexBlending;
 
 //
 // Debugger window variables
@@ -231,7 +227,7 @@ extern DWORD gDisableVertexBlending;
 extern int DbTopX,DbTopY;
 extern int DbMaxX,DbMaxY,DbMinX;
 
-extern DWORD TopStatistics;
+extern ULONG TopStatistics;
 
 //
 // Debugger window constants
@@ -246,19 +242,19 @@ extern int StartX,StartY;			// Current start of line
 
 
 
-void UpdateDebugger();
-void InitDebugger();
-void EndRenderMode();
-void DestroyDebugger();
-void SpewToDebugger( char* Message );
-int GetMipmapUsed( DWORD Handle, gos_VERTEX* Pickv1, gos_VERTEX* Pickv2, gos_VERTEX* Pickv3 );
-void ShowFrameGraphs();
-void UpdateDebugMouse();
-void UpdateDebugWindow();
-void InitTextDisplay();
-void DrawText( DWORD Color, char* String );
-void DrawSquare( int TopX, int TopY, int Width, int Height, DWORD Color );
-void DrawChr( char Chr );
+void __stdcall UpdateDebugger(void);
+void __stdcall InitDebugger(void);
+void __stdcall EndRenderMode(void);
+void __stdcall DestroyDebugger(void);
+void __stdcall SpewToDebugger( PSTR Message );
+int __stdcall GetMipmapUsed( ULONG Handle, pgos_VERTEX Pickv1, pgos_VERTEX Pickv2, pgos_VERTEX Pickv3 );
+void __stdcall ShowFrameGraphs(void);
+void __stdcall UpdateDebugMouse(void);
+void __stdcall UpdateDebugWindow(void);
+void __stdcall InitTextDisplay(void);
+void __stdcall DrawText( ULONG Color, PSTR String );
+void __stdcall DrawSquare( int TopX, int TopY, int Width, int Height, ULONG Color );
+void __stdcall DrawChr( char Chr );
 
 
 


  ================================================
diff --git a/source/gameos/include/debuggui.hpp b/source/gameos/include/debuggui.hpp
index 8403a34..20fbdaf 100755
--- a/source/gameos/include/debuggui.hpp
+++ b/source/gameos/include/debuggui.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 DebugGUI.hpp													 //
 // Contents: Debugger user interface										 //
@@ -6,12 +5,14 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-void UpdateDebugMouse();
-void UpdateDebugWindow();
-void InitTextDisplay();
-void DrawText( DWORD Color, char* String );
-void DrawSquare( int TopX, int TopY, int Width, int Height, DWORD Color );
-void DrawChr( char Chr );
+#pragma once
+
+void __stdcall UpdateDebugMouse(void);
+void __stdcall UpdateDebugWindow(void);
+void __stdcall InitTextDisplay(void);
+void __stdcall DrawText( ULONG Color, char* String );
+void __stdcall DrawSquare( int TopX, int TopY, int Width, int Height, ULONG Color );
+void __stdcall DrawChr( char Chr );
 
 
 //
@@ -19,8 +20,8 @@ void DrawChr( char Chr );
 //
 extern int DbTopX,DbTopY;
 extern int DbMaxX,DbMaxY,DbMinX;
-extern DWORD DebugDisplay;
-extern DWORD TopStatistics;
+extern ULONG DebugDisplay;
+extern ULONG TopStatistics;
 
 //
 // Debugger window constants


  ================================================
diff --git a/source/gameos/include/debuginterface.hpp b/source/gameos/include/debuginterface.hpp
index 046ff71..65829b2 100755
--- a/source/gameos/include/debuginterface.hpp
+++ b/source/gameos/include/debuginterface.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 DebugInterface.cpp												 //
 // Contents: Debug interface classes / routines								 //
@@ -6,14 +5,7 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
 
-
-void ShowDebuggingInformation();
-
-
-
-
-
-
-
+void __stdcall ShowDebuggingInformation(void);
 


  ================================================
diff --git a/source/gameos/include/directx.hpp b/source/gameos/include/directx.hpp
index 33fd58e..23fe3c0 100755
--- a/source/gameos/include/directx.hpp
+++ b/source/gameos/include/directx.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 DirectX.hpp													 //
 // Contents: Interface to DirectSetup										 //
@@ -6,24 +5,34 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
 
-
-extern bool	AllowFail;
-extern volatile WORD FPUControl;	// Current FPU control word
-extern WORD FPUDefault;				// Default FPU control word
-char* ErrorNumberToMessage( int hResult );
+extern UCHAR	AllowFail;
+extern volatile USHORT FPUControl;	// Current FPU control word
+extern USHORT FPUDefault;				// Default FPU control word
+extern PSTR __stdcall ErrorNumberToMessage(HRESULT hResult);
 
 
 //
 // Blade GUID
+
+//#ifdef __cplusplus
+//#define EXTERN_C    extern "C"
+//#else
+//#define EXTERN_C    extern
+//#endif
+//
+//#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+//	EXTERN_C const GUID DECLSPEC_SELECTANY name \
+//	= { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
 //
-DEFINE_GUID( IID_IDirect3DBladeDevice,    0x706e9520, 0x6db1, 0x11d2, 0xb9, 0x1, 0x0, 0x10, 0x4b, 0x36, 0xae, 0x4b);
+//DEFINE_GUID( IID_IDirect3DBladeDevice,    0x706e9520, 0x6db1, 0x11d2, 0xb9, 0x1, 0x0, 0x10, 0x4b, 0x36, 0xae, 0x4b);
 
 
 //
 // Used to save and restore FPU control word around DirectX functions
 //
-#if LAB_ONLY
+#if defined(LAB_ONLY)
 #define SafeFPU()		_asm fldcw FPUDefault
 #define GameOSFPU()		_asm fninit _asm fldcw FPUControl
 #else
@@ -37,279 +46,273 @@ DEFINE_GUID( IID_IDirect3DBladeDevice,    0x706e9520, 0x6db1, 0x11d2, 0xb9, 0x1,
 //
 // General DirectX
 //
-HRESULT wCoCreateInstance(REFCLSID rclsid,LPUNKNOWN pUnkOuter,DWORD dwClsContext,REFIID riid,LPVOID* ppv);
-HRESULT wQueryInterface( IUnknown *iun, REFIID riid, LPVOID* obp );
-ULONG wRelease( IUnknown *iun );
-ULONG wAddRef( IUnknown *iun );
+HRESULT __stdcall wCoCreateInstance(REFCLSID rclsid,LPUNKNOWN pUnkOuter,ULONG dwClsContext,REFIID riid,PVOID* ppv);
+HRESULT __stdcall wQueryInterface( IUnknown *iun, REFIID riid, PVOID* obp );
+ULONG __stdcall wRelease( IUnknown *iun );
+ULONG __stdcall wAddRef( IUnknown *iun );
 
 //
 // Direct Setup
 //
-void wDirectXSetupGetVersion( DWORD* dwVersion,DWORD* dwRevision );
+void wDirectXSetupGetVersion( PULONG dwVersion,PULONG dwRevision );
 
-//
 // IDirect3DDevice7
-//
-#ifdef LAB_ONLY
-HRESULT wDrawPrimitive( IDirect3DDevice7* d3dDevice7, D3DPRIMITIVETYPE dptPrimitiveType, DWORD dvtVertexType, LPVOID lpvVertices, DWORD dwVertexCount, DWORD dwFlags );
-HRESULT wDrawIndexedPrimitive( IDirect3DDevice7* d3dDevice7, D3DPRIMITIVETYPE d3dptPrimitiveType, DWORD dwVertexTypeDesc, LPVOID lpvVertices, DWORD dwVertexCount, LPWORD lpwIndices, DWORD dwIndexCount, DWORD dwFlags );
-#else
-#define wDrawPrimitive(d3dDevice7,dptPrimitiveType,dvtVertexType,lpvVertices,dwVertexCount,dwFlags ) d3dDevice7->DrawPrimitive( dptPrimitiveType,dvtVertexType,lpvVertices,dwVertexCount,dwFlags )
-#define wDrawIndexedPrimitive(d3dDevice7,d3dptPrimitiveType,dwVertexTypeDesc,lpvVertices,dwVertexCount,lpwIndices,dwIndexCount,dwFlags ) d3dDevice7->DrawIndexedPrimitive(d3dptPrimitiveType,dwVertexTypeDesc,lpvVertices,dwVertexCount,lpwIndices,dwIndexCount,dwFlags )
-#endif
-HRESULT wDrawPrimitiveVB( IDirect3DDevice7* d3dDevice7, D3DPRIMITIVETYPE d3dptPrimitiveType, LPDIRECT3DVERTEXBUFFER7 lpd3dVertexBuffer, DWORD dwStartVertex, DWORD dwNumVertices, DWORD dwFlags );
-HRESULT wDrawIndexedPrimitiveVB( IDirect3DDevice7* d3dDevice7, D3DPRIMITIVETYPE d3dptPrimitiveType, LPDIRECT3DVERTEXBUFFER7 lpd3dVertexBuffer, DWORD dwStartVertex, DWORD dwNumVertices, LPWORD lpwIndices, DWORD dwIndexCount, DWORD dwFlags );
-HRESULT wSetMaterial( IDirect3DDevice7* d3dDevice7, LPD3DMATERIAL7 lpMaterial );
-HRESULT wSetLight( IDirect3DDevice7* d3dDevice7, DWORD dwLightIndex, LPD3DLIGHT7 lpLight );
-HRESULT wLightEnable( IDirect3DDevice7* d3dDevice7, DWORD dwLightIndex, bool Enable );
-HRESULT wMultiplyTransform( IDirect3DDevice7* d3dDevice7, D3DTRANSFORMSTATETYPE dtstTransformStateType, LPD3DMATRIX lpD3DMatrix );
-HRESULT wSetTransform( IDirect3DDevice7* d3dDevice7, D3DTRANSFORMSTATETYPE dtstTransformStateType, LPD3DMATRIX lpD3DMatrix );
-HRESULT wBeginScene( IDirect3DDevice7* d3dDevice7 );
-HRESULT wEndScene( IDirect3DDevice7* d3dDevice7 );
-HRESULT wGetCaps( IDirect3DDevice7* d3dDevice7, LPD3DDEVICEDESC7 lpD3DHWDevDesc );
-HRESULT wSetRenderState( IDirect3DDevice7* d3dDevice7, D3DRENDERSTATETYPE dwRenderStateType, DWORD dwRenderState );
-HRESULT wEnumTextureFormats( IDirect3DDevice7* d3dDevice7, LPD3DENUMPIXELFORMATSCALLBACK lpd3dEnumPixelProc, void* lpArg );
-HRESULT wSetTexture( IDirect3DDevice7* d3dDevice7, DWORD dwStage, IDirectDrawSurface7* lpTexture );
-HRESULT wSetTextureStageState( IDirect3DDevice7* d3dDevice7, DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue );
-HRESULT wValidateDevice( IDirect3DDevice7* d3dDevice7, DWORD* ExtraPasses );
-HRESULT wLoad( IDirect3DDevice7* d3dDevice7, IDirectDrawSurface7* lpDestTex, LPPOINT lpDestPoint, IDirectDrawSurface7* lpSrcTex, LPRECT lprcSrcRect, DWORD dwFlags );
-HRESULT wSetViewport( IDirect3DDevice7* d3dDevice7, LPD3DVIEWPORT7 lpViewport );
-HRESULT wClear( IDirect3DDevice7* d3dDevice7, DWORD dwCount, LPD3DRECT lpRects, DWORD dwFlags, DWORD dwColor, D3DVALUE dvZ, DWORD dwStencil );
+//#ifdef LAB_ONLY
+HRESULT __stdcall wDrawPrimitive(LPDIRECT3DDEVICE7 d3dDevice7, D3DPRIMITIVETYPE dptPrimitiveType, ULONG dvtVertexType, PVOID lpvVertices, ULONG dwVertexCount, ULONG dwFlags );
+HRESULT __stdcall wDrawIndexedPrimitive(LPDIRECT3DDEVICE7 d3dDevice7, D3DPRIMITIVETYPE d3dptPrimitiveType, ULONG dwVertexTypeDesc, PVOID pvVertices, ULONG dwVertexCount, PUSHORT pwIndices, ULONG dwIndexCount, ULONG dwFlags );
+//#else
+//#define wDrawPrimitive(d3dDevice7,dptPrimitiveType,dvtVertexType,lpvVertices,dwVertexCount,dwFlags ) d3dDevice7->DrawPrimitive( dptPrimitiveType,dvtVertexType,lpvVertices,dwVertexCount,dwFlags )
+//#define wDrawIndexedPrimitive(d3dDevice7,d3dptPrimitiveType,dwVertexTypeDesc,lpvVertices,dwVertexCount,lpwIndices,dwIndexCount,dwFlags ) d3dDevice7->DrawIndexedPrimitive(d3dptPrimitiveType,dwVertexTypeDesc,lpvVertices,dwVertexCount,lpwIndices,dwIndexCount,dwFlags )
+//#endif
+HRESULT __stdcall wDrawPrimitiveVB(LPDIRECT3DDEVICE7 d3dDevice7, D3DPRIMITIVETYPE d3dptPrimitiveType, LPDIRECT3DVERTEXBUFFER7 lpd3dVertexBuffer, ULONG dwStartVertex, ULONG dwNumVertices, ULONG dwFlags );
+HRESULT __stdcall wDrawIndexedPrimitiveVB(LPDIRECT3DDEVICE7 d3dDevice7, D3DPRIMITIVETYPE d3dptPrimitiveType, LPDIRECT3DVERTEXBUFFER7 lpd3dVertexBuffer, ULONG dwStartVertex, ULONG dwNumVertices, PUSHORT lpwIndices, ULONG dwIndexCount, ULONG dwFlags );
+HRESULT __stdcall wSetMaterial(LPDIRECT3DDEVICE7 d3dDevice7, LPD3DMATERIAL7 lpMaterial );
+HRESULT __stdcall wSetLight(LPDIRECT3DDEVICE7 d3dDevice7, ULONG dwLightIndex, LPD3DLIGHT7 lpLight );
+HRESULT __stdcall wLightEnable(LPDIRECT3DDEVICE7 d3dDevice7, ULONG dwLightIndex, UCHAR Enable );
+HRESULT __stdcall wMultiplyTransform(LPDIRECT3DDEVICE7 d3dDevice7, D3DTRANSFORMSTATETYPE dtstTransformStateType, LPD3DMATRIX lpD3DMatrix );
+HRESULT __stdcall wSetTransform(LPDIRECT3DDEVICE7 d3dDevice7, D3DTRANSFORMSTATETYPE dtstTransformStateType, LPD3DMATRIX lpD3DMatrix );
+HRESULT __stdcall wBeginScene(LPDIRECT3DDEVICE7 d3dDevice7 );
+HRESULT __stdcall wEndScene(LPDIRECT3DDEVICE7 d3dDevice7 );
+HRESULT __stdcall wGetCaps(LPDIRECT3DDEVICE7 d3dDevice7, LPD3DDEVICEDESC7 lpD3DHWDevDesc );
+HRESULT __stdcall wSetRenderState(LPDIRECT3DDEVICE7 d3dDevice7, D3DRENDERSTATETYPE dwRenderStateType, ULONG dwRenderState );
+HRESULT __stdcall wEnumTextureFormats(LPDIRECT3DDEVICE7 d3dDevice7, LPD3DENUMPIXELFORMATSCALLBACK lpd3dEnumPixelProc, PVOID lpArg );
+HRESULT __stdcall wSetTexture(LPDIRECT3DDEVICE7 d3dDevice7, ULONG dwStage, LPDIRECTDRAWSURFACE7 lpTexture );
+HRESULT __stdcall wSetTextureStageState(LPDIRECT3DDEVICE7 d3dDevice7, ULONG dwStage, D3DTEXTURESTAGESTATETYPE dwState, ULONG dwValue );
+HRESULT __stdcall wValidateDevice(LPDIRECT3DDEVICE7 d3dDevice7, PULONG pExtraPasses );
+HRESULT __stdcall wLoad(LPDIRECT3DDEVICE7 d3dDevice7, LPDIRECTDRAWSURFACE7 lpDestTex, LPPOINT lpDestPoint, LPDIRECTDRAWSURFACE7 lpSrcTex, LPRECT lprcSrcRect, ULONG dwFlags );
+HRESULT __stdcall wSetViewport(LPDIRECT3DDEVICE7 d3dDevice7, LPD3DVIEWPORT7 lpViewport );
+HRESULT __stdcall wClear(LPDIRECT3DDEVICE7 d3dDevice7, ULONG dwCount, LPD3DRECT lpRects, ULONG dwFlags, ULONG dwColor, D3DVALUE dvZ, ULONG dwStencil );
 
-//
 // IDirect3D7
-//
-HRESULT wCreateDevice( IDirect3D7* d3d7, REFCLSID rclsid, IDirectDrawSurface7* lpDDS, LPDIRECT3DDEVICE7* lplpD3DDevice7 );
-HRESULT wEnumZBufferFormats( IDirect3D7* d3d7, REFCLSID riidDevice, LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback, void* lpContext );
-HRESULT wEnumDevices( IDirect3D7* d3d7, LPD3DENUMDEVICESCALLBACK7 lpEnumDevicesCallback, LPVOID lpUserArg );
-HRESULT wCreateVertexBuffer( IDirect3D7* d3d7, LPD3DVERTEXBUFFERDESC lpVBDesc, LPDIRECT3DVERTEXBUFFER7* lplpD3DVertexBuffer, DWORD dwFlags );
+HRESULT __stdcall wCreateDevice(LPDIRECT3D7 d3d7, REFCLSID rclsid, LPDIRECTDRAWSURFACE7 lpDDS, LPDIRECT3DDEVICE7* lplpD3DDevice7 );
+HRESULT __stdcall wEnumZBufferFormats(LPDIRECT3D7 d3d7, REFCLSID riidDevice, LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback, PVOID pContext );
+HRESULT __stdcall wEnumDevices(LPDIRECT3D7 d3d7, LPD3DENUMDEVICESCALLBACK7 lpEnumDevicesCallback, PVOID lpUserArg );
+HRESULT __stdcall wCreateVertexBuffer(LPDIRECT3D7 d3d7, LPD3DVERTEXBUFFERDESC lpVBDesc, LPDIRECT3DVERTEXBUFFER7* lplpD3DVertexBuffer, ULONG dwFlags );
 
-//
 // IDirect3DVertexBuffer7
-//
-HRESULT wLock( IDirect3DVertexBuffer7* D3Dvb7, DWORD dwFlags, LPVOID* lplpData, LPDWORD lpdwSize );
-HRESULT wUnlock( IDirect3DVertexBuffer7* D3Dvb7 );
-HRESULT wOptimize( IDirect3DVertexBuffer7* D3Dvb7, LPDIRECT3DDEVICE7 lpD3DDevice, DWORD dwFlags );
-HRESULT wProcessVertices( IDirect3DVertexBuffer7* D3Dvb7, DWORD dwVertexOp, DWORD dwDestIndex, DWORD dwCount, LPDIRECT3DVERTEXBUFFER7 lpSrcBuffer, DWORD dwSrcIndex, LPDIRECT3DDEVICE7 lpD3DDevice, DWORD dwFlags );
+HRESULT __stdcall wLock(LPDIRECT3DVERTEXBUFFER7 D3Dvb7, ULONG dwFlags, PVOID* plpData, PULONG pdwSize );
+HRESULT __stdcall wUnlock(LPDIRECT3DVERTEXBUFFER7 D3Dvb7 );
+HRESULT __stdcall wOptimize(LPDIRECT3DVERTEXBUFFER7 D3Dvb7, LPDIRECT3DDEVICE7 lpD3DDevice, ULONG dwFlags );
+HRESULT __stdcall wProcessVertices(LPDIRECT3DVERTEXBUFFER7 D3Dvb7, ULONG dwVertexOp, ULONG dwDestIndex, ULONG dwCount, LPDIRECT3DVERTEXBUFFER7 lpSrcBuffer, ULONG dwSrcIndex, LPDIRECT3DDEVICE7 lpD3DDevice, ULONG dwFlags );
 
-//
 // Direct Draw
-//
-HRESULT wDirectDrawCreateEx( GUID* lpGUID, void** lplpDD, REFIID iid, IUnknown* pUnkOuter );
-HRESULT wDirectDrawEnumerate( LPDDENUMCALLBACK lpCallback,LPDDENUMCALLBACKEX lpCallbackEx,LPVOID lpContext );
-
-HRESULT wSetHWnd( LPDIRECTDRAWCLIPPER lpddc, DWORD dwFlags, HWND hWnd );
-
-HRESULT wIsLost( IDirectDrawSurface7* lpdds7 );
-HRESULT wGetDC( IDirectDrawSurface7* lpdds7, HDC* lphDC );
-HRESULT wReleaseDC( IDirectDrawSurface7* lpdds7, HDC hDC );
-HRESULT wSetColorKey( IDirectDrawSurface7* lpdd3, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
-HRESULT wLock( IDirectDrawSurface7* lpdd7, LPRECT lpDestRect, LPDDSURFACEDESC2 lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent );
-HRESULT wUnlock( IDirectDrawSurface7* lpdds7, LPRECT lprect );
-HRESULT wLock( IDirectDrawSurface* lpdds, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent );
-HRESULT wUnlock( IDirectDrawSurface* lpdds, LPRECT lprect );
-HRESULT wSetPalette( IDirectDrawSurface7* lpdd7, LPDIRECTDRAWPALETTE lpDDPalette );
-HRESULT wRestore( IDirectDrawSurface7* lpdd7);
-HRESULT wBlt( IDirectDrawSurface7* lpdd7, LPRECT lpDestRect, IDirectDrawSurface7* lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFx );
-HRESULT wBltFast( IDirectDrawSurface7* lpdd7, DWORD dwX, DWORD dwY, IDirectDrawSurface7* lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwTrans );
-HRESULT wFlip( IDirectDrawSurface7* lpdd7, IDirectDrawSurface7* lpDDSurfaceTargetOverride, DWORD dwFlags );
-HRESULT wGetSurfaceDesc( IDirectDrawSurface7* lpdd7, LPDDSURFACEDESC2 lpDDSurfaceDesc );
-HRESULT wGetSurfaceDesc( IDirectDrawSurface* lpdds, LPDDSURFACEDESC lpDDSurfaceDesc );
-HRESULT wGetAttachedSurface( IDirectDrawSurface7* lpdds7, LPDDSCAPS2 lpDDSCaps2, IDirectDrawSurface7** lplpDDAttachedSurface );
-HRESULT wGetPixelFormat( IDirectDrawSurface7* lpdds7, LPDDPIXELFORMAT lpDDPixelFormat );
-HRESULT wAddAttachedSurface( IDirectDrawSurface7* lpdd7, IDirectDrawSurface7* lpDDSAttachedSurface );
-HRESULT wDeleteAttachedSurface( IDirectDrawSurface7* lpdds7, DWORD dwFlags, IDirectDrawSurface7* lpDDSAttachedSurface );
-HRESULT wSetClipper( IDirectDrawSurface7* lpdd7, LPDIRECTDRAWCLIPPER lpDDClipper );
-
-HRESULT wGetDeviceIdentifier( IDirectDraw7* lpdd7, LPDDDEVICEIDENTIFIER2 lpdddi2, DWORD dwFlags );
-HRESULT wGetCaps( IDirectDraw7* lpdd7, LPDDCAPS lpDDDriverCaps, LPDDCAPS lpDDHELCaps );
-HRESULT wCreatePalette( IDirectDraw7* lpdd7,DWORD dwFlags,LPPALETTEENTRY lpColorTable,LPDIRECTDRAWPALETTE* lplpDDPalette, IUnknown* pUnkOuter );
-HRESULT wCreateSurface( IDirectDraw7* lpdd7, LPDDSURFACEDESC2 lpDDSurfaceDesc, IDirectDrawSurface7** lplpDDSurface7, IUnknown* pUnkOuter );
-HRESULT wSetCooperativeLevel( IDirectDraw7* lpdd7, HWND hWnd, DWORD dwFlags );
-HRESULT wEnumDisplayModes( IDirectDraw7* lpdd7,DWORD dwFlags,LPDDSURFACEDESC2 lpDDSurfaceDesc,LPVOID lpContext,LPDDENUMMODESCALLBACK2 lpEnumModesCallback );
-HRESULT wRestoreDisplayMode( IDirectDraw7* lpdd7 );
-HRESULT wGetDisplayMode( IDirectDraw7* lpdd7, LPDDSURFACEDESC2 lpDDSurfaceDesc );
-HRESULT wCreateClipper( IDirectDraw7* lpdd7, DWORD dwFlags, LPDIRECTDRAWCLIPPER* lplpDDClipper, IUnknown* pUnkOuter );
-HRESULT wSetDisplayMode(IDirectDraw7* lpdd7,DWORD dwWidth,DWORD dwHeight,DWORD dwBPP,DWORD dwRefreshRate,DWORD dwFlags );
-HRESULT wGetAvailableVidMem( IDirectDraw7* lpdd7, LPDDSCAPS2 lpDDSCaps2, LPDWORD lpdwTotal, LPDWORD lpdwFree );
-HRESULT wGetFourCCCodes( IDirectDraw7* lpdd7, LPDWORD lpNumCodes, LPDWORD lpCodes );
+HRESULT __stdcall wDirectDrawCreateEx( LPGUID lpGUID, PVOID* lplpDD, REFIID iid, IUnknown* pUnkOuter );
+HRESULT __stdcall wDirectDrawEnumerate( LPDDENUMCALLBACK lpCallback,LPDDENUMCALLBACKEX lpCallbackEx,PVOID lpContext );
+
+HRESULT __stdcall wSetHWnd( LPDIRECTDRAWCLIPPER lpddc, ULONG dwFlags, HWND hWnd );
+
+HRESULT __stdcall wIsLost( LPDIRECTDRAWSURFACE7 lpdds7 );
+HRESULT __stdcall wGetDC( LPDIRECTDRAWSURFACE7 lpdds7, HDC* lphDC );
+HRESULT __stdcall wReleaseDC( LPDIRECTDRAWSURFACE7 lpdds7, HDC hDC );
+HRESULT __stdcall wSetColorKey( LPDIRECTDRAWSURFACE7 lpdd3, ULONG dwFlags, LPDDCOLORKEY lpDDColorKey );
+HRESULT __stdcall wLock( LPDIRECTDRAWSURFACE7 lpdd7, LPRECT lpDestRect, LPDDSURFACEDESC2 lpDDSurfaceDesc, ULONG dwFlags, HANDLE hEvent );
+HRESULT __stdcall wUnlock( LPDIRECTDRAWSURFACE7 lpdds7, LPRECT lprect );
+HRESULT __stdcall wLock(LPDIRECTDRAWSURFACE lpdds, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, ULONG dwFlags, HANDLE hEvent );
+HRESULT __stdcall wUnlock(LPDIRECTDRAWSURFACE lpdds, LPRECT lprect );
+HRESULT __stdcall wSetPalette( LPDIRECTDRAWSURFACE7 lpdd7, LPDIRECTDRAWPALETTE lpDDPalette );
+HRESULT __stdcall wRestore( LPDIRECTDRAWSURFACE7 lpdd7);
+HRESULT __stdcall wBlt( LPDIRECTDRAWSURFACE7 lpdd7, LPRECT lpDestRect, LPDIRECTDRAWSURFACE7 lpDDSrcSurface, LPRECT lpSrcRect, ULONG dwFlags, LPDDBLTFX lpDDBltFx );
+HRESULT __stdcall wBltFast( LPDIRECTDRAWSURFACE7 lpdd7, ULONG dwX, ULONG dwY, LPDIRECTDRAWSURFACE7 lpDDSrcSurface, LPRECT lpSrcRect, ULONG dwTrans );
+HRESULT __stdcall wFlip( LPDIRECTDRAWSURFACE7 lpdd7, LPDIRECTDRAWSURFACE7 lpDDSurfaceTargetOverride, ULONG dwFlags );
+HRESULT __stdcall wGetSurfaceDesc( LPDIRECTDRAWSURFACE7 lpdd7, LPDDSURFACEDESC2 lpDDSurfaceDesc );
+HRESULT __stdcall wGetSurfaceDesc(LPDIRECTDRAWSURFACE lpdds, LPDDSURFACEDESC lpDDSurfaceDesc );
+HRESULT __stdcall wGetAttachedSurface( LPDIRECTDRAWSURFACE7 lpdds7, LPDDSCAPS2 lpDDSCaps2, LPDIRECTDRAWSURFACE7* lplpDDAttachedSurface );
+HRESULT __stdcall wGetPixelFormat( LPDIRECTDRAWSURFACE7 lpdds7, LPDDPIXELFORMAT lpDDPixelFormat );
+HRESULT __stdcall wAddAttachedSurface( LPDIRECTDRAWSURFACE7 lpdd7, LPDIRECTDRAWSURFACE7 lpDDSAttachedSurface );
+HRESULT __stdcall wDeleteAttachedSurface( LPDIRECTDRAWSURFACE7 lpdds7, ULONG dwFlags, LPDIRECTDRAWSURFACE7 lpDDSAttachedSurface );
+HRESULT __stdcall wSetClipper( LPDIRECTDRAWSURFACE7 lpdd7, LPDIRECTDRAWCLIPPER lpDDClipper );
+
+HRESULT __stdcall wGetDeviceIdentifier(LPDIRECTDRAW7 lpdd7, LPDDDEVICEIDENTIFIER2 lpdddi2, ULONG dwFlags );
+HRESULT __stdcall wGetCaps(LPDIRECTDRAW7 lpdd7, LPDDCAPS lpDDDriverCaps, LPDDCAPS lpDDHELCaps );
+HRESULT __stdcall wCreatePalette(LPDIRECTDRAW7 lpdd7,ULONG dwFlags,LPPALETTEENTRY lpColorTable,LPDIRECTDRAWPALETTE* lplpDDPalette, IUnknown* pUnkOuter );
+HRESULT __stdcall wCreateSurface(LPDIRECTDRAW7 lpdd7, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE7* lplpDDSurface7, IUnknown* pUnkOuter );
+HRESULT __stdcall wSetCooperativeLevel(LPDIRECTDRAW7 lpdd7, HWND hWnd, ULONG dwFlags );
+HRESULT __stdcall wEnumDisplayModes(LPDIRECTDRAW7 lpdd7,ULONG dwFlags,LPDDSURFACEDESC2 lpDDSurfaceDesc,PVOID lpContext,LPDDENUMMODESCALLBACK2 lpEnumModesCallback );
+HRESULT __stdcall wRestoreDisplayMode(LPDIRECTDRAW7 lpdd7 );
+HRESULT __stdcall wGetDisplayMode(LPDIRECTDRAW7 lpdd7, LPDDSURFACEDESC2 lpDDSurfaceDesc );
+HRESULT __stdcall wCreateClipper(LPDIRECTDRAW7 lpdd7, ULONG dwFlags, LPDIRECTDRAWCLIPPER* lplpDDClipper, IUnknown* pUnkOuter );
+HRESULT __stdcall wSetDisplayMode(LPDIRECTDRAW7 lpdd7,ULONG dwWidth,ULONG dwHeight,ULONG dwBPP,ULONG dwRefreshRate,ULONG dwFlags );
+HRESULT __stdcall wGetAvailableVidMem(LPDIRECTDRAW7 lpdd7, LPDDSCAPS2 lpDDSCaps2, PULONG lpdwTotal, PULONG lpdwFree );
+HRESULT __stdcall wGetFourCCCodes(LPDIRECTDRAW7 lpdd7, PULONG lpNumCodes, PULONG lpCodes );
 
-//
 // Direct Sound
-//
-HRESULT wDirectSoundEnumerate( LPDSENUMCALLBACK cb, void* vp );
-HRESULT wDirectSoundCreate( LPGUID lpGuid, LPDIRECTSOUND* ppDS, IUnknown* pUnkOuter );
-HRESULT wGetCaps( LPDIRECTSOUND ppDS, DSCAPS* dsc );
-HRESULT	wSetSpeakerConfig( LPDIRECTSOUND ppDS, DWORD dsflags );
-HRESULT	wGetSpeakerConfig( LPDIRECTSOUND ppDS, DWORD *dsflags );
-HRESULT wLock( IDirectSoundBuffer* lpdsb, DWORD dwWriteCursor, DWORD dwWriteBytes, void** lplpvAudioPtr1, LPDWORD lpdwAudioBytes1, void** lplpvAudioPtr2, LPDWORD lpdwAudioBytes2, DWORD dwFlags );
-HRESULT wUnlock( IDirectSoundBuffer* lpdsb, void* lplpvAudioPtr1, DWORD lpdwAudioBytes1, void* lplpvAudioPtr2, DWORD lpdwAudioBytes2 );
-HRESULT wGetVolume( IDirectSoundBuffer* lpdsb, LONG* vol );
-HRESULT wGetFrequency( IDirectSoundBuffer* lpdsb, DWORD* freq);
-HRESULT wGetPan( IDirectSoundBuffer* lpdsb, LONG* pan);
-HRESULT wSetVolume( IDirectSoundBuffer* lpdsb, LONG vol );
-HRESULT wSetFrequency( IDirectSoundBuffer* lpdsb, DWORD freq);
-HRESULT wSetPan( IDirectSoundBuffer* lpdsb, LONG pan);
-HRESULT wPlay( IDirectSoundBuffer* lpdsb, DWORD res1, DWORD res2, DWORD flags);
-HRESULT wStop( IDirectSoundBuffer* lpdsb);
-HRESULT wGetStatus( IDirectSoundBuffer* lpdsb, LPDWORD status);
-HRESULT wSetCurrentPosition( IDirectSoundBuffer* lpdsb, DWORD pos);
-HRESULT wGetCurrentPosition( IDirectSoundBuffer* lpdsb, LPDWORD lpdwCurrentPlayCursor, LPDWORD lpdwCurrentWriteCursor );
-HRESULT wCreateSoundBuffer( IDirectSound* lpds, LPCDSBUFFERDESC lpcDSBufferDesc, LPLPDIRECTSOUNDBUFFER lplpDirectSoundBuffer, IUnknown* pUnkOuter );
-HRESULT wSetFormat( IDirectSoundBuffer* lpdsb, LPCWAVEFORMATEX lpcfxFormat );
-HRESULT wGetCaps( LPDIRECTSOUNDBUFFER ppDSB, DSBCAPS* dsc );
-HRESULT wSetCooperativeLevel( IDirectSound* lpds, HWND hwnd, DWORD dwLevel );
-HRESULT wPlay( IDirectSoundBuffer* lpdsb, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags );
-HRESULT wSetRolloffFactor( IDirectSound3DListener* lpdsb, float dist, DWORD flag );
-HRESULT wSetDopplerFactor( IDirectSound3DListener* lpdsb, float dist, DWORD flag );
-HRESULT wSetDistanceFactor( IDirectSound3DListener* lpdsb, float dist, DWORD flag );
-HRESULT wSetOrientation( IDirectSound3DListener* lpdsb, float fx, float fy, float fz, float tx, float ty, float tz, DWORD flag );
-HRESULT wSetPosition( IDirectSound3DBuffer* lpdsb, float x, float y, float z, DWORD flag );
-HRESULT wSetPosition( IDirectSound3DListener* lpdsb, float x, float y, float z, DWORD flag );
-HRESULT wSetVelocity( IDirectSound3DBuffer* lpdsb, float x, float y, float z, DWORD flag );
-HRESULT wSetVelocity( IDirectSound3DListener* lpdsb, float x, float y, float z, DWORD flag );
-HRESULT wSetMinDistance( IDirectSound3DBuffer* lpdsb, float x, DWORD flag );
-HRESULT wSetMaxDistance( IDirectSound3DBuffer* lpdsb, float x, DWORD flag );
-HRESULT	wSetConeAngles( LPDIRECTSOUND3DBUFFER ppDSB3D, DWORD min, DWORD max, DWORD flag );
-HRESULT	wSetConeOrientation( LPDIRECTSOUND3DBUFFER ppDSB3D, float x, float y, float z, DWORD flag );
-HRESULT wCommitDeferredSettings( LPDIRECTSOUND3DLISTENER lpList );
-HRESULT wQuerySupport( LPKSPROPERTYSET lpPS, REFGUID rGUID, ULONG uLong, ULONG* support );
-HRESULT wSet( LPKSPROPERTYSET lpPS, REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength, LPVOID pPropertyData, ULONG ulDataLength );
-HRESULT wGetFormat( LPDIRECTSOUNDBUFFER lpdsb, LPWAVEFORMATEX lpwf, DWORD sizeIn, DWORD *sizeOut );
-HRESULT wSetAllParameters(IDirectSound3DBuffer * lpdsb, DS3DBUFFER * ds3d, DWORD flag);
-HRESULT wSetAllParameters(IDirectSound3DListener * lpdsb, DS3DLISTENER * ds3d, DWORD flag);
-HRESULT wDuplicateSoundBuffer(IDirectSound* lpds, LPDIRECTSOUNDBUFFER src, LPDIRECTSOUNDBUFFER * dst );
-
-//
+HRESULT __stdcall wDirectSoundEnumerate( LPDSENUMCALLBACK cb, PVOID vp );
+HRESULT __stdcall wDirectSoundCreate( LPGUID lpGuid, LPDIRECTSOUND* ppDS, IUnknown* pUnkOuter );
+HRESULT __stdcall wGetCaps( LPDIRECTSOUND ppDS, DSCAPS* dsc );
+HRESULT __stdcall wSetSpeakerConfig( LPDIRECTSOUND ppDS, ULONG dsflags );
+HRESULT __stdcall wGetSpeakerConfig( LPDIRECTSOUND ppDS, PULONG dsflags );
+HRESULT __stdcall wLock( LPDIRECTSOUNDBUFFER lpdsb, ULONG dwWriteCursor, ULONG dwWriteBytes, PVOID* lplpvAudioPtr1, PULONG lpdwAudioBytes1, PVOID* lplpvAudioPtr2, PULONG lpdwAudioBytes2, ULONG dwFlags );
+HRESULT __stdcall wUnlock( LPDIRECTSOUNDBUFFER lpdsb, PVOID lplpvAudioPtr1, ULONG lpdwAudioBytes1, PVOID lplpvAudioPtr2, ULONG lpdwAudioBytes2 );
+HRESULT __stdcall wGetVolume( LPDIRECTSOUNDBUFFER lpdsb, LONG* vol );
+HRESULT __stdcall wGetFrequency( LPDIRECTSOUNDBUFFER lpdsb, PULONG freq);
+HRESULT __stdcall wGetPan( LPDIRECTSOUNDBUFFER lpdsb, LONG* pan);
+HRESULT __stdcall wSetVolume( LPDIRECTSOUNDBUFFER lpdsb, LONG vol );
+HRESULT __stdcall wSetFrequency( LPDIRECTSOUNDBUFFER lpdsb, ULONG freq);
+HRESULT __stdcall wSetPan( LPDIRECTSOUNDBUFFER lpdsb, LONG pan);
+HRESULT __stdcall wPlay( LPDIRECTSOUNDBUFFER lpdsb, ULONG res1, ULONG res2, ULONG flags);
+HRESULT __stdcall wStop( LPDIRECTSOUNDBUFFER lpdsb);
+HRESULT __stdcall wGetStatus( LPDIRECTSOUNDBUFFER lpdsb, PULONG status);
+HRESULT __stdcall wSetCurrentPosition( LPDIRECTSOUNDBUFFER lpdsb, ULONG pos);
+HRESULT __stdcall wGetCurrentPosition( LPDIRECTSOUNDBUFFER lpdsb, PULONG lpdwCurrentPlayCursor, PULONG lpdwCurrentWriteCursor );
+HRESULT __stdcall wCreateSoundBuffer( LPDIRECTSOUND lpds, LPCDSBUFFERDESC lpcDSBufferDesc, LPLPDIRECTSOUNDBUFFER lplpDirectSoundBuffer, IUnknown* pUnkOuter );
+HRESULT __stdcall wSetFormat( LPDIRECTSOUNDBUFFER lpdsb, LPCWAVEFORMATEX lpcfxFormat );
+HRESULT __stdcall wGetCaps( LPDIRECTSOUNDBUFFER ppDSB, DSBCAPS* dsc );
+HRESULT __stdcall wSetCooperativeLevel( LPDIRECTSOUND lpds, HWND hwnd, ULONG dwLevel );
+HRESULT __stdcall wPlay( LPDIRECTSOUNDBUFFER lpdsb, ULONG dwReserved1, ULONG dwReserved2, ULONG dwFlags );
+HRESULT __stdcall wSetRolloffFactor( LPDIRECTSOUND3DLISTENER lpdsb, float dist, ULONG flag );
+HRESULT __stdcall wSetDopplerFactor( LPDIRECTSOUND3DLISTENER lpdsb, float dist, ULONG flag );
+HRESULT __stdcall wSetDistanceFactor( LPDIRECTSOUND3DLISTENER lpdsb, float dist, ULONG flag );
+HRESULT __stdcall wSetOrientation( LPDIRECTSOUND3DLISTENER lpdsb, float fx, float fy, float fz, float tx, float ty, float tz, ULONG flag );
+HRESULT __stdcall wSetPosition( LPDIRECTSOUND3DBUFFER lpdsb, float x, float y, float z, ULONG flag );
+HRESULT __stdcall wSetPosition( LPDIRECTSOUND3DLISTENER lpdsb, float x, float y, float z, ULONG flag );
+HRESULT __stdcall wSetVelocity( LPDIRECTSOUND3DBUFFER lpdsb, float x, float y, float z, ULONG flag );
+HRESULT __stdcall wSetVelocity( LPDIRECTSOUND3DLISTENER lpdsb, float x, float y, float z, ULONG flag );
+HRESULT __stdcall wSetMinDistance( LPDIRECTSOUND3DBUFFER lpdsb, float x, ULONG flag );
+HRESULT __stdcall wSetMaxDistance( LPDIRECTSOUND3DBUFFER lpdsb, float x, ULONG flag );
+HRESULT __stdcall wSetConeAngles( LPDIRECTSOUND3DBUFFER ppDSB3D, ULONG min, ULONG max, ULONG flag );
+HRESULT __stdcall wSetConeOrientation( LPDIRECTSOUND3DBUFFER ppDSB3D, float x, float y, float z, ULONG flag );
+HRESULT __stdcall wCommitDeferredSettings( LPDIRECTSOUND3DLISTENER lpList );
+HRESULT __stdcall wQuerySupport( LPKSPROPERTYSET lpPS, REFGUID rGUID, ULONG uLong, PULONG support );
+HRESULT __stdcall wSet( LPKSPROPERTYSET lpPS, REFGUID rguidPropSet, ULONG ulId, PVOID pInstanceData, ULONG ulInstanceLength, PVOID pPropertyData, ULONG ulDataLength );
+HRESULT __stdcall wGetFormat( LPDIRECTSOUNDBUFFER lpdsb, LPWAVEFORMATEX lpwf, ULONG sizeIn, PULONG sizeOut );
+HRESULT __stdcall wSetAllParameters(LPDIRECTSOUND3DBUFFER lpdsb, DS3DBUFFER * ds3d, ULONG flag);
+HRESULT __stdcall wSetAllParameters(LPDIRECTSOUND3DLISTENER lpdsb, DS3DLISTENER * ds3d, ULONG flag);
+HRESULT __stdcall wDuplicateSoundBuffer(LPDIRECTSOUND lpds, LPDIRECTSOUNDBUFFER src, LPDIRECTSOUNDBUFFER * dst );
+
+typedef LONGLONG STREAM_TIME;
+typedef struct IMultiMediaStream*			PIMULTIMEDIASTREAM;
+typedef struct IDirectDrawMediaStream*		PIDIRECTDRAWMEDIASTREAM;
+typedef struct IAMMultiMediaStream*			PIAMMULTIMEDIASTREAM;
+typedef struct IMediaStream*				PIMEDIASTREAM;
+typedef struct IGraphBuilder*				PIGRAPHBUILDER;
+
+#if _CONSIDERED_OBSOLETE
 // Direct Show
-//
-HRESULT wSetState( IMultiMediaStream* imms, STREAM_STATE NewState );
-HRESULT wGetState( IMultiMediaStream* imms, STREAM_STATE * NewState );
-HRESULT wSeek( IMultiMediaStream* imms, STREAM_TIME SeekTime );
-HRESULT wGetTime( IMultiMediaStream* imms, STREAM_TIME* SeekTime );
-HRESULT wGetDuration( IMultiMediaStream* imms, STREAM_TIME *theTime );
-HRESULT wGetMediaStream( IMultiMediaStream* imms, REFMSPID idPurpose, IMediaStream** pMediaStream );
-
-HRESULT wInitialize( IAMMultiMediaStream* iammms, STREAM_TYPE StreamType, DWORD dwFlags, IGraphBuilder* pFilterGraph );
-HRESULT wAddMediaStream( IAMMultiMediaStream* iammms, IUnknown* pStreamObject, const MSPID *pPurposeID, DWORD dwFlags, IMediaStream** ppNewStream );
-HRESULT wOpenFile( IAMMultiMediaStream* iammms, LPCWSTR pszFileName, DWORD dwFlags );
-
-HRESULT wCreateSample( IDirectDrawMediaStream* iddms, IDirectDrawSurface* pSurface, const RECT *pRect, DWORD dwFlags, IDirectDrawStreamSample** ppSample );
-HRESULT wGetSurface( IDirectDrawStreamSample* iddss, IDirectDrawSurface ** ppDirectDrawSurface, RECT* pRect );
-
-HRESULT wSetFormat( IDirectDrawMediaStream* iddss, DDSURFACEDESC* ddsd );
-HRESULT wGetFormat( IDirectDrawMediaStream* iddss, DDSURFACEDESC* ddsd_current, DDSURFACEDESC* ddsd_desired, DWORD* flags );
-HRESULT wSetSampleTimes( IStreamSample* iddss, STREAM_TIME* st1, STREAM_TIME* st2 );
-HRESULT wUpdate( IStreamSample* iss, DWORD flags, HANDLE event, PAPCFUNC papcfunc, DWORD apc );
-HRESULT wGetFilterGraph( IAMMultiMediaStream* iamms, IGraphBuilder** igb );
-HRESULT wSetPositions( IMediaSeeking* ims, STREAM_TIME* st, DWORD stflags, STREAM_TIME* end, DWORD eflags );
-HRESULT wGetStopPosition( IMediaSeeking* ims, STREAM_TIME* st );
-HRESULT wGetSampleTimes( IDirectDrawStreamSample* iddss, STREAM_TIME* st, STREAM_TIME* end, STREAM_TIME* cur );
-
-HRESULT wPut_CurrentPosition( IMediaPosition* iba, REFTIME value );
-HRESULT wGet_CurrentPosition( IMediaPosition* iba, REFTIME *value );
-HRESULT wCanSeekForward( IMediaPosition* iba, LONG * canDo );
-HRESULT wGet_Duration( IMediaPosition* iba, REFTIME *value );
-HRESULT wStop( IMediaControl* iba );
-HRESULT wPause( IMediaControl* iba );
-HRESULT wRun( IMediaControl* iba );
-HRESULT wPut_Volume( IBasicAudio* iba, LONG value );
-HRESULT wPut_Balance( IBasicAudio* iba, LONG value );
-HRESULT wGetEndOfStreamEventHandle(IMultiMediaStream* imms, HANDLE * ph);
-HRESULT wGetInformation( IMultiMediaStream* imms, DWORD * flags, STREAM_TYPE *theType );
+HRESULT __stdcall wSetState( PIMULTIMEDIASTREAM imms, STREAM_STATE NewState );
+HRESULT __stdcall wGetState( PIMULTIMEDIASTREAM imms, STREAM_STATE * NewState );
+HRESULT __stdcall wSeek( PIMULTIMEDIASTREAM imms, STREAM_TIME SeekTime );
+HRESULT __stdcall wGetTime( PIMULTIMEDIASTREAM imms, STREAM_TIME* SeekTime );
+HRESULT __stdcall wGetDuration( PIMULTIMEDIASTREAM imms, STREAM_TIME *theTime );
+HRESULT __stdcall wGetMediaStream( PIMULTIMEDIASTREAM imms, REFMSPID idPurpose, PIMEDIASTREAM* pMediaStream );
+
+HRESULT __stdcall wInitialize( PIAMMULTIMEDIASTREAM iammms, STREAM_TYPE StreamType, ULONG dwFlags, PIGRAPHBUILDER pFilterGraph );
+HRESULT __stdcall wAddMediaStream( PIAMMULTIMEDIASTREAM iammms, IUnknown* pStreamObject, const MSPID *pPurposeID, ULONG dwFlags, PIMEDIASTREAM* ppNewStream );
+HRESULT __stdcall wOpenFile( PIAMMULTIMEDIASTREAM iammms, LPCWSTR pszFileName, ULONG dwFlags );
+
+HRESULT __stdcall wCreateSample( PIDIRECTDRAWMEDIASTREAM iddms,LPDIRECTDRAWSURFACE pSurface, const RECT *pRect, ULONG dwFlags, IDirectDrawStreamSample** ppSample );
+HRESULT __stdcall wGetSurface( IDirectDrawStreamSample* iddss, IDirectDrawSurface ** ppDirectDrawSurface, RECT* pRect );
+
+HRESULT __stdcall wSetFormat( PIDIRECTDRAWMEDIASTREAM iddss, DDSURFACEDESC* ddsd );
+HRESULT __stdcall wGetFormat( PIDIRECTDRAWMEDIASTREAM iddss, DDSURFACEDESC* ddsd_current, DDSURFACEDESC* ddsd_desired, PULONG flags );
+HRESULT __stdcall wSetSampleTimes( IStreamSample* iddss, STREAM_TIME* st1, STREAM_TIME* st2 );
+HRESULT __stdcall wUpdate( IStreamSample* iss, ULONG flags, HANDLE event, PAPCFUNC papcfunc, ULONG apc );
+HRESULT __stdcall wGetFilterGraph( PIAMMULTIMEDIASTREAM iamms, PIGRAPHBUILDER* igb );
+HRESULT __stdcall wSetPositions( IMediaSeeking* ims, STREAM_TIME* st, ULONG stflags, STREAM_TIME* end, ULONG eflags );
+HRESULT __stdcall wGetStopPosition( IMediaSeeking* ims, STREAM_TIME* st );
+HRESULT __stdcall wGetSampleTimes( IDirectDrawStreamSample* iddss, STREAM_TIME* st, STREAM_TIME* end, STREAM_TIME* cur );
+
+HRESULT __stdcall wPut_CurrentPosition( IMediaPosition* iba, REFTIME value );
+HRESULT __stdcall wGet_CurrentPosition( IMediaPosition* iba, REFTIME *value );
+HRESULT __stdcall wCanSeekForward( IMediaPosition* iba, LONG * canDo );
+HRESULT __stdcall wGet_Duration( IMediaPosition* iba, REFTIME *value );
+HRESULT __stdcall wStop( IMediaControl* iba );
+HRESULT __stdcall wPause( IMediaControl* iba );
+HRESULT __stdcall wRun( IMediaControl* iba );
+HRESULT __stdcall wPut_Volume( IBasicAudio* iba, LONG value );
+HRESULT __stdcall wPut_Balance( IBasicAudio* iba, LONG value );
+HRESULT __stdcall wGetEndOfStreamEventHandle(PIMULTIMEDIASTREAM imms, HANDLE * ph);
+HRESULT __stdcall wGetInformation( PIMULTIMEDIASTREAM imms, PULONG  flags, STREAM_TYPE *theType );
+#endif
 
 //
 // Direct Input
 //
-HRESULT wDirectInputCreateEx( HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, void** ppvOut, LPUNKNOWN punkOuter );
-HRESULT wCreateDeviceEx( IDirectInput7* lpdi, REFGUID rguid, REFIID riid, void** lplpDirectInputDevice, LPUNKNOWN pUnkOuter );
-HRESULT wSetDataFormat( IDirectInputDevice7* dev, LPCDIDATAFORMAT lpdf );
-HRESULT wSetCooperativeLevel( IDirectInputDevice7* dev, HWND hwnd, DWORD dwFlags );
-HRESULT wUnacquire( IDirectInputDevice7* dev );
-HRESULT wAcquire( IDirectInputDevice7* dev );
-HRESULT wGetDeviceState( IDirectInputDevice7* dev, DWORD cbData, LPVOID lpvData );
-HRESULT wEnumDevices( IDirectInput7* di, DWORD dwDevType, LPDIENUMDEVICESCALLBACK lpCallback, LPVOID pvRef, DWORD dwFlags );
-HRESULT wSetProperty( IDirectInputDevice7* dev, REFGUID rguidProp, LPCDIPROPHEADER pdiph );
-HRESULT wGetDeviceInfo( IDirectInputDevice7* dev, LPDIDEVICEINSTANCE pdidi );
-HRESULT wGetCapabilities( IDirectInputDevice7* dev, LPDIDEVCAPS lpDIDevCaps );
-HRESULT wGetDeviceData( IDirectInputDevice7* dev, DWORD cbObjectData, LPDIDEVICEOBJECTDATA rgdod, LPDWORD pdwInOut, DWORD dwFlags );
-HRESULT wPoll( IDirectInputDevice7* lpdid2 );
-HRESULT wCreateEffect( IDirectInputDevice7* lpdid2, REFGUID rguid, LPCDIEFFECT lpeff, LPDIRECTINPUTEFFECT* ppdeff, LPUNKNOWN punkOuter );
-HRESULT wStart( IDirectInputEffect* lpeff, DWORD iterations, DWORD flags );
-HRESULT wStop( IDirectInputEffect* lpeff );
-HRESULT wGetEffectStatus( IDirectInputEffect* lpeff, DWORD * status );
-HRESULT wDownload( IDirectInputEffect* lpeff );
-HRESULT wSetParameters( IDirectInputEffect* lpeff, LPCDIEFFECT lpdi, DWORD flags );
-
-
-
-//
+HRESULT __stdcall wDirectInputCreateEx( HINSTANCE hinst, ULONG dwVersion, REFIID riidltf, PVOID* ppvOut, LPUNKNOWN punkOuter );
+HRESULT __stdcall wCreateDeviceEx( LPDIRECTINPUT7 lpdi, REFGUID rguid, REFIID riid, PVOID* lplpDirectInputDevice, LPUNKNOWN pUnkOuter );
+HRESULT __stdcall wSetDataFormat( LPDIRECTINPUTDEVICE7 dev, LPCDIDATAFORMAT lpdf );
+HRESULT __stdcall wSetCooperativeLevel( LPDIRECTINPUTDEVICE7 dev, HWND hwnd, ULONG dwFlags );
+HRESULT __stdcall wUnacquire( LPDIRECTINPUTDEVICE7 dev );
+HRESULT __stdcall wAcquire( LPDIRECTINPUTDEVICE7 dev );
+HRESULT __stdcall wGetDeviceState( LPDIRECTINPUTDEVICE7 dev, ULONG cbData, PVOID lpvData );
+HRESULT __stdcall wEnumDevices( LPDIRECTINPUT7 di, ULONG dwDevType, LPDIENUMDEVICESCALLBACK lpCallback, PVOID pvRef, ULONG dwFlags );
+HRESULT __stdcall wSetProperty( LPDIRECTINPUTDEVICE7 dev, REFGUID rguidProp, LPCDIPROPHEADER pdiph );
+HRESULT __stdcall wGetDeviceInfo( LPDIRECTINPUTDEVICE7 dev, LPDIDEVICEINSTANCE pdidi );
+HRESULT __stdcall wGetCapabilities( LPDIRECTINPUTDEVICE7 dev, LPDIDEVCAPS lpDIDevCaps );
+HRESULT __stdcall wGetDeviceData( LPDIRECTINPUTDEVICE7 dev, ULONG cbObjectData, LPDIDEVICEOBJECTDATA rgdod, PULONG pdwInOut, ULONG dwFlags );
+HRESULT __stdcall wPoll( LPDIRECTINPUTDEVICE7 lpdid2 );
+HRESULT __stdcall wCreateEffect( LPDIRECTINPUTDEVICE7 lpdid2, REFGUID rguid, LPCDIEFFECT lpeff, LPDIRECTINPUTEFFECT* ppdeff, LPUNKNOWN punkOuter );
+HRESULT __stdcall wStart( LPDIRECTINPUTEFFECT lpeff, ULONG iterations, ULONG flags );
+HRESULT __stdcall wStop( LPDIRECTINPUTEFFECT lpeff );
+HRESULT __stdcall wGetEffectStatus( LPDIRECTINPUTEFFECT lpeff, PULONG  status );
+HRESULT __stdcall wDownload( LPDIRECTINPUTEFFECT lpeff );
+HRESULT __stdcall wSetParameters( LPDIRECTINPUTEFFECT lpeff, LPCDIEFFECT lpdi, ULONG flags );
+
+
+#if _CONSIDERED_OBSOLETE
 // DirectPlay
-//
-HRESULT wAddPlayerToGroup( IDirectPlay4A* dplay4, DPID idGroup, DPID idPlayer );
-HRESULT wCancelMessage( IDirectPlay4A* dplay4, DWORD dwMsgID, DWORD dwFlags );
-HRESULT wCancelPriority( IDirectPlay4A* dplay4, DWORD dwMinPriority, DWORD dwMaxPriority, DWORD dwFlags );
-HRESULT wClose( IDirectPlay4A* dplay4 );
-HRESULT wCreateGroup( IDirectPlay4A* dplay4, LPDPID lpidGroup, LPDPNAME lpGroupName, LPVOID lpData, DWORD dwDataSize, DWORD dwFlags );
-HRESULT wCreateGroupInGroup( IDirectPlay4A* dplay4, DPID idParentGroup, LPDPID lpidGroup, LPDPNAME lpGroupName, LPVOID lpData, DWORD dwDataSize, DWORD dwFlags );
-HRESULT wCreatePlayer( IDirectPlay4A* dplay4, LPDPID lpidPlayer, LPDPNAME lpPlayerName, HANDLE hEvent, LPVOID lpData, DWORD dwDataSize, DWORD dwFlags );
-HRESULT wDeleteGroupFromGroup( IDirectPlay4A* dplay4, DPID idParentGroup, DPID idGroup );
-HRESULT wDeletePlayerFromGroup( IDirectPlay4A* dplay4, DPID idGroup, DPID idPlayer );
-HRESULT wDestroyGroup( IDirectPlay4A* dplay4, DPID idGroup );
-HRESULT wDestroyPlayer( IDirectPlay4A* dplay4, DPID idPlayer );
-HRESULT wEnumConnections( IDirectPlay4A* dplay4, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags );
-HRESULT wEnumGroupPlayers( IDirectPlay4A* dplay4, DPID idGroup, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, LPVOID lpContext, DWORD dwFlags );
-HRESULT wEnumGroups( IDirectPlay4A* dplay4, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, LPVOID lpContext, DWORD dwFlags );
-HRESULT wEnumGroupsInGroup( IDirectPlay4A* dplay4, DPID idGroup, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumCallback, LPVOID lpContext, DWORD dwFlags );
-HRESULT wEnumPlayers( IDirectPlay4A* dplay4, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, LPVOID lpContext, DWORD dwFlags );
-HRESULT wEnumSessions( IDirectPlay4A* dplay4, LPDPSESSIONDESC2 lpsd, DWORD dwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumSessionsCallback2, LPVOID lpContext, DWORD dwFlags );
-HRESULT wGetCaps( IDirectPlay4A* dplay4, LPDPCAPS lpDPCaps, DWORD dwFlags );
-HRESULT wGetGroupConnectionSettings( IDirectPlay4A* dplay4, DWORD dwFlags, DPID idGroup, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wGetGroupData( IDirectPlay4A* dplay4, DPID idGroup, LPVOID lpData, LPDWORD lpdwDataSize, DWORD dwFlags );
-HRESULT wGetGroupFlags( IDirectPlay4A* dplay4, DPID idGroup, LPDWORD lpdwFlags );
-HRESULT wGetGroupName( IDirectPlay4A* dplay4, DPID idGroup, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wGetGroupOwner( IDirectPlay4A* dplay4, DPID idGroup, LPDPID lpidOwner );
-HRESULT wGetGroupParent( IDirectPlay4A* dplay4, DPID idGroup, LPDPID lpidParent );
-HRESULT wGetMessageCount( IDirectPlay4A* dplay4, DPID idPlayer, LPDWORD lpdwCount );
-HRESULT wGetMessageQueue( IDirectPlay4A* dplay4, DPID idFrom, DPID idTo, DWORD dwFlags, LPDWORD lpdwNumMsgs, LPDWORD lpdwNumBytes );
-HRESULT wGetPlayerAccount( IDirectPlay4A* dplay4, DPID idPlayer, DWORD dwFlags, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wGetPlayerAddress( IDirectPlay4A* dplay4, DPID idPlayer, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wGetPlayerCaps( IDirectPlay4A* dplay4, DPID idPlayer, LPDPCAPS lpPlayerCaps, DWORD dwFlags );
-HRESULT wGetPlayerData( IDirectPlay4A* dplay4, DPID idPlayer, LPVOID lpData, LPDWORD lpdwDataSize, DWORD dwFlags );
-HRESULT wGetPlayerFlags( IDirectPlay4A* dplay4, DPID idPlayer, LPDWORD lpdwFlags );
-HRESULT wGetPlayerName( IDirectPlay4A* dplay4, DPID idPlayer, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wGetSessionDesc( IDirectPlay4A* dplay4, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wInitialize( IDirectPlay4A* dplay4, LPGUID lpGUID );
-HRESULT wInitializeConnection( IDirectPlay4A* dplay4, LPVOID lpConnection, DWORD dwFlags );
-HRESULT wOpen( IDirectPlay4A* dplay4, LPDPSESSIONDESC2 lpsd, DWORD dwFlags );
-HRESULT wReceive( IDirectPlay4A* dplay4, LPDPID lpidFrom, LPDPID lpidTo, DWORD dwFlags, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wSecureOpen( IDirectPlay4A* dplay4, LPCDPSESSIONDESC2 lpsd, DWORD dwFlags, LPCDPSECURITYDESC lpSecurity, LPCDPCREDENTIALS lpCredentials );
-HRESULT wSendChatMessage( IDirectPlay4A* dplay4, DPID idFrom, DPID idTo, DWORD dwFlags, LPDPCHAT lpChatMessage );
-HRESULT wSend( IDirectPlay4A* dplay4, DPID idFrom, DPID idTo, DWORD dwFlags, LPVOID lpData, DWORD dwDataSize );
-HRESULT wSendEx( IDirectPlay4A* dplay4, DPID idFrom, DPID idTo, DWORD dwFlags, LPVOID lpData, DWORD dwDataSize, DWORD dwPriority, DWORD dwTimeout, LPVOID lpContext, LPDWORD lpdwMsgID );
-HRESULT wSetGroupConnectionSettings( IDirectPlay4A* dplay4, DWORD dwFlags, DPID idGroup, LPDPLCONNECTION lpConnection );
-HRESULT wSetGroupData( IDirectPlay4A* dplay4, DPID idGroup, LPVOID lpData, DWORD dwDataSize, DWORD dwFlags );
-HRESULT wSetGroupName( IDirectPlay4A* dplay4, DPID idGroup, LPDPNAME lpGroupName, DWORD dwFlags );
-HRESULT wSetGroupOwner( IDirectPlay4A* dplay4, DPID idGroup, DPID idOwner );
-HRESULT wSetPlayerData( IDirectPlay4A* dplay4, DPID idPlayer, LPVOID lpData, DWORD dwDataSize, DWORD dwFlags );
-HRESULT wSetPlayerName( IDirectPlay4A* dplay4, DPID idPlayer, LPDPNAME lpPlayerName, DWORD dwFlags );
-HRESULT wSetSessionDesc( IDirectPlay4A* dplay4, LPDPSESSIONDESC2 lpSessDesc, DWORD dwFlags );
-HRESULT wStartSession( IDirectPlay4A* dplay4, DWORD dwFlags, DPID idGroup );
-
-
+HRESULT __stdcall wAddPlayerToGroup( IDirectPlay4A* dplay4, DPID idGroup, DPID idPlayer );
+HRESULT __stdcall wCancelMessage( IDirectPlay4A* dplay4, ULONG dwMsgID, ULONG dwFlags );
+HRESULT __stdcall wCancelPriority( IDirectPlay4A* dplay4, ULONG dwMinPriority, ULONG dwMaxPriority, ULONG dwFlags );
+HRESULT __stdcall wClose( IDirectPlay4A* dplay4 );
+HRESULT __stdcall wCreateGroup( IDirectPlay4A* dplay4, LPDPID lpidGroup, LPDPNAME lpGroupName, PVOID lpData, ULONG dwDataSize, ULONG dwFlags );
+HRESULT __stdcall wCreateGroupInGroup( IDirectPlay4A* dplay4, DPID idParentGroup, LPDPID lpidGroup, LPDPNAME lpGroupName, PVOID lpData, ULONG dwDataSize, ULONG dwFlags );
+HRESULT __stdcall wCreatePlayer( IDirectPlay4A* dplay4, LPDPID lpidPlayer, LPDPNAME lpPlayerName, HANDLE hEvent, PVOID lpData, ULONG dwDataSize, ULONG dwFlags );
+HRESULT __stdcall wDeleteGroupFromGroup( IDirectPlay4A* dplay4, DPID idParentGroup, DPID idGroup );
+HRESULT __stdcall wDeletePlayerFromGroup( IDirectPlay4A* dplay4, DPID idGroup, DPID idPlayer );
+HRESULT __stdcall wDestroyGroup( IDirectPlay4A* dplay4, DPID idGroup );
+HRESULT __stdcall wDestroyPlayer( IDirectPlay4A* dplay4, DPID idPlayer );
+HRESULT __stdcall wEnumConnections( IDirectPlay4A* dplay4, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, PVOID lpContext, ULONG dwFlags );
+HRESULT __stdcall wEnumGroupPlayers( IDirectPlay4A* dplay4, DPID idGroup, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, PVOID lpContext, ULONG dwFlags );
+HRESULT __stdcall wEnumGroups( IDirectPlay4A* dplay4, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, PVOID lpContext, ULONG dwFlags );
+HRESULT __stdcall wEnumGroupsInGroup( IDirectPlay4A* dplay4, DPID idGroup, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumCallback, PVOID lpContext, ULONG dwFlags );
+HRESULT __stdcall wEnumPlayers( IDirectPlay4A* dplay4, LPGUID lpguidInstance, LPDPENUMPLAYERSCALLBACK2 lpEnumPlayersCallback2, PVOID lpContext, ULONG dwFlags );
+HRESULT __stdcall wEnumSessions( IDirectPlay4A* dplay4, LPDPSESSIONDESC2 lpsd, ULONG dwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumSessionsCallback2, PVOID lpContext, ULONG dwFlags );
+HRESULT __stdcall wGetCaps( IDirectPlay4A* dplay4, LPDPCAPS lpDPCaps, ULONG dwFlags );
+HRESULT __stdcall wGetGroupConnectionSettings( IDirectPlay4A* dplay4, ULONG dwFlags, DPID idGroup, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wGetGroupData( IDirectPlay4A* dplay4, DPID idGroup, PVOID lpData, PULONG lpdwDataSize, ULONG dwFlags );
+HRESULT __stdcall wGetGroupFlags( IDirectPlay4A* dplay4, DPID idGroup, PULONG lpdwFlags );
+HRESULT __stdcall wGetGroupName( IDirectPlay4A* dplay4, DPID idGroup, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wGetGroupOwner( IDirectPlay4A* dplay4, DPID idGroup, LPDPID lpidOwner );
+HRESULT __stdcall wGetGroupParent( IDirectPlay4A* dplay4, DPID idGroup, LPDPID lpidParent );
+HRESULT __stdcall wGetMessageCount( IDirectPlay4A* dplay4, DPID idPlayer, PULONG lpdwCount );
+HRESULT __stdcall wGetMessageQueue( IDirectPlay4A* dplay4, DPID idFrom, DPID idTo, ULONG dwFlags, PULONG lpdwNumMsgs, PULONG lpdwNumBytes );
+HRESULT __stdcall wGetPlayerAccount( IDirectPlay4A* dplay4, DPID idPlayer, ULONG dwFlags, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wGetPlayerAddress( IDirectPlay4A* dplay4, DPID idPlayer, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wGetPlayerCaps( IDirectPlay4A* dplay4, DPID idPlayer, LPDPCAPS lpPlayerCaps, ULONG dwFlags );
+HRESULT __stdcall wGetPlayerData( IDirectPlay4A* dplay4, DPID idPlayer, PVOID lpData, PULONG lpdwDataSize, ULONG dwFlags );
+HRESULT __stdcall wGetPlayerFlags( IDirectPlay4A* dplay4, DPID idPlayer, PULONG lpdwFlags );
+HRESULT __stdcall wGetPlayerName( IDirectPlay4A* dplay4, DPID idPlayer, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wGetSessionDesc( IDirectPlay4A* dplay4, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wInitialize( IDirectPlay4A* dplay4, LPGUID lpGUID );
+HRESULT __stdcall wInitializeConnection( IDirectPlay4A* dplay4, PVOID lpConnection, ULONG dwFlags );
+HRESULT __stdcall wOpen( IDirectPlay4A* dplay4, LPDPSESSIONDESC2 lpsd, ULONG dwFlags );
+HRESULT __stdcall wReceive( IDirectPlay4A* dplay4, LPDPID lpidFrom, LPDPID lpidTo, ULONG dwFlags, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wSecureOpen( IDirectPlay4A* dplay4, LPCDPSESSIONDESC2 lpsd, ULONG dwFlags, LPCDPSECURITYDESC lpSecurity, LPCDPCREDENTIALS lpCredentials );
+HRESULT __stdcall wSendChatMessage( IDirectPlay4A* dplay4, DPID idFrom, DPID idTo, ULONG dwFlags, LPDPCHAT lpChatMessage );
+HRESULT __stdcall wSend( IDirectPlay4A* dplay4, DPID idFrom, DPID idTo, ULONG dwFlags, PVOID lpData, ULONG dwDataSize );
+HRESULT __stdcall wSendEx( IDirectPlay4A* dplay4, DPID idFrom, DPID idTo, ULONG dwFlags, PVOID lpData, ULONG dwDataSize, ULONG dwPriority, ULONG dwTimeout, PVOID lpContext, PULONG lpdwMsgID );
+HRESULT __stdcall wSetGroupConnectionSettings( IDirectPlay4A* dplay4, ULONG dwFlags, DPID idGroup, LPDPLCONNECTION lpConnection );
+HRESULT __stdcall wSetGroupData( IDirectPlay4A* dplay4, DPID idGroup, PVOID lpData, ULONG dwDataSize, ULONG dwFlags );
+HRESULT __stdcall wSetGroupName( IDirectPlay4A* dplay4, DPID idGroup, LPDPNAME lpGroupName, ULONG dwFlags );
+HRESULT __stdcall wSetGroupOwner( IDirectPlay4A* dplay4, DPID idGroup, DPID idOwner );
+HRESULT __stdcall wSetPlayerData( IDirectPlay4A* dplay4, DPID idPlayer, PVOID lpData, ULONG dwDataSize, ULONG dwFlags );
+HRESULT __stdcall wSetPlayerName( IDirectPlay4A* dplay4, DPID idPlayer, LPDPNAME lpPlayerName, ULONG dwFlags );
+HRESULT __stdcall wSetSessionDesc( IDirectPlay4A* dplay4, LPDPSESSIONDESC2 lpSessDesc, ULONG dwFlags );
+HRESULT __stdcall wStartSession( IDirectPlay4A* dplay4, ULONG dwFlags, DPID idGroup );
 
 // DirectPlay Lobby functions
 
-HRESULT wCreateAddress( IDirectPlayLobby3A* dplobby3, REFGUID guidSP, REFGUID guidDataType, LPCVOID lpData, DWORD dwDataSize, LPVOID lpAddress, LPDWORD lpdwAddressSize );
-HRESULT wCreateCompoundAddress( IDirectPlayLobby3A* dplobby3, LPDPCOMPOUNDADDRESSELEMENT lpElements, DWORD dwElementCount, LPVOID lpAddress, LPDWORD lpdwAddressSize );
-HRESULT wEnumAddress( IDirectPlayLobby3A* dplobby3, LPDPENUMADDRESSCALLBACK lpEnumAddressCallback, LPCVOID lpAddress, DWORD dwAddressSize, LPVOID lpContext );
-HRESULT wGetConnectionSettings( IDirectPlayLobby3A* dplobby3, DWORD dwAppID, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wReceiveLobbyMessage( IDirectPlayLobby3A* dplobby3, DWORD dwFlags, DWORD dwAppID, LPDWORD lpdwMessageFlags, LPVOID lpData, LPDWORD lpdwDataSize );
-HRESULT wRegisterApplication( IDirectPlayLobby3A* dplobby3, DWORD dwFlags, LPDPAPPLICATIONDESC lpAppDesc );
-HRESULT wRunApplication( IDirectPlayLobby3A* dplobby3, DWORD dwFlags, LPDWORD lpdwAppID, LPDPLCONNECTION lpConn, HANDLE hReceiveEvent );
-HRESULT wSendLobbyMessage( IDirectPlayLobby3A* dplobby3, DWORD dwFlags, DWORD dwAppID, LPVOID lpData, DWORD dwDataSize );
-HRESULT wSetConnectionSettings( IDirectPlayLobby3A* dplobby3, DWORD dwFlags, DWORD dwAppID, LPDPLCONNECTION lpConn );
-HRESULT wSetLobbyMessageEvent( IDirectPlayLobby3A* dplobby3, DWORD dwFlags, DWORD dwAppID, HANDLE hReceiveEvent );
-HRESULT wUnregisterApplication( IDirectPlayLobby3A* dplobby3, DWORD dwFlags, REFGUID guidApplication );
-HRESULT wWaitForConnectionSettings( IDirectPlayLobby3A* dplobby3, DWORD dwFlags );
-HRESULT wConnectEx( IDirectPlayLobby3A* dplobby3, DWORD dwFlags, REFIID riid, LPVOID *lplpDP, IUnknown* pUnk );
+HRESULT __stdcall wCreateAddress( IDirectPlayLobby3A* dplobby3, REFGUID guidSP, REFGUID guidDataType, LPCVOID lpData, ULONG dwDataSize, PVOID lpAddress, PULONG lpdwAddressSize );
+HRESULT __stdcall wCreateCompoundAddress( IDirectPlayLobby3A* dplobby3, LPDPCOMPOUNDADDRESSELEMENT lpElements, ULONG dwElementCount, PVOID lpAddress, PULONG lpdwAddressSize );
+HRESULT __stdcall wEnumAddress( IDirectPlayLobby3A* dplobby3, LPDPENUMADDRESSCALLBACK lpEnumAddressCallback, LPCVOID lpAddress, ULONG dwAddressSize, PVOID lpContext );
+HRESULT __stdcall wGetConnectionSettings( IDirectPlayLobby3A* dplobby3, ULONG dwAppID, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wReceiveLobbyMessage( IDirectPlayLobby3A* dplobby3, ULONG dwFlags, ULONG dwAppID, PULONG lpdwMessageFlags, PVOID lpData, PULONG lpdwDataSize );
+HRESULT __stdcall wRegisterApplication( IDirectPlayLobby3A* dplobby3, ULONG dwFlags, LPDPAPPLICATIONDESC lpAppDesc );
+HRESULT __stdcall wRunApplication( IDirectPlayLobby3A* dplobby3, ULONG dwFlags, PULONG lpdwAppID, LPDPLCONNECTION lpConn, HANDLE hReceiveEvent );
+HRESULT __stdcall wSendLobbyMessage( IDirectPlayLobby3A* dplobby3, ULONG dwFlags, ULONG dwAppID, PVOID lpData, ULONG dwDataSize );
+HRESULT __stdcall wSetConnectionSettings( IDirectPlayLobby3A* dplobby3, ULONG dwFlags, ULONG dwAppID, LPDPLCONNECTION lpConn );
+HRESULT __stdcall wSetLobbyMessageEvent( IDirectPlayLobby3A* dplobby3, ULONG dwFlags, ULONG dwAppID, HANDLE hReceiveEvent );
+HRESULT __stdcall wUnregisterApplication( IDirectPlayLobby3A* dplobby3, ULONG dwFlags, REFGUID guidApplication );
+HRESULT __stdcall wWaitForConnectionSettings( IDirectPlayLobby3A* dplobby3, ULONG dwFlags );
+HRESULT __stdcall wConnectEx( IDirectPlayLobby3A* dplobby3, ULONG dwFlags, REFIID riid, PVOID *lplpDP, IUnknown* pUnk );
+#endif


  ================================================
diff --git a/source/gameos/include/directxdebugging.hpp b/source/gameos/include/directxdebugging.hpp
index fabbc19..35bca40 100755
--- a/source/gameos/include/directxdebugging.hpp
+++ b/source/gameos/include/directxdebugging.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 DirectXDebugging.hpp											 //
 // Contents: DirectX Debug routines											 //
@@ -6,67 +5,71 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
+
+typedef ULONG	DPID;
+typedef DPID*	LPDPID;
 
+typedef struct DPNAME *LPDPNAME;
+typedef struct DPSESSIONDESC2 *LPDPSESSIONDESC2;
 
-//
 // DirectX Debugging support
-//
-char* GetSBStatus( DWORD Status );
-char* GetQSupport( ULONG Support );
-char* GetLightInfo( LPD3DLIGHT7 lpLight );
-char* GetMaterialInfo( LPD3DMATERIAL7 lpMaterial );
-char* GetTransformType( D3DTRANSFORMSTATETYPE dtstTransformStateType );
-char* GetApplyFlag( DWORD flag );
-char* GetPropertyItem( REFGUID rguid, LONG Item );
-char* GetPropertySet( REFGUID rguid );
-char* GetSurfaceCaps( LPDDSCAPS2 lpDDSCaps2 );
-char* GetInputDevice( DWORD Size );
-char* GetEnumPlayersInfo( LPGUID lpguidInstance, DWORD Flags );
-char* GetConnectionInfo( void* ConnectionInfo );
-char* GetNetworkMessage( NetPacket* pMessage );
-char* GetSendExInfo( DPID idFrom, DPID idTo, DWORD dwFlags, DWORD dwDataSize, DWORD dwPriority, DWORD dwTimeout, LPVOID lpContext, LPDWORD lpdwMsgID );
-char* GetSendInfo( DPID idFrom, DPID idTo, DWORD dwFlags, DWORD dwDataSize );
-char* GetReceivedData( LPDPID lpidFrom, LPVOID lpData, LPDWORD lpdwDataSize );
-char* GetReceiveFlags( DWORD dwFlags, LPDPID lpidFrom, LPDPID lpidTo );
-char* GetPlayerName( LPDPNAME lpPlayerName );
-char* GetCreatePlayerFlags( DWORD dwFlags );
-char* GetEnumSessionFlags( DWORD Timeout, DWORD Flags );
-char* GetDPSessionDesc2( LPDPSESSIONDESC2 desc );
-char* GetDPOpenFLags( DWORD Flags );
-char* GetVertexType( char* Buffer, DWORD VertexType );
-char* GetChanProp( DWORD Prop );
-char* GetWaveFormat( char* Buffer, LPCWAVEFORMATEX lpcfxFormat );
-char* GetDSoundCoopLevel( DWORD Level );
-char* GetFlipFlags( DWORD Flags );
-char* GetStageSet( D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue );
-char* GetRectangle( char* Buffer, LPRECT lp );
-char* GetDIDevice( REFGUID rguid );
-char* GetRenderState( DWORD RenderState, DWORD Value );
-char* GetDrawPrimitiveData( D3DPRIMITIVETYPE dptPrimitiveType, DWORD dvtVertexType, LPVOID lpvVertices, DWORD dwVertexCount, DWORD dwFlags );
-char* GetDrawIndexedPrimitiveData( D3DPRIMITIVETYPE d3dptPrimitiveType, DWORD dwVertexTypeDesc, LPVOID lpvVertices, DWORD dwVertexCount, LPWORD lpwIndices, DWORD dwIndexCount, DWORD dwFlags );
-char* GetClearArea( DWORD dwCount, LPD3DRECT lpRects, DWORD dwFlags );
-char* GetSurfaceDescription( LPDDSURFACEDESC2 pSD );
-char* GetSurfaceDescriptionOld( LPDDSURFACEDESC pSD );
-char* GetGosPixelFormat( LPDDPIXELFORMAT pf );
-char* GetSetCooperativeLevelFlags( DWORD dwFlags );
-char* GetCreatePaletteFlags( DWORD dwFlags );
-char* GetEnumDisplayModeFlags( DWORD dwFlags );
-char* GetSetColorKeyFlags( DWORD dwFlags );
-char* GetLockFlags( DWORD dwFlags );
-char* Get3DDevice( REFCLSID rclsid );
-char* GetReturnInterface( REFIID riid );
-char* GetANSIfromUNICODE( const LPCWSTR Unicode );
-char* GetBltInformation( IDirectDrawSurface7* lpdd7, LPRECT lpDestRect, IDirectDrawSurface7* lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFx );
-char* GetBltFastInformation( IDirectDrawSurface7* lpdd7, DWORD dwX, DWORD dwY, IDirectDrawSurface7* lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwTrans );
-char* GetDIEnumFlags(DWORD flags);
-char* GetDICoopFlags(DWORD flags);
-char* GetDIGetDeviceDataFlags(DWORD dwFlags);
-char* GetDIInputFormat( LPCDIDATAFORMAT Format ); 
-char* GetDIDevType( DWORD DevType );
-char* DSGetStreamType(STREAM_TYPE StreamType);
-char* DSGetInitFlags(DWORD dwFlags);
-char* DSGetUpdateFlags(DWORD dwFlags);
-char* GetDSSpeakerConfig(DWORD dsFlags);
-char* GetDSBDFlags(DWORD dsFlags);
-char* GetDShowSeekType(DWORD seekFlag);
-char* GetEffectFlags(DWORD flags);
+PSTR __stdcall GetSBStatus( ULONG Status );
+PSTR __stdcall GetQSupport( ULONG Support );
+PSTR __stdcall GetLightInfo( LPD3DLIGHT7 lpLight );
+PSTR __stdcall GetMaterialInfo( LPD3DMATERIAL7 lpMaterial );
+PSTR __stdcall GetTransformType( D3DTRANSFORMSTATETYPE dtstTransformStateType );
+PSTR __stdcall GetApplyFlag( ULONG flag );
+PSTR __stdcall GetPropertyItem( REFGUID rguid, LONG Item );
+PSTR __stdcall GetPropertySet( REFGUID rguid );
+PSTR __stdcall GetSurfaceCaps( LPDDSCAPS2 lpDDSCaps2 );
+PSTR __stdcall GetInputDevice( ULONG Size );
+PSTR __stdcall GetEnumPlayersInfo( LPGUID lpguidInstance, ULONG Flags );
+PSTR __stdcall GetConnectionInfo( PVOID ConnectionInfo );
+PSTR __stdcall GetNetworkMessage( NetPacket* pMessage );
+PSTR __stdcall GetSendExInfo( DPID idFrom, DPID idTo, ULONG dwFlags, ULONG dwDataSize, ULONG dwPriority, ULONG dwTimeout, PVOID lpContext, PULONG lpdwMsgID );
+PSTR __stdcall GetSendInfo( DPID idFrom, DPID idTo, ULONG dwFlags, ULONG dwDataSize );
+PSTR __stdcall GetReceivedData( LPDPID lpidFrom, PVOID lpData, PULONG lpdwDataSize );
+PSTR __stdcall GetReceiveFlags( ULONG dwFlags, LPDPID lpidFrom, LPDPID lpidTo );
+PSTR __stdcall GetPlayerName( LPDPNAME lpPlayerName );
+PSTR __stdcall GetCreatePlayerFlags( ULONG dwFlags );
+PSTR __stdcall GetEnumSessionFlags( ULONG Timeout, ULONG Flags );
+PSTR __stdcall GetDPSessionDesc2( LPDPSESSIONDESC2 desc );
+PSTR __stdcall GetDPOpenFLags( ULONG Flags );
+PSTR __stdcall GetVertexType( PSTR Buffer, ULONG VertexType );
+PSTR __stdcall GetChanProp( ULONG Prop );
+PSTR __stdcall GetWaveFormat( PSTR Buffer, LPCWAVEFORMATEX lpcfxFormat );
+PSTR __stdcall GetDSoundCoopLevel( ULONG Level );
+PSTR __stdcall GetFlipFlags( ULONG dwFlags );
+PSTR __stdcall GetStageSet( D3DTEXTURESTAGESTATETYPE dwState, ULONG dwValue );
+PSTR __stdcall GetRectangle( PSTR Buffer, LPRECT lp );
+PSTR __stdcall GetDIDevice( REFGUID rguid );
+PSTR __stdcall GetRenderState( ULONG RenderState, ULONG Value );
+PSTR __stdcall GetDrawPrimitiveData( D3DPRIMITIVETYPE dptPrimitiveType, ULONG dvtVertexType, PVOID lpvVertices, ULONG dwVertexCount, ULONG dwFlags );
+PSTR __stdcall GetDrawIndexedPrimitiveData( D3DPRIMITIVETYPE d3dptPrimitiveType, ULONG dwVertexTypeDesc, PVOID lpvVertices, ULONG dwVertexCount, LPWORD lpwIndices, ULONG dwIndexCount, ULONG dwFlags );
+PSTR __stdcall GetClearArea( ULONG dwCount, LPD3DRECT lpRects, ULONG dwFlags );
+PSTR __stdcall GetSurfaceDescription( LPDDSURFACEDESC2 pSD );
+PSTR __stdcall GetSurfaceDescriptionOld( LPDDSURFACEDESC pSD );
+PSTR __stdcall GetGosPixelFormat( LPDDPIXELFORMAT pf );
+PSTR __stdcall GetSetCooperativeLevelFlags( ULONG dwFlags );
+PSTR __stdcall GetCreatePaletteFlags( ULONG dwFlags );
+PSTR __stdcall GetEnumDisplayModeFlags( ULONG dwFlags );
+PSTR __stdcall GetSetColorKeyFlags( ULONG dwFlags );
+PSTR __stdcall GetLockFlags( ULONG dwFlags );
+PSTR __stdcall Get3DDevice( REFCLSID rclsid );
+PSTR __stdcall GetReturnInterface( REFIID riid );
+PSTR __stdcall GetANSIfromUNICODE( const LPCWSTR Unicode );
+PSTR __stdcall GetBltInformation( LPDIRECTDRAWSURFACE7 lpdd7, LPRECT lpDestRect, LPDIRECTDRAWSURFACE7 lpDDSrcSurface, LPRECT lpSrcRect, ULONG dwFlags, LPDDBLTFX lpDDBltFx );
+PSTR __stdcall GetBltFastInformation( LPDIRECTDRAWSURFACE7 lpdd7, ULONG dwX, ULONG dwY, LPDIRECTDRAWSURFACE7 lpDDSrcSurface, LPRECT lpSrcRect, ULONG dwTrans );
+PSTR __stdcall GetDIEnumFlags(ULONG flags);
+PSTR __stdcall GetDICoopFlags(ULONG flags);
+PSTR __stdcall GetDIGetDeviceDataFlags(ULONG dwFlags);
+PSTR __stdcall GetDIInputFormat( LPCDIDATAFORMAT Format ); 
+PSTR __stdcall GetDIDevType( ULONG DevType );
+PSTR __stdcall DSGetStreamType(STREAM_TYPE StreamType);
+PSTR __stdcall DSGetInitFlags(ULONG dwFlags);
+PSTR __stdcall DSGetUpdateFlags(ULONG dwFlags);
+PSTR __stdcall GetDSSpeakerConfig(ULONG dsFlags);
+PSTR __stdcall GetDSBDFlags(ULONG dsFlags);
+PSTR __stdcall GetDShowSeekType(ULONG seekFlag);
+PSTR __stdcall GetEffectFlags(ULONG flags);


  ================================================
diff --git a/source/gameos/include/dllplatform.hpp b/source/gameos/include/dllplatform.hpp
index 3430bdb..992f03b 100755
--- a/source/gameos/include/dllplatform.hpp
+++ b/source/gameos/include/dllplatform.hpp
@@ -5,17 +5,18 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
+
 #define WIN32_EXTRA_LEAN			// Reduce windows header size
-#define VC_EXTRALEAN				// Reduce windows header size
 #include <windows.h>
-#include <GameOS\Platform.hpp>
-#include <GameOS\GameOS.hpp>
+#include <gameos\platform.hpp>
+#include <gameos\gameos.hpp>
 
 
-long _stdcall ProcessException( EXCEPTION_POINTERS* ep );
-void _stdcall InitExceptionHandler( char* CommandLine );
-void _stdcall InitGameOS( HINSTANCE hInstance, HWND hWindow, char* CommandLine );
-LRESULT CALLBACK GameOSWinProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
-DWORD _stdcall RunGameOSLogic();
-void _stdcall ExitGameOS();
+NTSTATUS _stdcall ProcessException( PEXCEPTION_POINTERS pep);
+void _stdcall InitExceptionHandler( PSTR CommandLine);
+void _stdcall InitGameOS( HINSTANCE hInstance, HWND hWindow, PSTR CommandLine);
+LRESULT _stdcall GameOSWinProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+ULONG _stdcall RunGameOSLogic(void);
+void _stdcall ExitGameOS(void);
 


  ================================================
diff --git a/source/gameos/include/dxrasterizer.hpp b/source/gameos/include/dxrasterizer.hpp
index cf830bf..60963b7 100755
--- a/source/gameos/include/dxrasterizer.hpp
+++ b/source/gameos/include/dxrasterizer.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 DXRasterizer.hpp												 //
 // Contents: DirectDraw Manager routines									 //
@@ -6,49 +5,41 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
 
+// videocard.cpp functions
+void __stdcall FindVideoCards(void);
+void __stdcall CreateCopyBuffers(void);
+void __stdcall RestoreAreas(void);
+void __stdcall DestroyDirtyRectangles(void);
+void __stdcall InvalidateVertexBuffers(void);
+void __stdcall ReCreateVertexBuffers(void);
 
-
-//
-// VideoCard.cpp functions
-//
-void FindVideoCards();
-
-
-void CreateCopyBuffers();
-void RestoreAreas();
-void DestroyDirtyRectangles();
-void InvalidateVertexBuffers();
-void ReCreateVertexBuffers();
-
-//
 // IME displays directly to backbuffer, that's why it's in DXRasterizer.hpp
-//
-void RenderIMEToBackBuffer(int POS_X, int POS_Y, float FONTHEIGHT);
+void __stdcall RenderIMEToBackBuffer(int POS_X, int POS_Y, float FONTHEIGHT);
 
-//
 // Variables for gamma correction
-//
-extern BYTE GammaTable[256];
+extern UCHAR GammaTable[256];
 extern float GammaSetting;
-extern bool UseGammaCorrection;
-extern DWORD GlobalWidth;
-extern DWORD GlobalHeight;
-extern bool GlobalZBuffer;
-extern bool GlobalFullScreen;
-HRESULT CALLBACK CheckEnumProc( DDPIXELFORMAT* ddpfPixelFormat, LPVOID lpContext );
-extern DWORD ValidTextures;
-extern void CopyBackBuffer( IDirectDrawSurface7* Dest, IDirectDrawSurface7* Source );
-extern bool ModeChanged;
-extern bool DebuggerUsed;
+extern UCHAR UseGammaCorrection;
+extern ULONG GlobalWidth;
+extern ULONG GlobalHeight;
+extern UCHAR GlobalZBuffer;
+extern UCHAR GlobalFullScreen;
+extern ULONG ValidTextures;
+extern UCHAR ModeChanged;
+extern UCHAR DebuggerUsed;
 extern DDSURFACEDESC2 BackBufferddsd;
-extern DWORD AllowBrightness;
-extern DWORD AllowContrast;
+extern ULONG AllowBrightness;
+extern ULONG AllowContrast;
+
+HRESULT __stdcall CheckEnumProc(DDPIXELFORMAT* ddpfPixelFormat, PVOID lpContext);
+extern void __stdcall CopyBackBuffer(LPDIRECTDRAWSURFACE7 Dest, LPDIRECTDRAWSURFACE7 Source);
+
 //
 // Compatibility flags for different video cards
 //
-enum
-{
+typedef enum __compatibilityconst {
 	SceneRenderer=1,				// Scene based renderer (PowerVR, Kyro etc...)
 	NoAlphaTest=1<<1,				// Disable alpha test (conflicts with other modes)
 	NoTriLinear=1<<2,				// Do not attempt trilinear filtering
@@ -82,28 +73,21 @@ enum
 //
 // This is the current cards compatiblity flags
 //
-extern DWORD Compatibility3D;
+extern ULONG Compatibility3D;
 
 //
 // Used to store all known video cards
 //
-typedef struct
-{
-	DWORD VendorID;						// Vendor ID, ie: S3=0x5333
-	DWORD DeviceID;						// Device ID, ie: ATI Rage=0x4750
-
-	DWORD DriverH;						// High and Low dword of driver version number (Windows 9x)
-	DWORD DriverL;
-
-	DWORD NTDriverH;					// High and Low dword of driver version number (Windows 2000)
-	DWORD NTDriverL;
-
-	char* VendorName;					// Friendly name for Vendor
-
-	char* CardName;						// Friendly name for card type
-
-	DWORD CompatibilityFlags;			// Flags that may alter how GameOS behaves
-
+typedef struct CardInfo {
+	ULONG VendorID;						// Vendor ID, ie: S3=0x5333
+	ULONG DeviceID;						// Device ID, ie: ATI Rage=0x4750
+	ULONG DriverH;						// High and Low dword of driver version number (Windows 9x)
+	ULONG DriverL;
+	ULONG NTDriverH;					// High and Low dword of driver version number (Windows 2000)
+	ULONG NTDriverL;
+	PSTR VendorName;					// Friendly name for Vendor
+	PSTR CardName;						// Friendly name for card type
+	ULONG CompatibilityFlags;			// Flags that may alter how GameOS behaves
 } CardInfo;
 
 extern CardInfo *KnownCards;
@@ -111,129 +95,112 @@ extern CardInfo *KnownCards;
 //
 // Used to store information about video cards in machine
 //
-typedef struct
-{
+typedef struct DeviceInfo {
 	GUID				DeviceGUID;
-
 	DDDEVICEIDENTIFIER2	DDid;					// Use DDid.szDescription for the readable name
-
-	DWORD				Empty;					// Bug in GetDeviceIdentifier - it overwrites the next 4 bytes!
-	
+	ULONG				Empty;					// Bug in GetDeviceIdentifier - it overwrites the next 4 bytes!
 	DDCAPS				DDCaps;
-
 	D3DDEVICEDESC7		D3DCaps;
-
 	char				FourCC[16*4];			// First 16 FourCC codes
-
 	DDPIXELFORMAT		TextureFormats[16];		// First 16 texture formats (ends in 0)
-
-	WORD				Modes16[16*2];			// First 16, 16 bit screen modes above 640*480
-	WORD				Refresh16[16];			// Refresh rates for above modes
-
-	WORD				Modes32[16*2];			// First 16, 32 bit screen modes above 640*480
-	WORD				Refresh32[16];			// Refresh rates for above modes
-
+	USHORT				Modes16[16*2];			// First 16, 16 bit screen modes above 640*480
+	USHORT				Refresh16[16];			// Refresh rates for above modes
+	USHORT				Modes32[16*2];			// First 16, 32 bit screen modes above 640*480
+	USHORT				Refresh32[16];			// Refresh rates for above modes
 	DDPIXELFORMAT		ZFormats[16];			// First 16 Z Buffer formats
-
-	DWORD				TotalVid;
-	DWORD				TotalLocalTex;
-	DWORD				TotalTex;
-
-	DWORD				MultitextureLightMap;			// Lightmap support
-	DWORD				MultitextureSpecularMap;		// Specular support
-	DWORD				MultitextureDetail;				// Detail support
-	DWORD				MultitextureLightMapFilter;		// Lightmap support (1=Disable trilinear)
-	DWORD				MultitextureSpecularMapFilter;	// Specular support (1=Disable trilinear)
-	DWORD				MultitextureDetailFilter;		// Detail support (1=Disable trilinear)
-
-	DWORD				CurrentCard;			// Which entry in the KnownCard array. (-1=Unknown)
-
-	bool				Failed60Hz;				// Set to only try full screen 60Hz once
-	bool				LinearMemory;			// Set if linear memory, not rectangular
+	ULONG				TotalVid;
+	ULONG				TotalLocalTex;
+	ULONG				TotalTex;
+	ULONG				MultitextureLightMap;			// Lightmap support
+	ULONG				MultitextureSpecularMap;		// Specular support
+	ULONG				MultitextureDetail;				// Detail support
+	ULONG				MultitextureLightMapFilter;		// Lightmap support (1=Disable trilinear)
+	ULONG				MultitextureSpecularMapFilter;	// Specular support (1=Disable trilinear)
+	ULONG				MultitextureDetailFilter;		// Detail support (1=Disable trilinear)
+	ULONG				CurrentCard;			// Which entry in the KnownCard array. (-1=Unknown)
+	UCHAR				Failed60Hz;				// Set to only try full screen 60Hz once
+	UCHAR				LinearMemory;			// Set if linear memory, not rectangular
+	UCHAR				_padding1[2];
 	int					MaxRefreshRate;			// Maximum refresh rate
-
-	char*				CurrentVendor;			// If vendor known, point to name, else 0
-
+	PSTR				CurrentVendor;			// If vendor known, point to name, else 0
 } DeviceInfo;
 
 extern DeviceInfo	DeviceArray[8];
 extern int			HardwareRenderer;			// Set when using a hardware renderer
 extern char DisplayInfoText[128];
 
-extern DWORD TripleBuffer;						// Copied from Environment for current card (so can be disabled on 3Dfx)
-extern DWORD StencilActive;
+extern ULONG TripleBuffer;						// Copied from Environment for current card (so can be disabled on 3Dfx)
+extern ULONG StencilActive;
 extern DDSURFACEDESC2 BBddsd;
 extern DDSURFACEDESC2 ZBddsd;
 
-extern IDirectDraw7*			DDobject;
-extern IDirectDraw7*			CurrentDDobject;
-extern IDirectDrawSurface7*		FrontBufferSurface;
-extern IDirectDrawSurface7*		BackBufferSurface;
-extern IDirectDrawSurface7*		ZBufferSurface;
-extern IDirectDrawSurface7*		g_RefBackBuffer;
-extern IDirectDrawSurface7*		g_CopyBackBuffer;
-extern IDirectDrawClipper*		g_lpDDClipper;
-extern IDirectDrawSurface7*		CopyTarget;
-extern IDirectDrawSurface7*		CopyZBuffer;
-extern IDirectDrawGammaControl*	GammaControlInterface;
-
-extern IDirect3D7*				d3d7;
-extern IDirect3DDevice7*		d3dDevice7;				// Current D3D Device
-extern IDirect3DDevice7*		Refd3dDevice7;			// Reference D3D Device
-extern IDirect3DDevice7*		Maind3dDevice7;			// Selected D3D Device
-extern IDirect3DDevice7*		RenderDevice;
-extern bool						InsideBeginScene;
-extern bool						NeedToInitRenderStates;
+extern LPDIRECTDRAW7			DDobject;
+extern LPDIRECTDRAW7			CurrentDDobject;
+extern LPDIRECTDRAWSURFACE7		FrontBufferSurface;
+extern LPDIRECTDRAWSURFACE7		BackBufferSurface;
+extern LPDIRECTDRAWSURFACE7		ZBufferSurface;
+extern LPDIRECTDRAWSURFACE7		g_RefBackBuffer;
+extern LPDIRECTDRAWSURFACE7		g_CopyBackBuffer;
+extern LPDIRECTDRAWCLIPPER		g_lpDDClipper;
+extern LPDIRECTDRAWSURFACE7		CopyTarget;
+extern LPDIRECTDRAWSURFACE7		CopyZBuffer;
+extern LPDIRECTDRAWGAMMACONTROL	GammaControlInterface;
+
+extern LPDIRECT3D7				d3d7;
+extern LPDIRECT3DDEVICE7		d3dDevice7;				// Current D3D Device
+extern LPDIRECT3DDEVICE7		Refd3dDevice7;			// Reference D3D Device
+extern LPDIRECT3DDEVICE7		Maind3dDevice7;			// Selected D3D Device
+extern LPDIRECT3DDEVICE7		RenderDevice;
+extern UCHAR					InsideBeginScene;
+extern UCHAR					NeedToInitRenderStates;
 extern int						HardwareRenderer;
-extern DWORD					BGColor;
+extern ULONG					BGColor;
 extern D3DDEVICEDESC7			CapsDirect3D;
 
 extern D3DVIEWPORT7				viewData;
 extern float					gosViewportMulX,gosViewportAddX,gosViewportMulY,gosViewportAddY;
-extern DWORD					NumDevices;
-extern DWORD					NumHWDevices;
-extern DWORD					NumMonitors;
-extern DWORD gosColorTable[];
-extern DWORD DepthResults[8];
-extern DWORD DepthPixels;
+extern ULONG					NumDevices;
+extern ULONG					NumHWDevices;
+extern ULONG					NumMonitors;
+extern ULONG gosColorTable[];
+extern ULONG DepthResults[8];
+extern ULONG DepthPixels;
 
-extern void InitRenderer();
-extern char* GetDirectXVersion();
+extern void __stdcall InitRenderer(void);
+extern PSTR __stdcall GetDirectXVersion(void);
 
 //
 // MipMapping flags
 //
-extern DWORD HasBiLinear;
-extern DWORD HasTriLinear;
+extern ULONG HasBiLinear;
+extern ULONG HasTriLinear;
 extern int HasTLHAL;
 //
 // Card specific changes triggered by these values
 //
-extern DWORD HasVertexBlending;
-extern DWORD HasClamp;
-extern DWORD HasFog;
-extern DWORD HasAlphaTest;
-extern DWORD HasAlphaModes;
-extern DWORD HasMultitextureLightmap;
-extern DWORD HasMultitextureSpecularmap;
-extern DWORD HasMultitextureDetailTexture;
-extern DWORD HasMultitextureLightmapFilter;
-extern DWORD HasMultitextureSpecularmapFilter;
-extern DWORD HasMultitextureDetailTextureFilter;
-
-void DisplayBackBuffer();
-void End3DScene();
-
-void RenderWithReferenceRasterizer( DWORD Type );
-void DirectDrawInstall();
-void ShowFrameGraphs();
-void DirectDrawUninstall();
-void DirectDrawCreateDDObject();
-BOOL CALLBACK DirectDrawEnumerateCallback( GUID* lpGUID, LPSTR, LPSTR, LPVOID lpContext );
-HRESULT CALLBACK DirectDrawEnumDisplayModesCallback( LPDDSURFACEDESC2 pddsd, LPVOID lpContext );
-void DirectDrawCreateAllBuffers();
-void EnterWindowMode();
-void EnterFullScreenMode();
-void RenderIMEtoScreen();
-
-
+extern ULONG HasVertexBlending;
+extern ULONG HasClamp;
+extern ULONG HasFog;
+extern ULONG HasAlphaTest;
+extern ULONG HasAlphaModes;
+extern ULONG HasMultitextureLightmap;
+extern ULONG HasMultitextureSpecularmap;
+extern ULONG HasMultitextureDetailTexture;
+extern ULONG HasMultitextureLightmapFilter;
+extern ULONG HasMultitextureSpecularmapFilter;
+extern ULONG HasMultitextureDetailTextureFilter;
+
+void __stdcall DisplayBackBuffer(void);
+void __stdcall End3DScene(void);
+
+void __stdcall RenderWithReferenceRasterizer(ULONG Type);
+void __stdcall DirectDrawInstall(void);
+void __stdcall ShowFrameGraphs(void);
+void __stdcall DirectDrawUninstall(void);
+void __stdcall DirectDrawCreateDDObject(void);
+BOOL __stdcall DirectDrawEnumerateCallback(GUID* lpGUID, PSTR, PSTR, PVOID lpContext);
+HRESULT __stdcall DirectDrawEnumDisplayModesCallback(LPDDSURFACEDESC2 pddsd, PVOID lpContext);
+void __stdcall DirectDrawCreateAllBuffers(void);
+void __stdcall EnterWindowMode(void);
+void __stdcall EnterFullScreenMode(void);
+void __stdcall RenderIMEtoScreen(void);


  ================================================
diff --git a/source/gameos/include/errorhandler.hpp b/source/gameos/include/errorhandler.hpp
index a0cc693..41bee25 100755
--- a/source/gameos/include/errorhandler.hpp
+++ b/source/gameos/include/errorhandler.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //==========================================================================//
 // File:	 ErrorHandler.hpp												//
 // Contents: error handling routines										//
@@ -6,10 +5,12 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "String.hpp"
+#pragma once
+
+#include "string.hpp"
 
 //JJ Fix-A-Roo
-typedef IDirect3DVertexBuffer7 * (WINAPI *GETDXFUNC)(IDirect3DVertexBuffer7 *, IDirect3DDevice7*);
+typedef LPDIRECT3DVERTEXBUFFER7 (__stdcall *GETDXFUNC)(LPDIRECT3DVERTEXBUFFER7, LPDIRECT3DDEVICE7);
 extern GETDXFUNC g_pGetDXVB;
 
 //
@@ -19,24 +20,26 @@ const int MAX_LINE_LENGTH=256;		// Maximum characters per line in a file (shown
 const int MAX_SUBJECT_LENGTH=128;	// Maximum length of email subject
 const int MAX_RAID_DESC=2048;		// Maximum length of the Raid description (may need to be longer to accomodate RTF info)
 
-extern DWORD DisableErrors;
-extern volatile WORD FPUControl;	// Current FPU control word
-extern WORD FPUDefault;				// Default FPU control word
-extern DWORD ShowFrame;
-extern void InitProcessorSpeed();
-extern char* GetProcessor();
+extern ULONG DisableErrors;
+extern volatile USHORT FPUControl;	// Current FPU control word
+extern USHORT FPUDefault;				// Default FPU control word
+extern ULONG ShowFrame;
 extern float L2SpeedR, L2SpeedW, L2SpeedRW, MainSpeedR, MainSpeedW, MainSpeedRW, VidMemR, VidMemW, VidMemRW, AGPMemR, AGPMemW, AGPMemRW;
 extern char SpeedBuffer[16];			// ASCII MHz
 extern float ProcessorSpeed;			// Processor speed
-void CheckLogFile();
 extern char LogBuffer[2048];
 extern HANDLE LoggingThreadID;
 extern bool ThreadDone;
-extern void ShowFTOL();
-extern void EnableSpewToFile();
-extern void DisableSpewToFile();
 extern bool InDebugger;						// During debugger rendering
 extern char CacheInformation[128];
+
+extern void __stdcall InitProcessorSpeed(void);
+extern PSTR __stdcall GetProcessor(void);
+extern void __stdcall EnableSpewToFile(void);
+extern void __stdcall DisableSpewToFile(void);
+extern void __stdcall CheckLogFile(void);
+extern void __stdcall ShowFTOL(void);
+
 //
 // Log file data types
 //
@@ -45,37 +48,36 @@ enum { Log_Invalid, Log_JoystickCount, Log_JoystickAxis, Log_JoystickButton, Log
 
 
 
-extern DWORD SpewWrites;
+extern ULONG SpewWrites;
 extern char DebuggerName[MAX_PATH+1];
 extern bool LaunchDebugger;
 extern int ScreenImageSize;
-char* GetFullErrorMessage( HWND hwnd );
-void WriteBitStream( DWORD Value, DWORD Bits, int Type );
-char* GetBugNotes( HWND hwnd );
-char* SendMail( HWND Window, char* Subject, char* Text, char* Bitmap, char* LogFile );
-DWORD ReadBitStream( DWORD Bits, int Type );
-void InitLogging();
-void DeleteLogging();
-void UpDateLogFile();
-void Spew( char* string );
-char* GetTime();
-char* GetExeTime();
-char* VersionNumber( char* Buffer, DWORD High, DWORD Low );
-BOOL IsDebuggerAvailable();
-void TriggerDebugger();
-char* gosGetUserName();
-void LogRun( char* Message );
-void InitRunLog();
-void GetInstalledAudioVideoCodecs( FixedLengthString& Buffer );
-void ReadLogData( BYTE* pData, DWORD Length );
-void WriteLogData( BYTE* pData, DWORD Length );
-
 
+PSTR __stdcall GetFullErrorMessage( HWND hwnd );
+void __stdcall WriteBitStream( ULONG Value, ULONG Bits, int Type );
+PSTR __stdcall GetBugNotes( HWND hwnd );
+PSTR __stdcall SendMail( HWND Window, PSTR Subject, PSTR Text, PSTR Bitmap, PSTR LogFile );
+ULONG __stdcall ReadBitStream( ULONG Bits, int Type );
+void __stdcall InitLogging(void);
+void __stdcall DeleteLogging(void);
+void __stdcall UpDateLogFile(void);
+void __stdcall Spew( PSTR string );
+PSTR __stdcall GetTime(void);
+PSTR __stdcall GetExeTime(void);
+PSTR __stdcall VersionNumber( PSTR Buffer, ULONG High, ULONG Low );
+BOOL __stdcall IsDebuggerAvailable(void);
+void __stdcall TriggerDebugger(void);
+PSTR __stdcall gosGetUserName(void);
+void __stdcall LogRun( PSTR Message );
+void __stdcall InitRunLog(void);
+void __stdcall GetInstalledAudioVideoCodecs( FixedLengthString& Buffer );
+void __stdcall ReadLogData( PUCHAR pData, ULONG Length );
+void __stdcall WriteLogData( PUCHAR pData, ULONG Length );
 
 typedef struct _pFTOL
 {
 	_pFTOL* pNext;
-	DWORD	Heap[6];
+	ULONG	Heap[6];
 
 } pFTOL;
 
@@ -87,38 +89,42 @@ extern pFTOL* ListOfFTOL;
 //
 // Routines dealing with floating point precision
 //
-void CheckPrecision();
+void CheckPrecision(void);
 
 
 
 //
 // Playback/Record mode?
 //
-extern DWORD LogMode;								// 0=Logging, 1=Playback
-void ShowLogFileControls();
+extern ULONG LogMode;								// 0=Logging, 1=Playback
+void __stdcall ShowLogFileControls(void);
 
 
+typedef struct _IMAGEHLP_LINE *PIMAGEHLP_LINE;
+typedef struct _tagSTACKFRAME *LPSTACKFRAME;
 
 
 //
 // Machine Details
 //
-void ScanCards( FixedLengthString& Buffer );
+void __stdcall ScanCards( FixedLengthString& Buffer );
 
 //
 // Functions in imagehlp.cpp
 //
-void _stdcall InitExceptionHandler( char* CommandLine );
-void DestroyImageHlp();
-char* GetSymbolFromAddress( char* Buffer, int Address );
-char* GetLocationFromAddress( IMAGEHLP_LINE* pline, char* Buffer, int Address );
-void InitStackWalk( STACKFRAME* sf, CONTEXT* Context );
-int WalkStack( STACKFRAME* sf );
-extern DWORD LastOffset;
-extern STACKFRAME ImageHlp_sf;
-extern IMAGEHLP_LINE ImageHlp_pline;
-char* GetExceptionCode( EXCEPTION_RECORD* er );
-void GetEnvironmentSettings( char* CommandLine );
+void __stdcall InitExceptionHandler( PSTR CommandLine );
+void __stdcall DestroyImageHlp(void);
+PSTR __stdcall GetSymbolFromAddress( PSTR Buffer, int Address );
+PSTR __stdcall GetLocationFromAddress(PIMAGEHLP_LINE pline, PSTR Buffer, int Address );
+void __stdcall InitStackWalk(LPSTACKFRAME sf, PCONTEXT Context );
+int __stdcall WalkStack(LPSTACKFRAME sf );
+
+extern ULONG LastOffset;
+//extern STACKFRAME ImageHlp_sf;
+//extern IMAGEHLP_LINE ImageHlp_pline;
+
+PSTR __stdcall GetExceptionCode( PEXCEPTION_RECORD per );
+void __stdcall GetEnvironmentSettings( PSTR CommandLine );
 
 //
 // Context information
@@ -137,27 +143,29 @@ extern float OneOverProcessorSpeed;
 // Used to setup the ErrorDialogProc
 //
 extern int ErrorFlags;
-extern char* ErrorTitle;
-extern char* ErrorMessage;
-extern char* ErrorMessageTitle;
-long _stdcall ProcessException( EXCEPTION_POINTERS* ep );
-char* ErrorNumberToMessage( int hResult );
+extern PSTR ErrorTitle;
+extern PSTR ErrorMessage;
+extern PSTR ErrorMessageTitle;
 extern volatile int ProcessingError;				// Renentrancy test flag for assert error routine
-extern char* ErrorExceptionText;
-extern char* Hex8Number( int Number );
-extern void GetProcessorDetails( STACKFRAME* sf, FixedLengthString& Buffer );
-extern void GetMachineDetails( FixedLengthString& Buffer );
-extern char* GetLineFromFile( char* tempLine, char* FileName, int LineNumber );
-extern BYTE* GotScreenImage;					// Pointer to buffer containing screen image (always 24 bit bmp)
-extern BYTE* GrabScreenImage();
-extern void GetDirectXDetails( FixedLengthString& Buffer );
-extern void GetGameDetails( FixedLengthString& Buffer, DWORD ErrorFlags );
+extern PSTR ErrorExceptionText;
+extern PUCHAR GotScreenImage;					// Pointer to buffer containing screen image (always 24 bit bmp)
 extern int AllowDebugButton;
-extern void DoDetailedDialog();
-extern void DoSimpleDialog();
-extern void DoColorDialog();
 extern int ErrorFlags,ErrorReturn;
-bool WriteLogFile( char* FileName );
+
+extern NTSTATUS __stdcall ProcessException( PEXCEPTION_POINTERS ep );
+extern PSTR __stdcall ErrorNumberToMessage( int hResult );
+extern PSTR __stdcall Hex8Number( int Number );
+extern void __stdcall GetProcessorDetails(LPSTACKFRAME sf, FixedLengthString& Buffer );
+extern void __stdcall GetMachineDetails( FixedLengthString& Buffer );
+extern PSTR __stdcall GetLineFromFile( PSTR tempLine, PSTR FileName, int LineNumber );
+extern PUCHAR __stdcall GrabScreenImage(void);
+extern void __stdcall GetDirectXDetails( FixedLengthString& Buffer );
+extern void __stdcall GetGameDetails( FixedLengthString& Buffer, ULONG ErrorFlags );
+extern void __stdcall DoDetailedDialog(void);
+extern void __stdcall DoSimpleDialog(void);
+extern void __stdcall DoColorDialog(void);
+
+bool __stdcall WriteLogFile( PSTR FileName );
 
 
 
@@ -182,7 +190,7 @@ bool WriteLogFile( char* FileName );
 typedef struct _IgnoreAddress
 {
 	_IgnoreAddress*	pNext;
-	DWORD			Address;
+	ULONG			Address;
 } IgnoreAddress;
 
 
@@ -191,8 +199,7 @@ extern IgnoreAddress*	pIgnore;
 
 
 #pragma pack(push,1)
-typedef struct _LogStruct
-{
+typedef struct _LogStruct {
 //
 // Store time at top of loop
 //
@@ -206,24 +213,23 @@ typedef struct _LogStruct
 	int			pXDelta;
 	int			pYDelta;
 	int			pWheelDelta;
-	BYTE		pButtonsPressed;
-	WORD		Length;							// Length of bitstream (or 0)
+	UCHAR		pButtonsPressed;
+	USHORT		Length;							// Length of bitstream (or 0)
 } LogStructure;
 #pragma pack(pop)
 
 
-typedef struct
-{
-	DWORD			Magic;							// Magic number for valid log file
-	DWORD			Version;						// Version number of log file data
+typedef struct _LogHeader {
+	ULONG			Magic;							// Magic number for valid log file
+	ULONG			Version;						// Version number of log file data
 	char			GameName[32];					// Name of application being logged
 	char			AppPath[256];					// Path of application being logged
 	char			CommandLine[128];				// Command line passed to App
 	char			UserName[32];					// Username who created log
 	char			LogDate[64];					// Date/Time log created
 	char			ExeDate[64];					// Date/Time exe file used to create log
-	DWORD			Frames;							// Number of frames of data
-	DWORD			Length;							// Size of logging information
+	ULONG			Frames;							// Number of frames of data
+	ULONG			Length;							// Size of logging information
 	long			StartSeed;						// Random Number seed
 	LogStructure*	First;							// Pointer to first frame
 	LogStructure*	Current;						// Pointer to current frame
@@ -233,13 +239,13 @@ typedef struct
 
 
 extern LogHeader LogInfo;
-extern DWORD LogLoops;
-extern DWORD FrameNumber;							// When recording=current frame, playback=last frame
-extern DWORD Debounce;
+extern ULONG LogLoops;
+extern ULONG FrameNumber;							// When recording=current frame, playback=last frame
+extern ULONG Debounce;
 
-extern void EndLogging();
-extern void LoadLogFile();
-extern void CheckLogInSync();
+extern void __stdcall EndLogging(void);
+extern void __stdcall LoadLogFile(void);
+extern void __stdcall CheckLogInSync(void);
 
 //
 // Size of blocks of memory allocated for logs
@@ -253,12 +259,13 @@ extern void CheckLogInSync();
 extern bool	AllowFail;
 extern volatile bool	SpewSilence;						// Set to disable all spews
 extern HANDLE hSpewOutput;
-void __stdcall ExitGameOS();
-void InitializeSpew();
-void TerminateSpew();
-void DebugColor( BYTE red, BYTE green, BYTE blue );
-void InitProcessorSpeed();
-void DestroyExceptions();
+
+void __stdcall ExitGameOS(void);
+void __stdcall InitializeSpew(void);
+void __stdcall TerminateSpew(void);
+void __stdcall DebugColor( UCHAR red, UCHAR green, UCHAR blue );
+void __stdcall InitProcessorSpeed(void);
+void __stdcall DestroyExceptions(void);
 
 
 	


  ================================================
diff --git a/source/gameos/include/eventid.hpp b/source/gameos/include/eventid.hpp
index 734fe8e..f8714be 100755
--- a/source/gameos/include/eventid.hpp
+++ b/source/gameos/include/eventid.hpp
@@ -18,7 +18,7 @@ class GosEventIdMgr
 
 
 	static EventInfo			*pEventInfo;
-	static unsigned long		NextEntry;
+	static ULONG				NextEntry;
 	static int					ListSize;
 	static int					ListSpace;
 


  ================================================
diff --git a/source/gameos/include/fileio.hpp b/source/gameos/include/fileio.hpp
index a964d99..1258ecc 100755
--- a/source/gameos/include/fileio.hpp
+++ b/source/gameos/include/fileio.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //==========================================================================//
 // File:	 FileIO.hpp														//
 // Contents: file i/o routines												//
@@ -6,22 +5,21 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
 
-
-
-void Init_FileSystem();
-void Destory_FileSystem( bool NoErrors );
+void __stdcall Init_FileSystem(void);
+void __stdcall Destory_FileSystem( bool NoErrors );
 
 
 
 
-#ifdef LAB_ONLY
+#if defined(LAB_ONLY)
 
 //
 // Debugging information
 //
 extern char FileInfo[32][MAX_PATH+32];
-extern DWORD CurrentFileInfo;
+extern ULONG CurrentFileInfo;
 #endif
 
 
@@ -32,42 +30,37 @@ extern DWORD CurrentFileInfo;
 typedef struct _MemoryMappedFiles
 {
 
-	DWORD Magic;						// Identify this structure
+	ULONG Magic;						// Identify this structure
 	_MemoryMappedFiles*	pNext;			// Pointer to next structure
 	HANDLE hFile;						// File handle
 	HANDLE hFileMapping;				// Mapping handle
-	BYTE*  pFile;						// Pointer to start of data
-	DWORD  Size;						// Size of data
-	DWORD  RefCount;					// Reference count (number of times a file is opened)
+	PUCHAR  pFile;						// Pointer to start of data
+	ULONG  Size;						// Size of data
+	ULONG  RefCount;					// Reference count (number of times a file is opened)
 	char   Name[MAX_PATH];				// Copy of the file name
 
 } MemoryMappedFiles;
 
-
-
-struct gosFileStream
+typedef struct gosFileStream
 {
 	gosEnum_FileWriteStatus m_writeEnabled;
 	HANDLE m_hFile;
 	char m_Filename[MAX_PATH];
-	gosFileStream* pNext;
+	struct gosFileStream* pNext;
 
 	gosFileStream( const char *FileName, gosEnum_FileWriteStatus fwstatus );
+	~gosFileStream(void);
 
-	~gosFileStream();
-
-	DWORD Seek( int where, gosEnum_FileSeekType from_end );
-
-	DWORD Read( void *buffer, DWORD length );
-
-	DWORD Write( const void *buffer, DWORD length );
+	ULONG Seek( int where, gosEnum_FileSeekType from_end );
+	ULONG Read( void *buffer, ULONG length );
+	ULONG Write( const void *buffer, ULONG length );
 
-	DWORD BytesTransfered;
-};
+	ULONG BytesTransfered;
+} gosFileStream;
 
 
 
 extern MemoryMappedFiles*	ListofMemoryMappedFiles;
 extern gosFileStream* ListOfFiles;
-extern DWORD NumberMemoryMappedFilesOpen;
-extern DWORD NumberFilesOpen;
+extern ULONG NumberMemoryMappedFilesOpen;
+extern ULONG NumberFilesOpen;


  ================================================
diff --git a/source/gameos/include/filestream.hpp b/source/gameos/include/filestream.hpp
index 0747ad5..f3053db 100755
--- a/source/gameos/include/filestream.hpp
+++ b/source/gameos/include/filestream.hpp
@@ -13,9 +13,9 @@
 #endif // _MSC_VER >= 1000
 
 /*
-#pragma warning(push,3)
+//#pragma warning(push,3)
 #include <fstream.h>
-#pragma warning(pop)
+//#pragma warning(pop)
 
 //#ifdef _ARMOR
 //#if 0


  ================================================
diff --git a/source/gameos/include/font3d.hpp b/source/gameos/include/font3d.hpp
index 1ee3f4d..2be4ca3 100755
--- a/source/gameos/include/font3d.hpp
+++ b/source/gameos/include/font3d.hpp
@@ -9,19 +9,19 @@
 //
 // Support for .d3f fonts files
 //
-#pragma warning( push )
-#pragma warning( disable : 4200 ) 
+//#pragma warning( push )
+//#pragma warning( disable : 4200 ) 
 //
 // Original FontEdit program
 //
 typedef struct {
-	DWORD dwSig;				// 0x46443344
-	DWORD dwWidth;
-	DWORD dwFontHeight;
-	DWORD dwHeight;
-	DWORD dwX[256];
-	DWORD dwY[256];
-	DWORD dwWidths[256];
+	ULONG dwSig;				// 0x46443344
+	ULONG dwWidth;
+	ULONG dwFontHeight;
+	ULONG dwHeight;
+	ULONG dwX[256];
+	ULONG dwY[256];
+	ULONG dwWidths[256];
 	int nA[256];
 	int nC[256];
 	BYTE bPixels[0];
@@ -34,13 +34,13 @@ typedef struct {
 //
 typedef struct 
 {
-	DWORD dwSig;				// 0x46443344
+	ULONG dwSig;				// 0x46443344
 	char szFaceName[64];
 	int iSize;					// point size of font used to create this font
 	bool bItalic;				// italic on or off when this font was created
 	int iWeight;				// weight of font created
 	int iTextureCount; 
-	DWORD dwFontHeight;			// height in pixels of the resulatant font
+	ULONG dwFontHeight;			// height in pixels of the resulatant font
 	BYTE bTexture[256];			// indicate which texture each character is on
 	BYTE bX[256];				// indicates x position of each character on it's texture
 	BYTE bY[256];				// indicates y position of each character on it's texture
@@ -51,32 +51,32 @@ typedef struct
 
 typedef struct
 {
-	DWORD dwSize;
+	ULONG dwSize;
 	BYTE bPixels[0];
 } D3DFontTexture;
 
 #pragma pack( pop )
-#pragma warning( pop )
+//#pragma warning( pop )
 
 
 
 
 typedef struct _FontInfo
 {
-	DWORD		MagicNumber;			// Valid font check
+	ULONG		MagicNumber;			// Valid font check
 	_FontInfo*	pNext;					// Pointer to next font
-	DWORD		ReferenceCount;			// Reference count
+	ULONG		ReferenceCount;			// Reference count
 	char		FontFile[MAX_PATH];		// Path name of font texture
-	DWORD		StartLine;				// texture line where font starts
+	ULONG		StartLine;				// texture line where font starts
 	int			CharCount;				// number of chars in font (valid range 33 to 256)
-	DWORD		TextureSize;			// Width and Height of texture
+	ULONG		TextureSize;			// Width and Height of texture
 	float		rhSize;					// 1.0 / Size
-	DWORD		TexturePitch;			// Pitch of texture
+	ULONG		TexturePitch;			// Pitch of texture
 	int			Width;					// Width of font grid
 	int			Height;					// Height of font grid
-	DWORD		Across;					// Number of characters across one line
-	DWORD		Aliased;				// True if 4444 texture (may be aliased - else 1555 keyed)
-	DWORD		FromTextureHandle;		// True is from a texture handle
+	ULONG		Across;					// Number of characters across one line
+	ULONG		Aliased;				// True if 4444 texture (may be aliased - else 1555 keyed)
+	ULONG		FromTextureHandle;		// True is from a texture handle
 	BYTE		BlankPixels[256-32];	// Empty pixels before character
 	BYTE		UsedPixels[256-32];		// Width of character
 	BYTE		TopU[256-32];
@@ -84,13 +84,13 @@ typedef struct _FontInfo
 	BYTE		TopOffset[256-32];		// Offset from top (number of blank lines)
 	BYTE		RealHeight[256-32];		// Height of character
 	BYTE		TextureHandle[256-32];	// Which texture handle to use
-	DWORD		NumberOfTextures;		// Number of texture handles used (normally 1)
+	ULONG		NumberOfTextures;		// Number of texture handles used (normally 1)
 	HFONT		hFontTTF;				// handle to a GDI font
-	DWORD		Texture[8];				// Texture handle array
+	ULONG		Texture[8];				// Texture handle array
 } FontInfo;
 
-void Init3DFont();
-void Destroy3DFont();
+void __stdcall Init3DFont();
+void __stdcall Destroy3DFont();
 
 
 


  ================================================
diff --git a/source/gameos/include/font3d_dbcs_surface.hpp b/source/gameos/include/font3d_dbcs_surface.hpp
index db9f760..8f0157b 100755
--- a/source/gameos/include/font3d_dbcs_surface.hpp
+++ b/source/gameos/include/font3d_dbcs_surface.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 Surface.hpp													 //
 // Contents: DirectDraw Surface object										 //
@@ -6,6 +5,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
+
 class DBCSSurface
 {
 	public:
@@ -13,12 +14,12 @@ class DBCSSurface
 		int m_height;
 		int m_width;
 		int m_offsety;
-		IDirectDrawSurface7 * m_lpdds7;
-		unsigned char * m_lpDynData;
+		LPDIRECTDRAWSURFACE7 m_lpdds7;
+		PUCHAR m_lpDynData;
 
-		DBCSSurface(DWORD width, DWORD height);
+		DBCSSurface(ULONG width, ULONG height);
 		~DBCSSurface();
-		void* GetDataPointer();
-		void Clear(DWORD color);
+		PVOID GetDataPointer(void);
+		void Clear(ULONG color);
 };
 


  ================================================
diff --git a/source/gameos/include/gameos.hpp b/source/gameos/include/gameos.hpp
index 01c77de..fad2d1e 100755
--- a/source/gameos/include/gameos.hpp
+++ b/source/gameos/include/gameos.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 GameOS.hpp														 //
 //																			 //
@@ -10,17 +9,24 @@
 //
 // Pragmas needed to compile at Warning 4
 //
-#pragma pack(push,4)
-#pragma warning( disable: 4725 )					// fdiv generates a warning
-#pragma warning( disable: 4127 )					// conditional expression is constant eg: Asserts will not work otherwise
-#pragma warning( disable: 4200 )					// zero size array
-#pragma warning( disable: 4201 )					// Nameless struct or union
-#pragma warning( disable: 4514 )					// Unreferenced inline function
+//#pragma pack(push,4)
+//#pragma warning( disable: 4725 )					// fdiv generates a warning
+//#pragma warning( disable: 4127 )					// conditional expression is constant eg: Asserts will not work otherwise
+//#pragma warning( disable: 4200 )					// zero size array
+//#pragma warning( disable: 4201 )					// Nameless struct or union
+//#pragma warning( disable: 4514 )					// Unreferenced inline function
+
+#pragma once
 
 #ifdef _ICECAP
 #include "icecap.h"
 #endif
 
+#ifndef MECH_IMPEXP
+#define MECH_IMPEXP extern
+#endif
+#define MECH_CALL __stdcall
+
 //
 //
 //
@@ -35,7 +41,7 @@
 //
 // Enter the visual C debugger
 //
-#define ENTER_DEBUGGER _asm int 3
+#define ENTER_DEBUGGER __debugbreak();	// _asm int 3
 //
 // Check !=0 only in debug builds (can be continued)
 //
@@ -76,17 +82,7 @@
 #define SPEW(x)		((void)0)
 #endif
 
-
-
-
-
-
-
-
-
-
-
-
+#if _CONSIDERED_OBSOLETE
 //
 // Types used by GameOS
 //
@@ -105,12 +101,10 @@ typedef struct _GUID
     unsigned short Data3;
     unsigned char Data4[8];
 } GUID;
-#endif /* GUID_DEFINED */
-
+#endif
+#endif
 
-//
 // Handles to internal structures
-//
 typedef struct	SoundResource*	HGOSAUDIO;
 typedef struct	gos_Music*		HGOSMUSIC;
 typedef struct	gos_Video*		HGOSVIDEO;
@@ -125,19 +119,20 @@ typedef struct	gos_Heap*		HGOSHEAP;
 //////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////
 
-typedef struct
-{
+typedef struct gosEnvironment {
 //
 // Application title and version number
 //
-	char*	applicationName;		// "TestApp" or "Pong"
-	char*	version;				// Default is "00.00.00.0000"
-	char*	registryVersion;		// If present, will be used to create a sub folder in the registry (ie: v1.1, v1.2)
-	char*	directoryPath;			// If program path end in this directory, move up levels (ie: "\\Code\\AssassinEditor" or "\\Tools\\PixelWhIP"). "!" will force GameOS NOT to change directory at all (Including DEBUG/RELEASE/PROFILE....)
-	char*	defaultPlayerName;		// used in lobby launch
-	bool	allowMultipleApps;		// Allows the game to be run more than once on a single system (network testing)
-	DWORD	MegMemoryRequired;		// Megabytes of virtual memory required to run game (default is 64Meg)
-	bool	dontClearRegistry;		// When true, the registry is not cleared when the .exe is changed
+	PSTR	applicationName;		// "TestApp" or "Pong"
+	PSTR	version;				// Default is "00.00.00.0000"
+	PSTR	registryVersion;		// If present, will be used to create a sub folder in the registry (ie: v1.1, v1.2)
+	PSTR	directoryPath;			// If program path end in this directory, move up levels (ie: "\\Code\\AssassinEditor" or "\\Tools\\PixelWhIP"). "!" will force GameOS NOT to change directory at all (Including DEBUG/RELEASE/PROFILE....)
+	PSTR	defaultPlayerName;		// used in lobby launch
+	UCHAR	allowMultipleApps;		// Allows the game to be run more than once on a single system (network testing)
+	UCHAR	_unused0[3];
+	ULONG	MegMemoryRequired;		// Megabytes of virtual memory required to run game (default is 64Meg)
+	UCHAR	dontClearRegistry;		// When true, the registry is not cleared when the .exe is changed
+	UCHAR	_unused1[3];
 //
 // Current screen mode (application can check, but may change from frame to frame)
 //
@@ -146,30 +141,32 @@ typedef struct
 	int		bitDepth;				// 16 or 32
 	int		FullScreenDevice;		// 0=Primary, 1=2nd video card (ie: 3Dfx) etc...
 	int		Renderer;				// 0=Try hardware, fallback to software, 1=RGB, 2=Refrast, 3=Blade
-	bool	fullScreen;				// Application start running full screen or in a window?
-	bool	disableZBuffer;			// When true no Z buffer surface will be created
-	bool	AntiAlias;				// When true full screen antialiasing will be enabled if possible
-	bool	RenderToVram;			// When true Blade applications will render directly to video memory (speed-up if no alpha is used)
-	bool	Stencil;				// When true an 8 bit stencil buffer will be enabled if possible
-	bool	TripleBuffer;			// When true, full screen modes will be triple buffered, else double buffered
-	bool	MaxRefreshRate;			// When true, full screen modes will use the maximum card refresh rate, else 60hz.
+	UCHAR	fullScreen;				// Application start running full screen or in a window?
+	UCHAR	disableZBuffer;			// When true no Z buffer surface will be created
+	UCHAR	AntiAlias;				// When true full screen antialiasing will be enabled if possible
+	UCHAR	RenderToVram;			// When true Blade applications will render directly to video memory (speed-up if no alpha is used)
+	UCHAR	Stencil;				// When true an 8 bit stencil buffer will be enabled if possible
+	UCHAR	TripleBuffer;			// When true, full screen modes will be triple buffered, else double buffered
+	UCHAR	MaxRefreshRate;			// When true, full screen modes will use the maximum card refresh rate, else 60hz.
+	UCHAR	_unused2;
 	int		DirtyRectangle;			// Bit 0=Enabled, Bit 1=Save Z buffer rectangles too, Bit 2=Save directly in system memory (don't try video memory).
 	int		DisableLowEndCard;		// When set to 1 and video cards in VideoCard.cpp with the LowEndCard flag set will have hardware acceleration disabled
-	DWORD	MinimumTextureMemory;	// If this value is !=0 it specifies the minimum TEXTURE memory required otherwise hardware acceleration is disabled
+	ULONG	MinimumTextureMemory;	// If this value is !=0 it specifies the minimum TEXTURE memory required otherwise hardware acceleration is disabled
 //
 // Keys used by GameOS (Use 0 to disable them, or see keycodes later in this header)
 //
-	DWORD	Key_FullScreen;			// Default is KEY_F4	(Enter/exit full screen mode)
-	DWORD	Key_SwitchMonitors;		// Default is KEY_F5	(Change video cards - nvidia/voodoo etc...)
-	DWORD	Key_Exit;				// Default is KEY_ESC	(Exit full screen mode or exit game)
+	ULONG	Key_FullScreen;			// Default is KEY_F4	(Enter/exit full screen mode)
+	ULONG	Key_SwitchMonitors;		// Default is KEY_F5	(Change video cards - nvidia/voodoo etc...)
+	ULONG	Key_Exit;				// Default is KEY_ESC	(Exit full screen mode or exit game)
 //
 // Debugging settings
 //
-	char*	debugLog;				// File to dump info to, or "debugger" to the debug console
-	char*	spew;					// List of groups to dump to debuglog - eg: GameOS_Texture, GameOS_DirectDraw
-	bool	TimeStampSpew;			// adds the current time stamp to all spews
-	DWORD	MemoryManager;			// 0=custom memory manager, 1=windows memory manager, 2=
-	DWORD	memoryTraceLevel;		// How many levels of stack to walk when tracing memory allocations
+	PSTR	debugLog;				// File to dump info to, or "debugger" to the debug console
+	PSTR	spew;					// List of groups to dump to debuglog - eg: GameOS_Texture, GameOS_DirectDraw
+	UCHAR	TimeStampSpew;			// adds the current time stamp to all spews
+	UCHAR	_unused3[3];
+	ULONG	MemoryManager;			// 0=custom memory manager, 1=windows memory manager, 2=
+	ULONG	memoryTraceLevel;		// How many levels of stack to walk when tracing memory allocations
 //
 // Game related functions
 //
@@ -178,71 +175,75 @@ typedef struct
 //
 // Sound-related application information
 //
-	bool	soundDisable;			// false = disable all sound, true = enable all sound
-	bool	soundHiFi;				// true = 44Khz sound, false = 22KHz
+	UCHAR	soundDisable;			// false = disable all sound, true = enable all sound
+	UCHAR	soundHiFi;				// true = 44Khz sound, false = 22KHz
+	UCHAR	_unused4[2];
 	int		soundDevice;			// 0 = primary/default, # = device enum
 	int		soundChannels;			// Default number of sound channels, for example 8
 	int		soundForceCache;		// 0 = never force a stream resource into cached resource else # bytes under which to force resource to cached if streamed
-	bool	soundMixInHardware;		// 0=no mixing sound in hardware (default), 1=mix sound in hardware, if available.
+	UCHAR	soundMixInHardware;		// 0=no mixing sound in hardware (default), 1=mix sound in hardware, if available.
 //
 // Network settings
 //
-	bool	NetworkGame;			// Is this game going to be network aware?
-	bool	DirectPlayProtocol;		// If this instance is the server, should we use the DirectPlay protocol?
+	UCHAR	NetworkGame;			// Is this game going to be network aware?
+	UCHAR	DirectPlayProtocol;		// If this instance is the server, should we use the DirectPlay protocol?
+	UCHAR	_unused5;
 	union {
-	BYTE	NetworkGUID[16];		// This is the DirectPlay GUID that must be unique for the game
+	UCHAR	NetworkGUID[16];		// This is the DirectPlay GUID that must be unique for the game
 	GUID	GameGUID;				// Note that this union allows access as GUID but byte order will changing depending on initialization
 	};								// All initialization of this code should use GameGUID from now on
-	DWORD	NetworkMaxPlayers;		// The maximum number of players allowed in this game.
-	BYTE	NetGameInfo[16];		// Information about the current network game (this can be enumerated from other network games before you join them)
-	char* (__stdcall *DecodeGameInfo)(void*Data);	// GameOS will call this routine if present to decode the 16 bytes of network game information.
-	char*	ZoneMatchServerIP;      // Typical value is ZoneMatch.zone.com
+	ULONG	NetworkMaxPlayers;		// The maximum number of players allowed in this game.
+	UCHAR	NetGameInfo[16];		// Information about the current network game (this can be enumerated from other network games before you join them)
+	PSTR (__stdcall *DecodeGameInfo)(PVOID Data);	// GameOS will call this routine if present to decode the 16 bytes of network game information.
+	PSTR	ZoneMatchServerIP;      // Typical value is ZoneMatch.zone.com
     int     ZoneAdvertisePort;      // Port games will be advertised on.  This is the port ZoneMatch connects to to receive updates to a game's state.  Don't
                                     // confuse this with the game's port, which would be the port that actual clients who want to play the game would connect
                                     // to.  Typical value is APP_QUERY_PORT (27999)
 
-	bool	NetServerMigration;		// When true, the server player can quit and the game will continue (another machine will become the server)
+	UCHAR	NetServerMigration;		// When true, the server player can quit and the game will continue (another machine will become the server)
 //
 // Controller settings
 //
-	bool ButtonsAsKeys;				// when true, gos_GetKey will return events for controller button presses
-	bool allowDoubleClicks;			// make double-click messages available to the application (default is false)
+	UCHAR	ButtonsAsKeys;				// when true, gos_GetKey will return events for controller button presses
+	UCHAR	allowDoubleClicks;			// make double-click messages available to the application (default is false)
+	UCHAR	_unused6;
 //
 // Raid Database settings
 //
-	char* RaidFilePath;				//	The path where the exception files for your project should be stored. They will be referred to by hyperlink in the bug description.
-	char* RaidCustomFields;			//  A string containing key-value pairs of Raid Database column name and the value for that record. the column must be of type var-char with a width of 32 (standard raid list)
-	char* RaidDataSource;			//  The raid data source name (can be retrieved from your odbc control panel or the registry once an rdq has been opened on your machine.
-	char* RaidDescTemplate;			//	A string sets the default text that appears in the description of the bug eg. Description: \n REPRO STEPS: \n etc.
+	PSTR RaidFilePath;				//	The path where the exception files for your project should be stored. They will be referred to by hyperlink in the bug description.
+	PSTR RaidCustomFields;			//  A string containing key-value pairs of Raid Database column name and the value for that record. the column must be of type var-char with a width of 32 (standard raid list)
+	PSTR RaidDataSource;			//  The raid data source name (can be retrieved from your odbc control panel or the registry once an rdq has been opened on your machine.
+	PSTR RaidDescTemplate;			//	A string sets the default text that appears in the description of the bug eg. Description: \n REPRO STEPS: \n etc.
 //
 //
 //
 //
 // These are legacy and will be deleted
 //
-	DWORD	NetworkMinPlayers;		// The minimum number of player required to start a game
-	DWORD	AllowJoinInProgress;	// When true 'join in progress' is enabled for this network game
-	DWORD	Texture_S_256;			// Number of 256*256 Solid texture heap pages
-	DWORD	Texture_S_128;			// Number of 128*128 Solid texture heap pages
-	DWORD	Texture_S_64;			// Number of   64*64 Solid texture heap pages
-	DWORD	Texture_S_32;			// Number of   32*32 Solid texture heap pages
-	DWORD	Texture_S_16;			// Number of   16*16 Solid texture heap pages
-	DWORD	Texture_K_256;			// Number of 256*256 Keyed texture heap pages
-	DWORD	Texture_K_128;			// Number of 128*128 Keyed texture heap pages
-	DWORD	Texture_K_64;			// Number of   64*64 Keyed texture heap pages
-	DWORD	Texture_K_32;			// Number of   32*32 Keyed texture heap pages
-	DWORD	Texture_K_16;			// Number of   16*16 Keyed texture heap pages
-	DWORD	Texture_A_256;			// Number of 256*256 Alpha texture heap pages
-	DWORD	Texture_A_128;			// Number of 128*128 Alpha texture heap pages
-	DWORD	Texture_A_64;			// Number of   64*64 Alpha texture heap pages
-	DWORD	Texture_A_32;			// Number of   32*32 Alpha texture heap pages
-	DWORD	Texture_A_16;			// Number of   16*16 Alpha texture heap pages
+	ULONG	NetworkMinPlayers;		// The minimum number of player required to start a game
+	ULONG	AllowJoinInProgress;	// When true 'join in progress' is enabled for this network game
+	ULONG	Texture_S_256;			// Number of 256*256 Solid texture heap pages
+	ULONG	Texture_S_128;			// Number of 128*128 Solid texture heap pages
+	ULONG	Texture_S_64;			// Number of   64*64 Solid texture heap pages
+	ULONG	Texture_S_32;			// Number of   32*32 Solid texture heap pages
+	ULONG	Texture_S_16;			// Number of   16*16 Solid texture heap pages
+	ULONG	Texture_K_256;			// Number of 256*256 Keyed texture heap pages
+	ULONG	Texture_K_128;			// Number of 128*128 Keyed texture heap pages
+	ULONG	Texture_K_64;			// Number of   64*64 Keyed texture heap pages
+	ULONG	Texture_K_32;			// Number of   32*32 Keyed texture heap pages
+	ULONG	Texture_K_16;			// Number of   16*16 Keyed texture heap pages
+	ULONG	Texture_A_256;			// Number of 256*256 Alpha texture heap pages
+	ULONG	Texture_A_128;			// Number of 128*128 Alpha texture heap pages
+	ULONG	Texture_A_64;			// Number of   64*64 Alpha texture heap pages
+	ULONG	Texture_A_32;			// Number of   32*32 Alpha texture heap pages
+	ULONG	Texture_A_16;			// Number of   16*16 Alpha texture heap pages
 
 //
 // This flag suppresses the "No 3D Acceleration" message when not full screen.
 // MC2 needs this so that the initial MessageBox can display a warning about sniffing you machine.
 // At any time during the release builds, the game will be full screen.
-	bool	Suppress3DFullScreenWarning;
+	UCHAR	Suppress3DFullScreenWarning;
+	UCHAR	_unused7[3];
 
 // Now functions GameOS can call in the application
 
@@ -253,29 +254,29 @@ typedef struct
 //  This is called during error routines, so NO errors must be able to occur in this routine.
 //  Do not assume DirectX or your memory heap etc.. are valid.
 //
-	char* (__stdcall *GetGameInformation)();		
+	PSTR (__stdcall *GetGameInformation)(void);		
 //
 // Called ONCE only, after GameOS has been setup, just before main loop starts
 //  All memory should be allocated and all structures should be cleared
 //
-	void (__stdcall *InitializeGameEngine)();
+	void (__stdcall *InitializeGameEngine)(void);
 //
 // Called each main loop, game should move 'one tick' if DoTimedGameLogic is not set
 //  Do not update the display, just do the game logic.
 //
-	void (__stdcall *DoGameLogic)();
+	void (__stdcall *DoGameLogic)(void);
 //
 // Called each main loop, game should update it's sound and video renderers.
 //  This is the only time draw or sound functions within the game are valid.
 //  These are not allowed during DoGameLogic so renders may be skipped during
 //  heavy loads or during 'fast playback' of a logfile.
 //
-	void (__stdcall *UpdateRenderers)();
+	void (__stdcall *UpdateRenderers)(void);
 //
 // GameOS will call this once it comes out of the main loop, before it shuts down
 //  No display updating should be attempted. This should be used to free all memory.
 //
-	void (__stdcall *TerminateGameEngine)();
+	void (__stdcall *TerminateGameEngine)(void);
 //
 //
 //
@@ -289,11 +290,11 @@ typedef struct
 // function there, GameOS will jump to that function. GameOS will check for gos_GetFIle being called
 // again during this function and allow it to read from the disk normally.
 //
-	void (__stdcall *HookGetFile)( const char* FileName, BYTE** MemoryImage, DWORD* Size );
+	void (__stdcall *HookGetFile)( PCSTR FileName, PUCHAR* MemoryImage, PULONG Size );
 
 // Other file API calls available to hook
 
-	bool (__stdcall *HookDoesFileExist)( const char* FileName);
+	UCHAR (__stdcall *HookDoesFileExist)( PCSTR FileName);
 
 } gosEnvironment;
 
@@ -307,19 +308,19 @@ typedef struct
 //
 // The command line that was used to start the game is passed
 //
-void __stdcall GetGameOSEnvironment( char* CommandLine );
+void __stdcall GetGameOSEnvironment( PSTR CommandLine );
 //
 // Called by the Game to cause GameOS to quit and exit (at the end of the current frame - not immediatly)
 //
-void __stdcall gos_TerminateApplication();
+void __stdcall gos_TerminateApplication(void);
 //
 // In the Environment.TerminateGameEngine routine this function will tell you if you can prompt the user or if you must just terminate (for exmaple on log file playback)
 //
-bool __stdcall gos_UserExit();
+UCHAR __stdcall gos_UserExit(void);
 //
 // While the application is inside the Environment.TerminateGameEngine routine it may execute this to make GameOS continue.
 //
-void __stdcall gos_AbortTermination();
+void __stdcall gos_AbortTermination(void);
 
 
 //
@@ -329,7 +330,7 @@ void __stdcall gos_AbortTermination();
 // It is passed the function to call in place of the original gamelogic. If this is passed 0, no game logic is called. If the original gamelogic loop should be used, pass Environment.DoGameLogic
 // Returns true if the game was terminated
 //
-bool __stdcall gos_RunMainLoop( void(__stdcall *DoGameLogic)()=0 );
+UCHAR __stdcall gos_RunMainLoop( void(__stdcall *DoGameLogic)()=0 );
 
 
 
@@ -349,26 +350,24 @@ bool __stdcall gos_RunMainLoop( void(__stdcall *DoGameLogic)()=0 );
 
 //////////////////////////////////////////////////////////////////////////////////
 // An enumeration of the various commands to the Video playback API.
-enum gosVideo_Command
-{
+typedef enum gosVideo_Command {
 	gosVideo_SeekTime = 1, 			// Seek to a frame or timestamp in hVideo
 	gosVideo_SetCoords	= 2,		// Set the destination coordinates of <hVideo> via <dwOriginX/Y>
 	gosVideo_SetScale = 4,			// Change the scale of <hVideo> on the fly via <fScaleOfX/Y>
 	gosVideo_Volume = 8,			// Set the volume of the multiVideo
 	gosVideo_Panning = 16			// Set the pan of the multiVideo
-};
+}gosVideo_Command;
 
 //////////////////////////////////////////////////////////////////////////////////
 // An enumeration of the various states the video playback can be in.
-enum gosVideo_PlayMode
-{
+typedef enum gosVideo_PlayMode {
 	gosVideo_PlayOnceHide,		// The Video is currently playing (will hide when done)
 	gosVideo_PlayOnceHold,		// The Video is currently playing (will hold when done)
 	gosVideo_Loop,				// The Video is currently in continuous play mode
 	gosVideo_Stop,				// The Video is stopped
 	gosVideo_Pause,				// The Video has been paused
 	gosVideo_Continue			// SET ONLY: continue a paused Video
-};
+}gosVideo_PlayMode;
 
 //////////////////////////////////////////////////////////////////////////////////
 // This structure is used to send and receive information about a particular video
@@ -377,34 +376,34 @@ enum gosVideo_PlayMode
 // consult the comments listed under the appropriate command (listed above).
 typedef struct _gosVideo_Info
 {
-	char *					lpstrPath;		// string specified path to data
+	PSTR					lpstrPath;		// string specified path to data
 	gosVideo_PlayMode		ePlayMode;		// the play mode (see above)
 	gosVideo_PlayMode		ePlayStatus;	// the play mode (see above)
-	DWORD					dwOriginX;		// x coord on dest. surf for video
-	DWORD					dwOriginY;		// y coord on dest. surf for video
+	ULONG					dwOriginX;		// x coord on dest. surf for video
+	ULONG					dwOriginY;		// y coord on dest. surf for video
 	float					fScaleOfX;		// ratio of displayed to orgininal width
 	float					fScaleOfY;		// ratio of displayed to orgininal height
 	float					fDurationSec;	// read-only duration of video (hundredth of a second)
 	float					fSoFarSec;		// current play position (hundredth of a second)
-	unsigned char *			lpData;			// RGB data
-	DWORD					dwSurfaceWidth;	// read-only width of video surface
-	DWORD					dwSurfaceHeight;// read-only height of vidoe surface
-	DWORD					dwPitch;		// read-only pitch of video surface
-	DWORD					dwWidth;		// read-only width of video
-	DWORD					dwHeight;		// read-only height of vidoe
+	PUCHAR					lpData;			// RGB data
+	ULONG					dwSurfaceWidth;	// read-only width of video surface
+	ULONG					dwSurfaceHeight;// read-only height of vidoe surface
+	ULONG					dwPitch;		// read-only pitch of video surface
+	ULONG					dwWidth;		// read-only width of video
+	ULONG					dwHeight;		// read-only height of vidoe
 } gosVideo_ResourceInfo;
 
 //////////////////////////////////////////////////////////////////////////////////
 // Send a command to an existing video resource or create a new video resource.
 // Consult the structures/enums listed above for more information.
 //
-void __stdcall gosVideo_CreateResource( HGOSVIDEO* Handle, char* filename );
-void __stdcall gosVideo_CreateResourceAsTexture( HGOSVIDEO* Handle, DWORD* hTex, char* filename );
+void __stdcall gosVideo_CreateResource( HGOSVIDEO* Handle, PSTR filename );
+void __stdcall gosVideo_CreateResourceAsTexture( HGOSVIDEO* Handle, PULONG hTex, PSTR filename );
 void __stdcall gosVideo_DestroyResource( HGOSVIDEO* Handle );
 void __stdcall gosVideo_GetResourceInfo( HGOSVIDEO Handle, gosVideo_ResourceInfo* gvi );
 
-void __stdcall gosVideo_SetPlayMode( HGOSVIDEO Handle, enum gosVideo_PlayMode gvpm );
-void __stdcall gosVideo_Command( HGOSVIDEO Handle, enum gosVideo_Command vc, float x, float y = 0.0f );
+void __stdcall gosVideo_SetPlayMode( HGOSVIDEO Handle, gosVideo_PlayMode gvpm );
+void __stdcall gosVideo_Command( HGOSVIDEO Handle, gosVideo_Command vc, float x, float y = 0.0f );
 
 
 
@@ -441,8 +440,7 @@ void __stdcall gosVideo_Command( HGOSVIDEO Handle, enum gosVideo_Command vc, flo
 // function-- only allocate the sliders you intend to use on each channel-- this improves
 // both hardware and software performance.
 //
-enum gosAudio_Properties
-{
+typedef enum gosAudio_Properties {
 	gosAudio_Common = 1,				//
 	gosAudio_Volume = 2,				// Volume can be adjusted independently of mixer (0.0 = silence, 1.0 = full volume)
 	gosAudio_Panning = 4,				// Panning can be adjusted independently of mixer (-1.0 = left, 0 = center, +1 = right)
@@ -461,14 +459,13 @@ enum gosAudio_Properties
 	gosAudio_Decay = 16384,				// .1f to 20.0f (in seconds)
 	gosAudio_ConeAngles = 32768,		// expressed as degrees. 1st parameters is inner (full volume), second is outer (fully attenuated)
 	gosAudio_ConeOrientation = 65536	// direction in which the cone points.
-};
+} gosAudio_Properties;
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////////
 // This enum is used to set or return the client's speaker configuration. Note that gosAudio_DegreeArc<x> may be bitwise OR'd into
 // the speaker type if the speaker type is gosAudio_Stereo.
 //
-enum gosAudio_SpeakerConfig				
-{
+typedef enum gosAudio_SpeakerConfig {
 	gosAudio_Headphones = 1,			// The client system uses a pair of headphones for aural feedback
 	gosAudio_Monaural = 2,				// The client system has only one speaker attached
 	gosAudio_Quadraphonic = 4,			// The system is using a four-speaker system
@@ -478,24 +475,22 @@ enum gosAudio_SpeakerConfig
 	gosAudio_DegreeArc10 = 64,
 	gosAudio_DegreeArc20 = 128,
 	gosAudio_DegreeArc180 = 256
-};
+} gosAudio_SpeakerConfig;
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////////
 // Sound Channels can be in one of the following states
 //
-enum gosAudio_PlayMode
-{
+typedef enum gosAudio_PlayMode {
 	gosAudio_PlayOnce,				// Play the channel's resource once and then end
 	gosAudio_Loop,					// Continually play the channel's resource, looping after each iteration
 	gosAudio_Pause,					// Pause the sound, a Continue will resume the sound from where it was paused
 	gosAudio_Continue,				// SET ONLY: continue a sound that was paused.
 	gosAudio_Stop,					// Silence the channel and stop processing the resource
-};
+}gosAudio_PlayMode;
 ////////////////////////////////////////////////////////////////////////////////////////////////////////
 // Resource Types
 //
-typedef enum gosAudio_ResourceType
-{
+typedef enum gosAudio_ResourceType {
 	gosAudio_CachedFile,			// Pull a WAV file from disk, parse it, and copy the raw sound data into system memory
 	gosAudio_UserMemory,			// Use a preloaded WAV already in the client's system memory. Note: This memory must remain intact until this resource is destroyed
 	gosAudio_UserMemoryDecode,		// Use a preloaded WAV already in the client's system memory. Note: Unlike UserMemory, UserMemoryDecode deciphers the waveformat itself.
@@ -503,20 +498,20 @@ typedef enum gosAudio_ResourceType
 	gosAudio_StreamedFile,			// Leave the sound data on disk, streaming only the data when needed. Note: only volume and pan affect streamed files
 	gosAudio_StreamedMusic,			// Leave the sound data on disk, play a non-PCM/ADPCM song.
 	gosAudio_StreamedFP				// Streamed from a file pointer
-};
+} gosAudio_ResourceType;
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////////
 // The format structure, for describing the format of sound resources
 //
 typedef struct _gosAudio_Format
 {
-	WORD  wFormatTag;				// Waveform-audio format type. 1=PCM, 2=Microsoft ADPCM.
-	WORD  nChannels; 				// 1=Mono, 2=Stereo.
-    DWORD nSamplesPerSec;			// Sample rate, 11025Hz, 22050Hz or 44100Hz.
-	DWORD nAvgBytesPerSec;          // Normally, nBlockAlign * nSamplesPerSec
-	WORD  nBlockAlign; 				// Normally, wBitsPerSample / 8 * nChannels
-    WORD  wBitsPerSample;			// Bits per sample for the wFormatTag format type. If wFormatTag is 1 (PCM), then wBitsPerSample should be equal to 8 or 16.
-	WORD  cbSize;					// Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure. For PCM's, this should be set to 0. For ADPCM, this should be set to 32.
+	USHORT	wFormatTag;				// Waveform-audio format type. 1=PCM, 2=Microsoft ADPCM.
+	USHORT  nChannels; 				// 1=Mono, 2=Stereo.
+    ULONG	nSamplesPerSec;			// Sample rate, 11025Hz, 22050Hz or 44100Hz.
+	ULONG	nAvgBytesPerSec;        // Normally, nBlockAlign * nSamplesPerSec
+	USHORT  nBlockAlign; 			// Normally, wBitsPerSample / 8 * nChannels
+    USHORT  wBitsPerSample;			// Bits per sample for the wFormatTag format type. If wFormatTag is 1 (PCM), then wBitsPerSample should be equal to 8 or 16.
+	SIZE_T	cbSize;					// Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure. For PCM's, this should be set to 0. For ADPCM, this should be set to 32.
 } gosAudio_Format;
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -524,11 +519,11 @@ typedef struct _gosAudio_Format
 // in the structure itself as well as the pointers within the arrays will be copied, so the structures
 // can be discarded once the resource has been created
 //
-typedef struct gosAudio_PlayList
+typedef struct _gosAudio_PlayList
 {
-	DWORD		m_dwListLength;		// Number of sample in the playlist
-	DWORD *		m_lpSoundData;		// A array of pointers pointing to the start of each memory-mapped WAV file.
-	DWORD *		m_lpDataLength;		// The size of each corresponding sample in the playlist
+	SIZE_T		m_dwListLength;		// Number of sample in the playlist
+	PUINT_PTR	m_lpSoundData;		// A array of pointers pointing to the start of each memory-mapped WAV file.
+	PSIZE_T		m_lpDataLength;		// The size of each corresponding sample in the playlist
 } gosAudio_PlayList;
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -536,10 +531,10 @@ typedef struct gosAudio_PlayList
 //
 typedef struct _gosAudio_ResourceInfo
 {
-	char *					lpstrPath;		// the path or name of the resource queried
+	PSTR					lpstrPath;		// the path or name of the resource queried
 	gosAudio_ResourceType	eType;			// see above
 	gosAudio_Format			sFormat;		// 1 = PCM, 2 = ADPCM
-	DWORD					dwSizeInBytes;	// size of the data portion of the WAV
+	ULONG					dwSizeInBytes;	// size of the data portion of the WAV
 	float					fDuration;		// in seconds
 } gosAudio_ResourceInfo;
 
@@ -550,7 +545,7 @@ typedef struct _gosAudio_ResourceInfo
 typedef struct _gosAudio_ChannelInfo
 {
 	HGOSAUDIO			hAudio;
-	DWORD				dwProperties;				// A bitwise flag field specifying which sliders have been allocated to it.
+	ULONG				dwProperties;				// A bitwise flag field specifying which sliders have been allocated to it.
 	gosAudio_PlayMode	ePlayMode;					// The current playmode of the channel
 	float				fVolume;					// The current volume (0.0 - 1.0) of the channel
 	float				fPanning;					// The current panning (-1.0 - +1.0) of the channel
@@ -565,7 +560,7 @@ typedef struct _gosAudio_ChannelInfo
 //////////////////////////////////////////////////////////////////////////////////
 //	Mixer (channel -1) related
 //
-	DWORD				dwSpeakerConfig;			// The speaker setup of the mixer
+	ULONG				dwSpeakerConfig;			// The speaker setup of the mixer
 	float				fFrontX, fFrontY, fFrontZ;	// The forward-facing vector of the user's "ears"
 	float				fTopX, fTopY, fTopZ;		// The top-pointing vector of the listener
 	float				fDoppler;					// Typically 1.0, this can be manipulated for a desired effect
@@ -578,8 +573,8 @@ typedef struct _gosAudio_ChannelInfo
 //////////////////////////////////////////////////////////////////////////////////
 // Creates a resource to be played later
 //
-void __stdcall gosAudio_CreateResource( HGOSAUDIO* hgosaudio, enum gosAudio_ResourceType,  const char* file_name, gosAudio_Format* ga_wf = 0, void* data = 0, int size = 0, bool only2D = 0);
-void __stdcall gosAudio_CreateResource( HGOSAUDIO * hgosaudio, const char * identifier_name, HGOSFILE file, DWORD offset, bool only2D = 0);
+void __stdcall gosAudio_CreateResource( HGOSAUDIO* hgosaudio, gosAudio_ResourceType,  PCSTR file_name, gosAudio_Format* ga_wf = 0, PVOID data = 0, int size = 0, UCHAR only2D = 0);
+void __stdcall gosAudio_CreateResource( HGOSAUDIO * hgosaudio, PCSTR identifier_name, HGOSFILE file, ULONG offset, UCHAR only2D = 0);
 
 //////////////////////////////////////////////////////////////////////////////////
 // Destroy a resource; any sounds currently playing using the ResourceID will be
@@ -593,7 +588,7 @@ void __stdcall gosAudio_DestroyResource( HGOSAUDIO* hgosaudio );
 // allocate only the properties that will need modification. Use a bitwise'd group
 // of gosAudio_Properties to set what is needed.
 //
-void __stdcall gosAudio_AllocateChannelSliders( int Channel, DWORD properties);
+void __stdcall gosAudio_AllocateChannelSliders( int Channel, ULONG properties);
 
 //////////////////////////////////////////////////////////////////////////////////
 // Prepare a channel to play a resource of any type.
@@ -604,18 +599,18 @@ void __stdcall gosAudio_AssignResourceToChannel( int Channel, HGOSAUDIO hgosaudi
 // Get and Set functions only operate if a channel has the property enabled
 //  Channel number -1 used in SetVolume and SetPanning will alter the windows master
 //  volume and balance
-void __stdcall gosAudio_SetChannelSlider( int Channel, enum gosAudio_Properties, float value1, float value2 = 0.0f, float value3 = 0.0f );
-void __stdcall gosAudio_GetChannelSlider( int Channel, enum gosAudio_Properties, float* value1, float* value2 = 0, float* value3 = 0 );
+void __stdcall gosAudio_SetChannelSlider( int Channel, gosAudio_Properties, float value1, float value2 = 0.0f, float value3 = 0.0f );
+void __stdcall gosAudio_GetChannelSlider( int Channel, gosAudio_Properties, float* value1, float* value2 = 0, float* value3 = 0 );
 
 //////////////////////////////////////////////////////////////////////////////////
 // Set the speaker configuration. See enum above.
 //
-void __stdcall gosAudio_SetSpeakerConfig( DWORD config );
+void __stdcall gosAudio_SetSpeakerConfig( ULONG config );
 
 //////////////////////////////////////////////////////////////////////////////////
 // Play, Loop, Stop, Pause, or Continue a particular channel
 //
-void __stdcall gosAudio_SetChannelPlayMode( int Channel, enum gosAudio_PlayMode ga_pm );
+void __stdcall gosAudio_SetChannelPlayMode( int Channel, gosAudio_PlayMode ga_pm );
 //////////////////////////////////////////////////////////////////////////////////
 // Determine the current play mode of a channel
 //
@@ -631,7 +626,7 @@ void __stdcall gosAudio_GetChannelInfo( int Channel, gosAudio_ChannelInfo* sri )
 // Reset the sound system if you wanna change the original sound device,
 // or the KHz of the mixer....
 //
-void __stdcall gosAudio_Reset();
+void __stdcall gosAudio_Reset(void);
 
 //////////////////////////////////////////////////////////////////////////////////
 // Get a list of available sound devices. Returns <available> possibilities as strings in <name>
@@ -696,46 +691,48 @@ void __stdcall gosAudio_DeviceOptions( char names[8][128], int* available );
 typedef struct _gosIME_Appearance
 {
 	// symbol (Henkan-kyu)
-	DWORD			symbolColor;
-	DWORD			symbolColorText;
-	BYTE			symbolHeight;
-	BYTE			symbolTranslucence;
-	BYTE			symbolPlacement;
+	ULONG			symbolColor;
+	ULONG			symbolColorText;
+	UCHAR			symbolHeight;
+	UCHAR			symbolTranslucence;
+	UCHAR			symbolPlacement;
+	UCHAR			_padding1;
 
 	// candidate list
-	DWORD			candColorBase;
-	DWORD			candColorBorder;
-	DWORD			candColorText;
+	ULONG			candColorBase;
+	ULONG			candColorBorder;
+	ULONG			candColorText;
 
 	// composition string
-	DWORD			compColorInput;
-	DWORD			compColorTargetConv;
-	DWORD			compColorConverted;
-	DWORD			compColorTargetNotConv;
-	DWORD			compColorInputErr;
-	BYTE			compTranslucence;
-	DWORD			compColorText;
+	ULONG			compColorInput;
+	ULONG			compColorTargetConv;
+	ULONG			compColorConverted;
+	ULONG			compColorTargetNotConv;
+	ULONG			compColorInputErr;
+	UCHAR			compTranslucence;
+	UCHAR			_padding2[3];
+	ULONG			compColorText;
 } gosIME_Appearance;
 
 //
 // Opens a DLL and returns a handle
 //
-DWORD __stdcall gos_OpenResourceDLL( const char* FileName );
+ULONG __stdcall gos_OpenResourceDLL( PCSTR FileName );
 
 //
 // Use to close a resource DLL
 //
-void __stdcall gos_CloseResourceDLL( DWORD Handle );
+void __stdcall gos_CloseResourceDLL( ULONG Handle );
 
 //
 // Returns a string from a resource (or a place holder if string not defined)
 //
 // This returns a pointer to an internal GameOS 4K buffer. It is only valid until the next call to gos_GetResourceString
 //
-char* __stdcall gos_GetResourceString( DWORD Handle, DWORD Id );
+PSTR __stdcall gos_GetResourceString( ULONG Handle, ULONG Id );
 
 //
-// Returns a void* to block of memory stored in the resource .dll. Resources
+// Returns a PVOID to block of memory stored in the resource .dll. Resources
 // that are stored in this fashion must be a "custom" resource and their resource type
 // string must match that of the 2nd parameter.
 //
@@ -746,39 +743,39 @@ char* __stdcall gos_GetResourceString( DWORD Handle, DWORD Id );
 // currently designated heap. It is the responsibility of the client application to
 // release this memory when it is no longer needed.
 //
-void* __stdcall gos_GetResourceData( DWORD Handle, const char* type, DWORD id, size_t * size );
+PVOID __stdcall gos_GetResourceData( ULONG Handle, PCSTR type, ULONG id, size_t * size );
 
 //
 // If the user's OS supports IME, this function will Enable/Disable the user's ability to interface with the IME for
 // in the GameOS application. If <enabledDisabled> is false, the user will be unable to bring up the input
 // method editor's interface via ALT-~.
 //
-void _stdcall gos_EnableIME( bool enabledDisabled );
+void _stdcall gos_EnableIME( UCHAR enabledDisabled );
 
 //
 // If the user's OS supports IME, and the IME is enabled (see above), the application can forcibly switch the IME to
 // the active state. When active, the user's keypresses will be fed to the IME for clarification via the IME interface
 // and candidate list. Note that this is the programatic equivalent of the user pressing ALT-~.
 //
-void _stdcall gos_ToggleIME( bool activeInactive );
+void _stdcall gos_ToggleIME( UCHAR activeInactive );
 
 //
 // If the user's OS supports IME, set text entry caret screen position (Used to enable the localization IME pop-up
 // at the correct place):
 //
-void _stdcall gos_PositionIME( DWORD x, DWORD y );
+void _stdcall gos_PositionIME( ULONG x, ULONG y );
 
 //
 // Finalize current composition string. An application should call this function when focused edit box is clicked
 //
-void _stdcall gos_FinalizeStringIME();
+void _stdcall gos_FinalizeStringIME(void);
 
 //
 // Sets IME support level (2 or 3)
 // 2 - Composition string is drawn by IME UI library. GOS application receives characters when composition string is finalized.
 // 3 - Composition string is drawn by GOS application (default). GOS application receives characters and control keys whenever composition string changes.
 //
-void _stdcall gos_SetIMELevel( DWORD dwImeLevel );
+void _stdcall gos_SetIMELevel( ULONG dwImeLevel );
 
 //
 // Sets appearance of IME UI
@@ -794,20 +791,20 @@ void _stdcall gos_GetIMEAppearance( gosIME_Appearance* pia );
 // Tell the IME whether or not the IME should process keystrokes in Overwrite mode
 // (bInsert = false) or in Insert mode (bInsert = true)
 //
-void _stdcall gos_SetIMEInsertMode(bool bInsert);
+void _stdcall gos_SetIMEInsertMode(UCHAR bInsert);
 
 //
 // Returns a localized string describing a date as either short form "02/03/2000" or Verbose form "Wednesday, May 3rd, 1999"
 //
 // If the Year, Month and Day are -1 the current time is used
 //
-char* __stdcall gos_GetFormattedDate( bool Verbose, WORD Year=-1, WORD Month=-1, WORD Day=-1 );
+PSTR __stdcall gos_GetFormattedDate( UCHAR Verbose, USHORT Year=-1, USHORT Month=-1, USHORT Day=-1 );
 
 
 //
 // Returns the year month and day
 //
-void  __stdcall gos_GetUnformattedDate(  WORD *Year, WORD *Month, WORD *Day);
+void  __stdcall gos_GetUnformattedDate(PUSHORT Year, PUSHORT Month, PUSHORT Day);
 
 
 //
@@ -815,7 +812,7 @@ void  __stdcall gos_GetUnformattedDate(  WORD *Year, WORD *Month, WORD *Day);
 //
 // If the Hours, Minutes and Seconds are -1 the current time is used
 //
-char* __stdcall gos_GetFormattedTime( WORD Hour=-1, WORD Minute=-1, WORD Second=-1 );
+PSTR __stdcall gos_GetFormattedTime( USHORT Hour=-1, USHORT Minute=-1, USHORT Second=-1 );
 
 
 
@@ -862,7 +859,7 @@ char* __stdcall gos_GetFormattedTime( WORD Hour=-1, WORD Minute=-1, WORD Second=
 //  CharCount is the ASCII value of the last character in the font
 //  texture plus one.
 //
-HGOSFONT3D __stdcall gos_LoadFont( const char* FontFile, DWORD StartLine = 0, int CharCount = 256, DWORD TextureHandle=0 );
+HGOSFONT3D __stdcall gos_LoadFont( PCSTR FontFile, ULONG StartLine = 0, int CharCount = 256, ULONG TextureHandle=0 );
 
 //
 // This routine should be called to release storage and textures used by fonts.
@@ -881,7 +878,7 @@ void __stdcall gos_DeleteFont( HGOSFONT3D Fonthandle );
 //
 // This API just updates internal variables, it's very fast to change any of these parameters
 //
-void __stdcall gos_TextSetAttributes( HGOSFONT3D FontHandle, DWORD Foreground, float Size, bool WordWrap, bool Proportional, bool Bold, bool Italic, DWORD WrapType=0, bool DisableEmbeddedCodes=0 );
+void __stdcall gos_TextSetAttributes( HGOSFONT3D FontHandle, ULONG Foreground, float Size, UCHAR WordWrap, UCHAR Proportional, UCHAR Bold, UCHAR Italic, ULONG WrapType=0, UCHAR DisableEmbeddedCodes=0 );
 
 //
 // Set the current position of the cursor. (Screen pixels)
@@ -906,13 +903,13 @@ void __stdcall gos_TextSetRegion( int Left, int Top, int Right, int Bottom );
 //  This can be used to draw the 'background' of any text.
 //  Remember! - To set the alpha component of the color to FF if you want a solid background
 //
-void __stdcall gos_TextDrawBackground( int Left, int Top, int Right, int Bottom, DWORD Color );
+void __stdcall gos_TextDrawBackground( int Left, int Top, int Right, int Bottom, ULONG Color );
 
 //
 // Returns pixel height and width of string (Height=Height of charcters * number of /n found)
 //  Make sure you have setup the Text attributes before calling this.
 //
-void __stdcall gos_TextStringLength( DWORD* Width, DWORD* Height, const char *Message, ... );
+void __stdcall gos_TextStringLength( PULONG Width, PULONG Height, PCSTR Message, ... );
 
 //
 // Draws string using current attributes and position
@@ -926,11 +923,11 @@ void __stdcall gos_TextStringLength( DWORD* Width, DWORD* Height, const char *Me
 //		/italic=?			? is 1 or 1
 //		//					/ character (/ not followed by a special code will be displayed as - // is only required to display strings like "//color"
 //
-void __stdcall gos_TextDraw( const char *Message, ... );
+void __stdcall gos_TextDraw( PCSTR Message, ... );
 //
 // Same as above, but an arglist can be passed
 //
-void __stdcall gos_TextDrawV( const char *Message, char* arglist );
+void __stdcall gos_TextDrawV( PCSTR Message, PSTR arglist );
 
 
 
@@ -957,30 +954,30 @@ void __stdcall gos_TextDrawV( const char *Message, char* arglist );
 // The whole file in read into memory, MemoryImage will point to the start of the file,
 // Size will be the size of the file.
 //
-void __stdcall gos_GetFile( const char* FileName, BYTE** MemoryImage, DWORD* Size );
+void __stdcall gos_GetFile( PCSTR FileName, PUCHAR* MemoryImage, PULONG Size );
 
 
 //
 // Opens a memory mapped file - returns a handle that must be passed to the Close function below.
 //
-DWORD __stdcall gos_OpenMemoryMappedFile( const char* FileName, BYTE** MemoryImage, DWORD* Size );
+ULONG __stdcall gos_OpenMemoryMappedFile( PCSTR FileName, PUCHAR* MemoryImage, PULONG Size );
 
 //
 // Closes a memory mapped file
 //
-void __stdcall gos_CloseMemoryMappedFile( DWORD Handle );
+void __stdcall gos_CloseMemoryMappedFile( ULONG Handle );
 
 
 //
 // Opens and reads in the whole file in a background thread. The MemoryImage pointer will be NULL until the file is read in completly.
 //    When you are finished with the file, the Close function below must be called.
 //
-DWORD __stdcall gos_ReadFileInBackground( const char* FileName, BYTE** MemoryImage, DWORD* Size, DWORD Offset=0, DWORD MaxSize=0xffffffff );
+ULONG __stdcall gos_ReadFileInBackground( PCSTR FileName, PUCHAR* MemoryImage, PULONG Size, ULONG Offset=0, ULONG MaxSize=0xffffffff );
 
 //
 // Closes and releases the memory used by a file read in the background.
 //
-void __stdcall gos_CloseBackgroundFile( DWORD Handle );
+void __stdcall gos_CloseBackgroundFile( ULONG Handle );
 
 
 
@@ -1027,25 +1024,27 @@ extern HGOSHEAP ParentClientHeap;
 // Not filling in the heap parameter on gos_Malloc's tells the Memory Manager to allocate memory in
 // the heap currently on top of the heap stack.
 //
-void* __stdcall gos_Malloc( size_t bytes, HGOSHEAP Heap = 0 );
-void __stdcall gos_Free( void* ptr );
+PVOID __stdcall gos_Malloc( size_t bytes, HGOSHEAP Heap = 0 );
+void __stdcall gos_Free( PVOID ptr );
 
 //
 // Not filling in the heap parameter on new's tells the Memory Manager to allocate memory in
 // the heap currently on top of the heap stack.
-//
-void* __cdecl operator new (size_t size, HGOSHEAP Heap);
+
+#ifdef __cplusplus
+PVOID __cdecl operator new (size_t size, HGOSHEAP Heap);
+#endif
 
 //
 // Allows an application to create a named memory heap.
 //
-// The DWORD returned is a heap number that can be the second parameter passed to new or gos_Malloc.
+// The ULONG returned is a heap number that can be the second parameter passed to new or gos_Malloc.
 //
 // If MaximumSize is specified, GameOS will assert when more than that number of bytes is allocated.
 //
 // The memory heaps and current sizes are visible in the GameOS debugger.
 //
-HGOSHEAP __stdcall gos_CreateMemoryHeap( char* HeapName, DWORD MaximumSize=0, HGOSHEAP parentHeap = ParentClientHeap);
+HGOSHEAP __stdcall gos_CreateMemoryHeap( PSTR HeapName, ULONG MaximumSize=0, HGOSHEAP parentHeap = ParentClientHeap);
 
 //
 // Allows the application to destroy a previously created memory heap.
@@ -1056,7 +1055,7 @@ HGOSHEAP __stdcall gos_CreateMemoryHeap( char* HeapName, DWORD MaximumSize=0, HG
 //   still assigned to the heap or its children. We don't encourage this
 //   as it can result in non-NULLed pointers within the client code.
 //
-void __stdcall gos_DestroyMemoryHeap( HGOSHEAP Heap, bool shouldBeEmpty = true );
+void __stdcall gos_DestroyMemoryHeap( HGOSHEAP Heap, UCHAR shouldBeEmpty = 1 );
 
 //
 // Sets the current heap being used by new and delete (and any gos_Mallocs that don't specifiy a heap)
@@ -1065,9 +1064,9 @@ void __stdcall gos_DestroyMemoryHeap( HGOSHEAP Heap, bool shouldBeEmpty = true )
 //
 void __stdcall gos_PushCurrentHeap( HGOSHEAP Heap );
 
-HGOSHEAP __stdcall gos_GetCurrentHeap();
+HGOSHEAP __stdcall gos_GetCurrentHeap(void);
 
-void __stdcall gos_PopCurrentHeap();
+void __stdcall gos_PopCurrentHeap(void);
 
 //
 // To verify that memory hasn't been corrupted during particularly dicey operations, the gos_WalkMemoryHeap
@@ -1080,7 +1079,7 @@ void __stdcall gos_PopCurrentHeap();
 //         in the specified heap at the time of the call. These SPEWs will occur only if Environment.memoryTraceLevel
 //         is
 //
-void __stdcall gos_WalkMemoryHeap(HGOSHEAP pHeap, bool vociferous = false);
+void __stdcall gos_WalkMemoryHeap(HGOSHEAP pHeap, UCHAR vociferous = 0);
 
 
 
@@ -1101,8 +1100,7 @@ void __stdcall gos_WalkMemoryHeap(HGOSHEAP pHeap, bool vociferous = false);
 
 //////////////////////////////////////////////////////////////////////////////////
 // A list of the "buttons" on a keyboard.
-typedef enum gosEnum_KeyIndex
-{
+typedef enum gosEnum_KeyIndex {
 	KEY_ESCAPE		= 0x1B,
 	KEY_1			= '1',
 	KEY_2			= '2',
@@ -1229,23 +1227,21 @@ typedef enum gosEnum_KeyIndex
 	KEY_MMOUSE		= 3,		// Middle mouse button
 	KEY_MOUSEX1		= 4,		// New mouse button 1
 	KEY_MOUSEX2		= 5,		// New mouse button 2
-};
+} gosEnum_KeyIndex;
 
-typedef enum gosEnum_KeyStatus
-{
+typedef enum gosEnum_KeyStatus {
 	KEY_FREE,
 	KEY_PRESSED,
 	KEY_HELD,
 	KEY_RELEASED,
-};
+} gosEnum_KeyStatus;
 
-typedef enum gosEnum_KeyDeviceType
-{
+typedef enum gosEnum_KeyDeviceType {
 	KEYDEV_KEYBOARD = 0x00000000,
 	KEYDEV_JOYSTICK = 0x01000000,
-};
+} gosEnum_KeyDeviceType;
 
-enum { KEYDEV_MASK = 0xff000000 };
+typedef enum _KeyDevice_const { KEYDEV_MASK = 0xff000000 };
 
 //////////////////////////////////////////////////////////////////////////////////
 // Get the status of key <index>. TRUE means it is pressed, while FALSE means
@@ -1278,17 +1274,17 @@ gosEnum_KeyStatus __stdcall gos_GetKeyStatus( gosEnum_KeyIndex index );
 // byte will always be zero (since these buttons never map to ASCII).  For example, a return value of
 // 0x01020300 is button 3 on joystick #2.
 //
-DWORD __stdcall gos_GetKey();
+ULONG __stdcall gos_GetKey(void);
 
 
 //
 // Returns the displayable name of a key press returned from gos_GetKey() eg: "A", "Cursor Left" or "Enter"
 //
-char* __stdcall gos_DescribeKey( DWORD Key );
+PSTR __stdcall gos_DescribeKey( ULONG Key );
 
 //////////////////////////////////////////////////////////////////////////////////
 // Clear the client keyboard buffer
-void __stdcall gos_KeyboardFlush();
+void __stdcall gos_KeyboardFlush(void);
 
 
 
@@ -1309,8 +1305,7 @@ void __stdcall gos_KeyboardFlush();
 //
 // The various outputs that can be examined by GameOS.
 //
-typedef enum GOSJoystickAxis
-{
+typedef enum GOSJoystickAxis {
 	JOY_XAXIS = 0,
 	JOY_YAXIS = 1,
 	JOY_ZAXIS = 2,
@@ -1330,30 +1325,29 @@ typedef enum GOSJoystickAxis
 	JOY_HAT4 = 11,
 	JOY_POV4 = 11,
 	JOY_MAX = 12
-};
+} GOSJoystickAxis;
 
 
 //
 // Information returned about each joystick
 //
-struct gosJoystick_Info
+typedef struct gosJoystick_Info
 {
-	const char*	lpstrName;				// the brand and model name
-	DWORD		bAxisValid:JOY_MAX;		// yes/no bitflags.
-	DWORD  		nAxes:4;				// number of availab axes
-	DWORD  		nButtons:5;				// number of available buttons
-	DWORD  		nSliders:4;				// number of slidesr
-	DWORD  		nPOVs:4;				// number of point of view hats
-	DWORD  		bIsPolled:1;			// whether or not this stick is polled
-	DWORD 		bIsForceFeedback:1;
+	PCSTR	lpstrName;				// the brand and model name
+	ULONG		bAxisValid:JOY_MAX;		// yes/no bitflags.
+	ULONG  		nAxes:4;				// number of availab axes
+	ULONG  		nButtons:5;				// number of available buttons
+	ULONG  		nSliders:4;				// number of slidesr
+	ULONG  		nPOVs:4;				// number of point of view hats
+	ULONG  		bIsPolled:1;			// whether or not this stick is polled
+	ULONG 		bIsForceFeedback:1;
 											// 1 spare bit
-};
+} gosJoystick_Info;
 
 //
 // Used in defining a force feedback forces
 //
-typedef enum gosForce
-{
+typedef enum gosForce {
 	gosForce_Constant,
 	gosForce_Ramp,
 	gosForce_Square,
@@ -1361,7 +1355,7 @@ typedef enum gosForce
 	gosForce_Triangle,
 	gosForce_SawtoothUp,
 	gosForce_SawtoothDown
-};
+} gosForce;
 
 #define gosFOREVER -1.0f
 
@@ -1376,7 +1370,7 @@ typedef struct
 typedef struct _gosJoystick_ForceEffect
 {
 	gosForce	eType;
-	bool		bAffectedAxes[12];
+	UCHAR		bAffectedAxes[12];
 	float		fXOrigin, fYOrigin;
 	float		fMagnitude;
 	float		fDurationSec;
@@ -1405,36 +1399,36 @@ typedef struct _gosJoystick_ForceEffect
 //
 // If ReDetect is 0, the joysticks are not re-init'ed this can take up to two seconds on some hardware
 //
-DWORD __stdcall gosJoystick_CountJoysticks( bool ReDetect=1 );
+ULONG __stdcall gosJoystick_CountJoysticks( UCHAR ReDetect=1 );
 
 //
 // Return joystick <index>'s details in structure <gji>
 //
-void __stdcall gosJoystick_GetInfo( DWORD index, gosJoystick_Info* gji );
+void __stdcall gosJoystick_GetInfo( ULONG index, gosJoystick_Info* gji );
 
 //
 // Turn the polling of joystick <index> on or off. howOften variable details the
 // frequency of polling. A 'howOften' of .5 will poll twice per second, for
 // example.	By default, it polls at 30Hz.
 //
-void __stdcall gosJoystick_SetPolling( DWORD index, bool yesNo, float howOften=0.03333f );
+void __stdcall gosJoystick_SetPolling( ULONG index, UCHAR yesNo, float howOften=0.03333f );
 
 //
 // Return the current value of a particular joystick's particular axis. The
 // value is mapped internally to range between -1.0f and 1.0f.
 // except for POV which are at -1 when at rest, a %clockwise when engaged
 //
-float __stdcall gosJoystick_GetAxis( DWORD index, GOSJoystickAxis axis );
+float __stdcall gosJoystick_GetAxis( ULONG index, GOSJoystickAxis axis );
 
 //
 // Return a value (FALSE unpressed, TRUE pressed) for the button <button> on joystick <index>.
 //
-bool __stdcall gosJoystick_ButtonStatus( DWORD index, DWORD button );
+UCHAR __stdcall gosJoystick_ButtonStatus( ULONG index, ULONG button );
 
 //
 // Play the precreated effect <ff>, iterating it <time> times.
 //
-void __stdcall gosJoystick_PlayEffect( HGOSFORCEEFFECT ff, DWORD times = 1 );
+void __stdcall gosJoystick_PlayEffect( HGOSFORCEEFFECT ff, ULONG times = 1 );
 
 //
 // Stop playing <ff>
@@ -1444,12 +1438,12 @@ void __stdcall gosJoystick_StopEffect( HGOSFORCEEFFECT ff );
 //
 // Create a force feedback effect <ff> on joystick <joy>, given the parameters specified in <fe>
 //
-void __stdcall gosJoystick_CreateEffect( HGOSFORCEEFFECT* ff, DWORD joystick, gosJoystick_ForceEffect* fe );
+void __stdcall gosJoystick_CreateEffect( HGOSFORCEEFFECT* ff, ULONG joystick, gosJoystick_ForceEffect* fe );
 
 //
 // Load a feedback effect from an FFE file onto joystick <joy>
 //
-void __stdcall gosJoystick_LoadEffect(HGOSFORCEEFFECT * ff, DWORD joystick, const char * file);
+void __stdcall gosJoystick_LoadEffect(HGOSFORCEEFFECT * ff, ULONG joystick, PCSTR  file);
 
 //
 // Update the force feedback effect <ff>, given the parameters specified in <fe>
@@ -1464,7 +1458,7 @@ void __stdcall gosJoystick_DestroyEffect( HGOSFORCEEFFECT* fe );
 //
 // Determine whether a feedback effect is still playing
 //
-bool __stdcall gosJoystick_IsEffectPlaying(HGOSFORCEEFFECT fe);
+UCHAR __stdcall gosJoystick_IsEffectPlaying(HGOSFORCEEFFECT fe);
 
 
 
@@ -1504,7 +1498,7 @@ bool __stdcall gosJoystick_IsEffectPlaying(HGOSFORCEEFFECT fe);
 //
 // You may pass zero as any parameter you do not wish to query
 //
-void __stdcall gos_GetMouseInfo( float* pXPosition, float* pYPosition, int* pXDelta, int* pYDelta, int* pWheelDelta, DWORD* pButtonsPressed );
+void __stdcall gos_GetMouseInfo( float* pXPosition, float* pYPosition, int* pXDelta, int* pYDelta, int* pWheelDelta, PULONG pButtonsPressed );
 
 //
 // This function allows the application to move the windows mouse cursor.
@@ -1561,34 +1555,28 @@ double __stdcall gos_GetElapsedTime( int RealTime=0 );
 
 //
 // Loads *szData bytes into *pData from the registry key specified.
-//
-// The data can be a DWORD, Binary value or string
-//
+// The data can be a ULONG, Binary value or string
 // If the key does not exist szData will be set to 0 and pData will not be altered
-//
 // If the *szData will be set to the actual number of bytes read
-//
 // Normally all registry data is saved and read from HKEY_CURRENT_USER\Software\Microsoft\Microsoft Games\App Name
-//
 // Data can be read from HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft Games\App Name, but not written (this would require a machine administrator)
-//
-// When 'bool HKLM' on the read function is true it will read from LOCAL_MACHINE, otherwise CURRENT_USER. The write functions ONLY work to CURRENT_USER
-//
-void __stdcall gos_LoadDataFromRegistry( char* keyName, void* pData, DWORD* szData, bool HKLM=false );
+// When 'UCHAR HKLM' on the read function is true it will read from LOCAL_MACHINE, otherwise CURRENT_USER. The write functions ONLY work to CURRENT_USER
+
+void __stdcall gos_LoadDataFromRegistry( PSTR keyName, PVOID pData, PULONG szData, UCHAR HKLM=0 );
 
 //
 // Saves szData bytes starting at pData into the registry key specified.
 //
-// If szData is 4 the data will be saved as a DWORD, otherwise just binary data
+// If szData is 4 the data will be saved as a ULONG, otherwise just binary data
 //
-void __stdcall gos_SaveDataToRegistry( char* keyName,  void* pData,  DWORD szData );
+void __stdcall gos_SaveDataToRegistry( PSTR keyName,  PVOID pData,  ULONG szData );
 
 //
 // Saves a string starting at pData, length szData into the registry key specified.
 //
 // This is the same as the gos_SaveDataToRegistry API, except it's saved as a readable string
 //
-void __stdcall gos_SaveStringToRegistry( char* keyName,  char* pData,  DWORD szData );
+void __stdcall gos_SaveStringToRegistry( PSTR keyName,  PSTR pData,  ULONG szData );
 
 
 
@@ -1628,7 +1616,7 @@ void __stdcall gos_SaveStringToRegistry( char* keyName,  char* pData,  DWORD szD
 //  launched by a lobby server the command line will be "-lobby" - the game should bypass any
 //  user interface and call gos_NetCheckLobby() as soon as possible.
 //
-bool __stdcall gos_NetCheckLobby();
+UCHAR __stdcall gos_NetCheckLobby(void);
 
 //
 // Enters GameOS 'modal scripts' that prompt for join/create network game.
@@ -1638,148 +1626,113 @@ bool __stdcall gos_NetCheckLobby();
 // GameOptionsScript is legacy and should be set to 0
 // When Secure is true, encrypted packets are allowed and certain DPLAY messages will be encrypted and signed.
 //
-bool __stdcall gos_NetStartGame( char* GameOptionsScript, bool Secure=0 );
+UCHAR __stdcall gos_NetStartGame( PSTR GameOptionsScript, UCHAR Secure=0 );
 
 //
 // Leaves the current network game.
 //
-void __stdcall gos_NetEndGame();
+void __stdcall gos_NetEndGame(void);
 
 //
 // Returns networking information
 //
-typedef enum
-{
-	gos_Networking,				// (DWORD)  Returns TRUE if in a networked game
-	gos_AmITheServer,			// (DWORD)  Returns TRUE if you created the game (FALSE=Joined)
-	gos_NumberOfPlayers,		// (DWORD)  Returns the number of players in the game
-	gos_MyIPAddress,			// (char*)  Returns string of IP address.  Can be 0.0.0.0 in non-tcpip games
-	gos_MyID,					// (DWORD)  Returns a PlayerID for this machines player NUMBER
-	gos_ServerID,				// (DWORD)  Returns a PlayerID that represents the current server
-	gos_AllID,					// (DWORD)  Returns a PlayerID that represents 'All Players'
-	gos_PlayerName,				// (char*)  Returns a char* for the player NUMBER passed in the parameter
-	gos_PlayerID,				// (DWORD)  Returns a PlayerID for the player NUMBER passed in the parameter
-	gos_PlayerNumber,			// (DWORD)  Returns a NUMBER for the PlayerID passed in the parameter (or 0xffffffff if not found)
-	gos_LockedStatus,			// (DWORD)  Returns TRUE if the game is currently locked
-	gos_GameSecure,				// (DWORD)	Returns TRUE if the host created the game as a secure game
-	gos_GamePassword,			// (char*)	Returns NULL or a pointer to the ASCII password used to create or join the game
+typedef enum gosNetInfo {
+	gos_Networking,				// (ULONG)  Returns TRUE if in a networked game
+	gos_AmITheServer,			// (ULONG)  Returns TRUE if you created the game (FALSE=Joined)
+	gos_NumberOfPlayers,		// (ULONG)  Returns the number of players in the game
+	gos_MyIPAddress,			// (PSTR)  Returns string of IP address.  Can be 0.0.0.0 in non-tcpip games
+	gos_MyID,					// (ULONG)  Returns a PlayerID for this machines player NUMBER
+	gos_ServerID,				// (ULONG)  Returns a PlayerID that represents the current server
+	gos_AllID,					// (ULONG)  Returns a PlayerID that represents 'All Players'
+	gos_PlayerName,				// (PSTR)  Returns a PSTR for the player NUMBER passed in the parameter
+	gos_PlayerID,				// (ULONG)  Returns a PlayerID for the player NUMBER passed in the parameter
+	gos_PlayerNumber,			// (ULONG)  Returns a NUMBER for the PlayerID passed in the parameter (or 0xffffffff if not found)
+	gos_LockedStatus,			// (ULONG)  Returns TRUE if the game is currently locked
+	gos_GameSecure,				// (ULONG)	Returns TRUE if the host created the game as a secure game
+	gos_GamePassword,			// (PSTR)	Returns NULL or a pointer to the ASCII password used to create or join the game
 //
 // Networking status information
 //
-	gos_PacketsSentLastFrame,	// (DWORD)  Returns number of packets sent in the past frame to the player NUMBER passed
-	gos_PacketsFromLastFrame,	// (DWORD)  Returns number of packets recieved in the past Frame from the player NUMBER passed
-	gos_BytesSentLastFrame,		// (DWORD)  Returns number of bytes sent in the past Frame to the player NUMBER passed
-	gos_BytesFromLastFrame,		// (DWORD)  Returns number of bytes recieved in the past Frame from the player NUMBER passed
-	gos_BandwithSentLastFrame,	// (DWORD)  Returns total number of bytes sent in the past Frame to the player NUMBER passed (including packet overhead)
-	gos_BandwithFromLastFrame,	// (DWORD)  Returns total number of bytes recieved in the past Frame from the player NUMBER passed (including packet overhead)
-	gos_PacketsLostLastFrame,	// (DWORD)  Returns number of packets lost from the player NUMBER passed (based on packet numbers and retries)
-	gos_LatencyLastFrame,		// (DWORD)  Returns the average response time for any guaranteed packets sent in the last frame to the player NUMBER
-	gos_GetMessageSendQueue,	// (DWORD)  Returns the number of messages still in this machines send queue to the player NUMBER passed
-	gos_GetNumOutboudWindows,	// (DWORD)  Returns the number of outbound window objects that exist
-	gos_GetOutboundWindowSize,	// (DWORD)	Returns the current number of outstanding packets sent to a given outbound message window object
-	gos_GetOB_NxtPkt2Send,		// (DWORD) Returns the next packet number to send for a specified outbound window index
-	gos_GetOB_LstPktRcvd,		// (DWORD) Returns the last packet received from a specified outbound window index
-	gos_GetOB_LstPktTheyRcvd,	// (DWORD) Returns the last packet that the specified outbound window index received
-//
-// Internal functions used for browsing, creating and joining games
-//
-	gos_InformationAboutGame,	// (BYTE*)  Returns a pointer to 16 bytes of information from the game, Name=Game Name  (Games set this in Environment.NetGameInfo)
-	gos_NumberOfGames,			// (DWORD)  Returns the number of Games found on network
-	gos_NameOfGame,				// (char*)  Returns the name of the Game with the parameter passed
-	gos_IsGamePassworded,		// (DWORD)	Returns true if the game name passed is passworded, Name=Game Name
-	gos_IsGameSecure,			// (DWORD)	Returns true if the game name passed is secure, Name=Game Name
-	gos_IsGameLocked,			// (DWORD)	Returns true if the game name passed is locked so no more players can enter, Name=Game Name
-	gos_NumberOfPlayersInGame,	// (DWORD)  Returns number of players in a game, Name=Game Name
-	gos_MaxPlayersInGame,		// (DWORD)  Returns maximum number of players in a game, Name=Game Name
-	gos_NameOfPlayersInGame,	// (char*)  Return players name - Parameter=Player #, Name=Game Name.
-	gos_NumberOfModems,			// (DWORD)  Returns the number of modems installed
-	gos_NameOfModem,			// (char*)  Returns the name of the modem number passed
-	gos_NumberOfSerialPorts,	// (DWORD)  Returns the number of serial ports installed
-	gos_NameOfSerialPort,		// (char*)  Returns the name of the serial port number passed
-
+	gos_PacketsSentLastFrame,	// (ULONG)  Returns number of packets sent in the past frame to the player NUMBER passed
+	gos_PacketsFromLastFrame,	// (ULONG)  Returns number of packets recieved in the past Frame from the player NUMBER passed
+	gos_BytesSentLastFrame,		// (ULONG)  Returns number of bytes sent in the past Frame to the player NUMBER passed
+	gos_BytesFromLastFrame,		// (ULONG)  Returns number of bytes recieved in the past Frame from the player NUMBER passed
+	gos_BandwithSentLastFrame,	// (ULONG)  Returns total number of bytes sent in the past Frame to the player NUMBER passed (including packet overhead)
+	gos_BandwithFromLastFrame,	// (ULONG)  Returns total number of bytes recieved in the past Frame from the player NUMBER passed (including packet overhead)
+	gos_PacketsLostLastFrame,	// (ULONG)  Returns number of packets lost from the player NUMBER passed (based on packet numbers and retries)
+	gos_LatencyLastFrame,		// (ULONG)  Returns the average response time for any guaranteed packets sent in the last frame to the player NUMBER
+	gos_GetMessageSendQueue,	// (ULONG)  Returns the number of messages still in this machines send queue to the player NUMBER passed
+	gos_GetNumOutboudWindows,	// (ULONG)  Returns the number of outbound window objects that exist
+	gos_GetOutboundWindowSize,	// (ULONG)	Returns the current number of outstanding packets sent to a given outbound message window object
+	gos_GetOB_NxtPkt2Send,		// (ULONG) Returns the next packet number to send for a specified outbound window index
+	gos_GetOB_LstPktRcvd,		// (ULONG) Returns the last packet received from a specified outbound window index
+	gos_GetOB_LstPktTheyRcvd,	// (ULONG) Returns the last packet that the specified outbound window index received
 
+// Internal functions used for browsing, creating and joining games
+	gos_InformationAboutGame,	// (PUCHAR)  Returns a pointer to 16 bytes of information from the game, Name=Game Name  (Games set this in Environment.NetGameInfo)
+	gos_NumberOfGames,			// (ULONG)  Returns the number of Games found on network
+	gos_NameOfGame,				// (PSTR)  Returns the name of the Game with the parameter passed
+	gos_IsGamePassworded,		// (ULONG)	Returns true if the game name passed is passworded, Name=Game Name
+	gos_IsGameSecure,			// (ULONG)	Returns true if the game name passed is secure, Name=Game Name
+	gos_IsGameLocked,			// (ULONG)	Returns true if the game name passed is locked so no more players can enter, Name=Game Name
+	gos_NumberOfPlayersInGame,	// (ULONG)  Returns number of players in a game, Name=Game Name
+	gos_MaxPlayersInGame,		// (ULONG)  Returns maximum number of players in a game, Name=Game Name
+	gos_NameOfPlayersInGame,	// (PSTR)  Return players name - Parameter=Player #, Name=Game Name.
+	gos_NumberOfModems,			// (ULONG)  Returns the number of modems installed
+	gos_NameOfModem,			// (PSTR)  Returns the name of the modem number passed
+	gos_NumberOfSerialPorts,	// (ULONG)  Returns the number of serial ports installed
+	gos_NameOfSerialPort,		// (PSTR)  Returns the name of the serial port number passed
 } gosNetInfo;
 
-void* __stdcall gos_NetInformation( gosNetInfo Info, DWORD Parameter=0, char* Name=0 );
+PVOID __stdcall gos_NetInformation( gosNetInfo Info, ULONG Parameter=0, PSTR Name=0 );
 
 
 
 //
 // Flags that can be used in NetPacket.Flags
-//
-typedef enum
-{
+typedef enum gosNetFlags {
 	gosNetFlag_guaranteed=1,	// Will arrive at destination in order and guaranteed.
 	gosNetFlag_encrypt=2,		// Will encrypt the packet before sending (only valid in a secure game)
-
 } gosNetFlags;
 
 //
 // These are the system messages that may be recieved by the application
 //
-const BYTE gosNet_PlayerAdded=240;		// FromID will contain the new PlayerID of the player. gos_NetInformation(gos_NumberOfPlayers) will be greater than last game logic.
-const BYTE gosNet_PlayerDeleted=241;	// FromID will contain the old PlayerID of the player. gos_NetInformation will work with this ID only for the remainder of the current GameLogic. (Packets sent to the player will be ignored)
-const BYTE gosNet_GameEnded=242;		// The server has ended the network game. This is the last packet the game will see.
-const BYTE gosNet_Ping=243;				// Used to send a ping packet. You will eventually receive back a ping packet containing four DWORD containing the milliseconds time at each end of a 'double ping'.
-const BYTE gosNet_Heartbeat=244;		// Used to send a heartbeat packet to keep the outbound window up to date.
+const UCHAR gosNet_PlayerAdded=240;		// FromID will contain the new PlayerID of the player. gos_NetInformation(gos_NumberOfPlayers) will be greater than last game logic.
+const UCHAR gosNet_PlayerDeleted=241;	// FromID will contain the old PlayerID of the player. gos_NetInformation will work with this ID only for the remainder of the current GameLogic. (Packets sent to the player will be ignored)
+const UCHAR gosNet_GameEnded=242;		// The server has ended the network game. This is the last packet the game will see.
+const UCHAR gosNet_Ping=243;				// Used to send a ping packet. You will eventually receive back a ping packet containing four ULONG containing the milliseconds time at each end of a 'double ping'.
+const UCHAR gosNet_Heartbeat=244;		// Used to send a heartbeat packet to keep the outbound window up to date.
 
-//
-//
-// This is a network packet header for sent and recieved packets. This is not sent with each packet, it just contains packet information
-//
-//
+// This is a network packet header for sent and recieved packets. This is not sent 
+// with each packet, it just contains packet information
 #pragma pack(push,1)
-
-typedef struct _NetPacket
-{
-	DWORD	FromID;					// Filled in by when packets are recieved
-	DWORD	ToID;					// Must be filled in to send a packet
-
-	WORD	Flags;					// Information flags (see gosNetFlag_*) - only valid on sending messages
-
+typedef struct _NetPacket {
+	ULONG	FromID;					// Filled in by when packets are recieved
+	ULONG	ToID;					// Must be filled in to send a packet
+	USHORT	Flags;					// Information flags (see gosNetFlag_*) - only valid on sending messages
 	double	TimeStamp;				// Timestamp set by GameOS when the packet was recieved
-
-	WORD	Length;					// Number of bytes of data.
-
-	BYTE	Type;					// Type of message (224-> System messages)
-
-	void	*pData;					// Pointer to message data
-
+	USHORT	Length;					// Number of bytes of data.
+	UCHAR	Type;					// Type of message (224-> System messages)
+	PVOID   pData;					// Pointer to message data
 } NetPacket;
-
 #pragma pack(pop)
 
-
-//
 // Get the next network message, returns 0 when no more messages
-//
-NetPacket* __stdcall gos_NetGetMessage();
+NetPacket* __stdcall gos_NetGetMessage(void);
 
-//
 // Send a network message
-//
-bool __stdcall gos_NetSendMessage( NetPacket* Message );
-
-
+UCHAR __stdcall gos_NetSendMessage( NetPacket* Message );
 
-
-
-
-//
 // If this computer is the server these commands can be used
-//
-typedef enum
-{
+typedef enum gos_NetCommands {
 	gos_Command_KillPlayer,			// Remove the player with PlayerID == Data1 from the game
 	gos_Command_LockGame,			// Datat1=1 to lock the game, 0=to unlock the game - no more players can join when a game is locked
 	gos_Command_UpdateGameData,		// Updates the 'game data' from Environment.NetGameInfo - so players enumerating games can see the changes
 	gos_Commend_UpdateMaxPlayers,	// Updates the number of maximum players allowed in a game from Environment.NetworkMaxPlayers
-
 } gos_NetCommands;
-//
-//
-//
-void __stdcall gos_NetServerCommands( gos_NetCommands Command, DWORD Data1 );
+
+void __stdcall gos_NetServerCommands( gos_NetCommands Command, ULONG Data1 );
 
 
 
@@ -1812,7 +1765,7 @@ void __stdcall gos_srand( unsigned int seed );
 //
 // Return a random number between 0 and 32767
 //
-int __stdcall gos_rand();
+int __stdcall gos_rand(void);
 
 
 
@@ -1924,8 +1877,7 @@ typedef enum gos_CompareMode
 //
 // Functions for stencil operations
 //
-typedef enum gos_StencilFunctions
-{
+typedef enum gos_StencilFunctions {
 	gos_Stencil_Keep=1,			// Do not update the stencil buffer
 	gos_Stencil_Zero=2,			// Set stencil buffer to 0
 	gos_Stencil_Replace=3,		// Set stencil buffer to reference value
@@ -1934,93 +1886,59 @@ typedef enum gos_StencilFunctions
 	gos_Stencil_Invert=6,		// Invert the stencil bits
 	gos_Stencil_Incr=7,			// Increment the stencil value
 	gos_Stencil_Decr=8,			// Decrement the stencil value
-};
+} gos_StencilFunctions;
 
 //
 // Supported multitexture modes
 //
-typedef enum gos_MutitextureModes
-{
+typedef enum gos_MutitextureModes {
 	gos_Multitexture_None=0,			// Multitexture is disabled
 	gos_Multitexture_LightMap=1,		// The second texture will be modulate2X with the base texture
 	gos_Multitexture_SpecularMap=2,		// The second texture will be ADDed with the base texture
 	gos_Multitexture_DetailTexture=3,	// The second texture will be blended with the 1st based on the alpha channel in the 1st texture
 	gos_Multitexture_BumpEnvMap=4,		// Tex0=base (u0,v0), Tex1=bump (u0,v0), Tex2=envmap (u1,v1)
 	gos_Multitexture_BumpDotMap=5,		// Tex0=base (u0,v0), Tex1=normalmap (u0,v0)
-};
+} gos_MutitextureModes;
 
 
 //
 // Renderstate offsets in structure.
 //
-typedef enum gos_RenderState
-{
+typedef enum gos_RenderState {
 	gos_State_Texture=1,		// Default: 0						Current texture handle. 0=No texture
-
 	gos_State_Texture2,			// Default: 0						2nd Texture handle used in multitexture rendering modes
-
 	gos_State_Texture3,			// Default: 0						3rd Texture handle used in bump environment map rendering mode
-
 	gos_State_Filter,			// Default: gos_FilterNone			gos_FilterMode
-
 	gos_State_ZCompare,			// Default: 1						0=No z buffer test, 1=LessEqual test with z buffer, 2=Less test
-
 	gos_State_ZWrite,			// Default: 1						true/false - write to ZBuffer enabled/disabled
-
 	gos_State_AlphaTest,		// Default: 0						true/false - Do not update screen or Z with Alpha=0 pixels
-
 	gos_State_Perspective,		// Default: 1						true/false - Enable perspective correct rendering
-
 	gos_State_Specular,			// Default: 0						true/false - Enable specular highlights
-
 	gos_State_Dither,			// Default: 0						true/false	(Improves gouraud shading)
-
 	gos_State_Clipping,			// Default: 0						1=D3D clipping, 2=Guard band clipping if available or D3D Clipping if not
-
 	gos_State_WireframeMode,	// Default: 0						true/false - Enable wireframe mode
-
 	gos_State_AlphaMode,		// Default: gos_Alpha_OneZero		gos_AlphaMode
-
 	gos_State_TextureAddress,	// Default: gos_TextureWrap			gos_TextureAddressMode
-
 	gos_State_ShadeMode,		// Default: gos_ShadeGouraud		gos_ShadeAddressMode (Note in FLAT, set all vertex colors to the same to allow clipping to work correctly)
-
 	gos_State_TextureMapBlend,	// Default: gos_BlendModulateAlpha	gos_TextureMapBlendMode
-
 	gos_State_MipMapBias,		// Default: 0						Number of larger mipmap levels to not use (Max value=4 - would means 256*256 textures used the 16*16)
-
 	gos_State_Fog,				// Default: 0						Pointer to the fog color (when not 0 application must use 'f' in vertex for fog density)
-
 	gos_State_MonoEnable,		// Default: 0						This is a hint to the software rasterizer that the RGB colors of vertices are all the same (intensity). Bit 8 enables 'pixel doubling' in Blade only.
-
 	gos_State_Culling,			// Default: gos_CullMode			Default gos_Cull_None, This renderstate rejects polygons if they are facing away or towards the screen
-
 	gos_State_StencilEnable,	// Default: false					true/false  - Enable stencil operations
-
 	gos_State_StencilFunc,		// Default: gos_Cmp_Never			Set to one of the gos_CompareMode values
-
 	gos_State_StencilRef,		// Default: 0						Set to the pixel value to compare`
-
 	gos_State_StencilMask,		// Default: 0xffffffff				Used to mask the reference and pixel before the compare
-
 	gos_State_StencilZFail,		// Default: gos_Stencil_Keep		Operation on the stencil buffer to perform when the function passes, but the Z buffer test fails
-
 	gos_State_StencilFail,		// Default: gos_Stencil_Keep		Operation on the stencil buffer to perform when the function fails
-
 	gos_State_StencilPass,		// Default: gos_Stencil_Keep		Operation on the stencil buffer to perform when the function passes and so does the Z buffer test
-
 	gos_State_Multitexture,		// Default: gos_Multitexture_None	Select multitexture mode for rendering (see gos_GetMachineInformation to see if modes are valid)
-
 	gos_State_Ambient,			// Default: 0xffffff				Set the Ambient lighting for the scene when using hardware T&L
-	
 	gos_State_Lighting,			// Default: 0						true / flase - Enables D3D lighting when using hardware T&L
-
 	gos_State_NormalizeNormals,	// Default: 0						true / false - Enables automatic normalization of vertex normals when using hardware T&L
-
 	gos_State_VertexBlend,		// Default: 0						Number of blend weights in each vertex to blend (Only 0 or 1 valid currently)
-
 	gos_MaxState				// Marker for last render state
-};
+} gos_RenderState;
 
 //
 // Vertex used by low level rasterizer
@@ -2033,48 +1951,46 @@ typedef enum gos_RenderState
 // x = x*ViewportMulX + ViewportAddX
 // y = y*ViewportMulY + ViewportAddY
 //
-typedef struct
-{
+typedef struct _gos_VERTEX {
 	float x,y;					// Screen coords	- must be 0.0 to Environment.screenWidth/Height (no clipping occurs unless gos_State_Clipping is true)
 	float z;					// 0.0 to 0.99999	- Used for visiblity check in ZBuffer (1.0 is not valid)
 	float rhw;					// 0.0 to 1.0		- reciprocal of homogeneous w - Used for perspective correct textures, fog and clipping
-	DWORD argb;					// Vertex color and alpha (alpha of 255 means solid, 0=transparent)
-	DWORD frgb;					// Specular color and fog
+	ULONG argb;					// Vertex color and alpha (alpha of 255 means solid, 0=transparent)
+	ULONG frgb;					// Specular color and fog
 	float u,v;					// Texture coordinates
-
 } gos_VERTEX;
+typedef gos_VERTEX *pgos_VERTEX;
 
 //
 // This vertex type is used for rendering with 2 textures at once, it is identical to the normal vertex structure, but with 2 u,v's
 //
-typedef struct
-{
+typedef struct _gos_VERTEX_2UV {
 	float x,y;					// Screen coords	- must be 0.0 to Environment.screenWidth/Height (no clipping occurs unless gos_State_Clipping is true)
 	float z;					// 0.0 to 0.99999	- Used for visiblity check in ZBuffer (1.0 is not valid)
 	float rhw;					// 0.0 to 1.0		- reciprocal of homogeneous w - Used for perspective correct textures, fog and clipping
-	DWORD argb;					// Vertex color and alpha (alpha of 255 means solid, 0=transparent)
-	DWORD frgb;					// Specular color and fog
+	ULONG argb;					// Vertex color and alpha (alpha of 255 means solid, 0=transparent)
+	ULONG frgb;					// Specular color and fog
 	float u1,v1;				// Texture coordinates
 	float u2,v2;				// Texture coordinates
-
 } gos_VERTEX_2UV;
+typedef gos_VERTEX_2UV *pgos_VERTEX_2UV;
 
 //
 // This vertex type is used for rendering with 3 textures at once, it is identical to the normal vertex structure, but with 3 u,v's
 // Expected use:  u1,v1 = base texture  u2,v2 = bump map  u3,v3 = environment map
 //
-typedef struct
-{
+typedef struct _gos_VERTEX_3UV {
 	float x,y;					// Screen coords	- must be 0.0 to Environment.screenWidth/Height (no clipping occurs unless gos_State_Clipping is true)
 	float z;					// 0.0 to 0.99999	- Used for visiblity check in ZBuffer (1.0 is not valid)
 	float rhw;					// 0.0 to 1.0		- reciprocal of homogeneous w - Used for perspective correct textures, fog and clipping
-	DWORD argb;					// Vertex color and alpha (alpha of 255 means solid, 0=transparent)
-	DWORD frgb;					// Specular color and fog
+	ULONG argb;					// Vertex color and alpha (alpha of 255 means solid, 0=transparent)
+	ULONG frgb;					// Specular color and fog
 	float u1,v1;				// Texture coordinates
 	float u2,v2;				// Texture coordinates
 	float u3,v3;				// Texture coordinates
 
 } gos_VERTEX_3UV;
+typedef gos_VERTEX_3UV *pgos_VERTEX_3UV;
 
 //
 // Setup a viewport, must be called before drawing
@@ -2089,7 +2005,7 @@ typedef struct
 //
 // Normal applications will fill the Z buffer with 1.0
 //
-void __stdcall gos_SetupViewport( bool FillZ, float ZBuffer, bool FillBG, DWORD BGColor, float top, float left, float bottom, float right, bool ClearStencil=0, DWORD StencilValue=0 );
+void __stdcall gos_SetupViewport( UCHAR FillZ, float ZBuffer, UCHAR FillBG, ULONG BGColor, float top, float left, float bottom, float right, UCHAR ClearStencil=0, ULONG StencilValue=0 );
 
 //
 // The values returned must be used to transform the x,y coords into the current
@@ -2108,33 +2024,33 @@ void __stdcall gos_GetViewport( float* pViewportMulX, float* pViewportMulY, floa
 // Draw points, pass a pointer to an array of gos_VERTEX's - every vertex is a new point
 //  (you must set the texture to 0 if you want to disable texture mapping on the points)
 //
-void __stdcall gos_DrawPoints( gos_VERTEX* Vertices, int NumVertices );
+MECH_IMPEXP HRESULT MECH_CALL gos_DrawPoints( pgos_VERTEX Vertices, int NumVertices );
 
 //
 // Draw lines, pass a pointer to an array of gos_VERTEX's - every two vertices is a new line
 //  (you must set the texture to 0 if you want to disable texture mapping on the points)
 //
-void __stdcall gos_DrawLines( gos_VERTEX* Vertices, int NumVertices );
+MECH_IMPEXP HRESULT MECH_CALL gos_DrawLines( pgos_VERTEX Vertices, int NumVertices );
 
 //
 // Draw triangles, pass a pointer to an array of gos_VERTEX's - every three vertices is a new triangle
 //
-void __stdcall gos_DrawTriangles( gos_VERTEX* Vertices, int NumVertices );
+MECH_IMPEXP HRESULT MECH_CALL gos_DrawTriangles( pgos_VERTEX Vertices, int NumVertices );
 
 //
 // Draws a strip, pass a pointer to an array of gos_VERTEX's - every vertex after the 2nd is a new triangle
 //
-void __stdcall gos_DrawStrips( gos_VERTEX* Vertices, int NumVertices );
+MECH_IMPEXP HRESULT MECH_CALL gos_DrawStrips( pgos_VERTEX Vertices, int NumVertices );
 
 //
 // Draws a fan, pass a pointer to an array of gos_VERTEX's - every vertex after the 2nd is a new triangle
 //
-void __stdcall gos_DrawFans( gos_VERTEX* Vertices, int NumVertices );
+MECH_IMPEXP HRESULT MECH_CALL gos_DrawFans(pgos_VERTEX Vertices, int NumVertices);
 
 //
 // Draw quads, pass a pointer to an array of gos_VERTEX's - every four vertices is a new quad
 //
-void __stdcall gos_DrawQuads( gos_VERTEX* Vertices, int NumVertices );
+MECH_IMPEXP HRESULT MECH_CALL gos_DrawQuads(pgos_VERTEX Vertices, int NumVertices);
 
 //
 // This API allows you to pass an array of indices and an array of vertices to be rendered.
@@ -2145,9 +2061,9 @@ void __stdcall gos_DrawQuads( gos_VERTEX* Vertices, int NumVertices );
 // The vertex colors in the array may be changed in some wireframe modes. Otherwise the data is
 // not altered.
 //
-void __stdcall gos_RenderIndexedArray( gos_VERTEX* pVertexArray, DWORD NumberVertices, WORD* lpwIndices, DWORD NumberIndices );
-void __stdcall gos_RenderIndexedArray( gos_VERTEX_2UV* pVertexArray, DWORD NumberVertices, WORD* lpwIndices, DWORD NumberIndices );
-void __stdcall gos_RenderIndexedArray( gos_VERTEX_3UV* pVertexArray, DWORD NumberVertices, WORD* lpwIndices, DWORD NumberIndices );
+MECH_IMPEXP HRESULT MECH_CALL gos_RenderIndexedArray1( pgos_VERTEX pVertexArray, ULONG NumberVertices, PUSHORT lpwIndices, ULONG NumberIndices );
+MECH_IMPEXP HRESULT MECH_CALL gos_RenderIndexedArray2( pgos_VERTEX_2UV pVertexArray, ULONG NumberVertices, PUSHORT lpwIndices, ULONG NumberIndices );
+MECH_IMPEXP HRESULT MECH_CALL gos_RenderIndexedArray3( pgos_VERTEX_3UV pVertexArray, ULONG NumberVertices, PUSHORT lpwIndices, ULONG NumberIndices );
 
 //
 // Set a renderstate
@@ -2159,8 +2075,8 @@ void __stdcall gos_SetRenderState( gos_RenderState RenderState, int Value );
 //
 // Save and restore all the current renderstate settings. These are saved on a linked list, so can be nested. If they are not all pop'ed by the end of update renderers, an error will be generated
 //
-void __stdcall gos_PushRenderStates();
-void __stdcall gos_PopRenderStates();
+void __stdcall gos_PushRenderStates(void);
+void __stdcall gos_PopRenderStates(void);
 
 
 
@@ -2203,9 +2119,9 @@ typedef struct
 typedef struct
 {
 	float x,y,z;
-	DWORD unused;			// This DWORD is unused and is here to match the D3DLVETEX type
-	DWORD argb;
-	DWORD frgb;
+	ULONG unused;			// This ULONG is unused and is here to match the D3DLVETEX type
+	ULONG argb;
+	ULONG frgb;
 	float u,v;
 
 } gosD3DLVERTEX;
@@ -2216,8 +2132,8 @@ typedef struct
 typedef struct
 {
 	float x,y,z;
-	DWORD argb;
-	DWORD frgb;
+	ULONG argb;
+	ULONG frgb;
 	float u1,v1, u2,v2;
 
 } gosD3DLVERTEX_2UV;
@@ -2252,8 +2168,7 @@ typedef struct
 //
 // Used to specify type of vertex when creating vertex buffer or rendering an array of vertices
 //
-typedef enum
-{
+typedef enum gosVERTEXTYPE {
 	VERTEX_gos_VERTEX=1,				// Old style untransformed and unlit vertex
 	VERTEX_gos_VERTEX_2UV,				// Old style untransformed and unlit vertex with TWO u,v coords
 	VERTEX_gosD3DLVERTEX,				// D3D transforms and clips by does not light
@@ -2263,7 +2178,6 @@ typedef enum
 	VERTEX_gosD3DBLENDVERTEX,			// D3D transforms, clips, blends and lights
 	VERTEX_gosD3DBLENDVERTEX_2UV,		// D3D transforms, clips, blends and lights with TWO u,v coords
 	VERTEX_gos_VERTEX_3UV,				// Old style untransformed and unlit vertex with TWO u,v coords
-
 } gosVERTEXTYPE;
 
 
@@ -2324,8 +2238,7 @@ typedef struct
 //
 // Used to specify type of light (Identical to D3DLIGHTTYPE)
 //
-typedef enum
-{
+typedef enum gosLIGHTTYPE {
 	LIGHT_POINT=1,
 	LIGHT_SPOT,
 	LIGHT_DIRECTIONAL,
@@ -2341,7 +2254,7 @@ typedef enum
 //
 // Light definition (Identical to D3DLIGHT7)
 //
-typedef struct
+typedef struct gosLIGHT
 {
     gosLIGHTTYPE	dltType;
     gosCOLOR		dcvDiffuse;
@@ -2363,25 +2276,21 @@ typedef struct
 //
 // Used to specify which matrix (Identical to D3DTRANSFORMSTATETYPE)
 //
-typedef enum
-{
+typedef enum gosTRANSFORMTYPE {
 	MATRIX_WORLD=1,
 	MATRIX_VIEW,
 	MATRIX_PROJECTION,
 	MATRIX_WORLD1,				// 2nd world matrix used in vertex blending
-
 } gosTRANSFORMTYPE;
 
 
 //
 // Used to specify type of primitive being rendered in gos_RenderIndexedArray and gos_RenderVertexBuffer
 //
-typedef enum
-{
+typedef enum gosPRIMITIVETYPE {
 	PRIMITIVE_POINTLIST=1,
 	PRIMITIVE_LINELIST=2,
 	PRIMITIVE_TRIANGLELIST=3,
-
 } gosPRIMITIVETYPE;
 
 
@@ -2389,7 +2298,7 @@ typedef enum
 //
 // Sets the region of screen that will be rendered to. (The default values set at the start of each frame are 0, 0, Environment.screenWidth, Environment.screenHeight)
 //
-void __stdcall gos_SetViewport( DWORD LeftX, DWORD RightX, DWORD Width, DWORD height, float MinZ=0.0f, float MaxZ=1.0f );
+void __stdcall gos_SetViewport( ULONG LeftX, ULONG RightX, ULONG Width, ULONG height, float MinZ=0.0f, float MaxZ=1.0f );
 
 //
 // Sets the WORLD/VIEW or PROJECTION matrix
@@ -2404,12 +2313,12 @@ void __stdcall gos_MultiplyTransform( gosTRANSFORMTYPE TransformType, gosMATRIX*
 //
 // Sets the parameters of a light (LightNumber can be any number)
 //
-void __stdcall gos_SetLight( DWORD LightNumber, gosLIGHT* LightData );
+void __stdcall gos_SetLight( ULONG LightNumber, gosLIGHT* LightData );
 
 //
 // Enables / Disables a light (Maximum of gos_GetMachineInformation( gos_Info_GetMaximumActiveLights ) lights enabled at once)
 //
-void __stdcall gos_LightEnable( DWORD LightNumber, bool Enable );
+void __stdcall gos_LightEnable( ULONG LightNumber, UCHAR Enable );
 
 //
 // Sets the parameters of the current material
@@ -2421,7 +2330,7 @@ void __stdcall gos_SetMaterial( gosMATERIAL* MaterialData );
 //
 // NOTE: When PrimitiveType is a POINTLIST the lpwIndices and NumberIndices are ignored, it is treated as a list of points
 //
-void __stdcall gos_RenderIndexedArray( void* pVertexArray, DWORD NumberVertices, WORD* lpwIndices, DWORD NumberIndices, gosVERTEXTYPE VertexType, gosPRIMITIVETYPE PrimitiveType=PRIMITIVE_TRIANGLELIST );
+void __stdcall gos_RenderIndexedArray( PVOID pVertexArray, ULONG NumberVertices, PUSHORT lpwIndices, ULONG NumberIndices, gosVERTEXTYPE VertexType, gosPRIMITIVETYPE PrimitiveType=PRIMITIVE_TRIANGLELIST );
 
 
 
@@ -2435,14 +2344,14 @@ void __stdcall gos_RenderIndexedArray( void* pVertexArray, DWORD NumberVertices,
 // If the Optimized flag is set, when the Vertex Buffer is locked and unlocked the first time it will be optimized. It cannot be locked again after this.
 // Only valid in game logic - not valid in update renderer.
 //
-DWORD __stdcall gos_CreateVertexBuffer( DWORD NumberVertices, bool Optimized, gosVERTEXTYPE VertexType );
+ULONG __stdcall gos_CreateVertexBuffer( ULONG NumberVertices, UCHAR Optimized, gosVERTEXTYPE VertexType );
 
 //
 // Deletes the vertex buffer
 //
 // Only valid in game logic - not valid in update renderer.
 //
-void __stdcall gos_DeleteVertexBuffer( DWORD VertexBufferHandle );
+void __stdcall gos_DeleteVertexBuffer( ULONG VertexBufferHandle );
 
 //
 // Locks a vertex buffer and returns a pointer to the base address
@@ -2451,14 +2360,14 @@ void __stdcall gos_DeleteVertexBuffer( DWORD VertexBufferHandle );
 // If the NoOverwrite flag is true, D3D will assume you are only ADDING new vertices, D3D may still be rendering old vertices in the buffer.
 // Valid in game logic or the update renderer
 //
-void* __stdcall gos_LockVertexBuffer( DWORD VertexBufferHandle, bool DiscardContents, bool NoOverwrite );
+PVOID __stdcall gos_LockVertexBuffer( ULONG VertexBufferHandle, UCHAR DiscardContents, UCHAR NoOverwrite );
 
 //
 // Unlocks a vertex buffer
 //
 // Valid in game logic or the update renderer
 //
-void __stdcall gos_UnLockVertexBuffer( DWORD VertexBufferHandle );
+void __stdcall gos_UnLockVertexBuffer( ULONG VertexBufferHandle );
 
 //
 // Application should check this at the start of a frame. If the user has changed modes or video cards, this will be true.
@@ -2467,14 +2376,14 @@ void __stdcall gos_UnLockVertexBuffer( DWORD VertexBufferHandle );
 // If you pass no parameter, or 0 it will tell you if ALL vertex buffers have been lost since the last frame.
 // If you pass a specific handle to a vertex buffer it will tell you if that vertex buffer is currently lost (so you only have to restore vertex buffers when you need them)
 //
-bool __stdcall gos_VertexBuffersLost( DWORD VertexBufferHandle=0 );
+UCHAR __stdcall gos_VertexBuffersLost( ULONG VertexBufferHandle=0 );
 
 //
 // Renders a vertex buffer of untransformed vertices
 //
 // NOTE: When PrimitiveType is a POINTLIST the lpwIndices and NumberIndices are ignored, it is treated as a list of points
 //
-void __stdcall gos_RenderVertexBuffer( DWORD VertexBufferHandle, DWORD StartVertex, DWORD NumberVertices, WORD* lpwIndices, DWORD NumberIndices, gosPRIMITIVETYPE PrimitiveType=PRIMITIVE_TRIANGLELIST );
+void __stdcall gos_RenderVertexBuffer( ULONG VertexBufferHandle, ULONG StartVertex, ULONG NumberVertices, PUSHORT lpwIndices, ULONG NumberIndices, gosPRIMITIVETYPE PrimitiveType=PRIMITIVE_TRIANGLELIST );
 
 
 
@@ -2515,14 +2424,14 @@ void __stdcall gos_RenderVertexBuffer( DWORD VertexBufferHandle, DWORD StartVert
 //
 // Renderer is 0 for hardware or 3 for Blade
 //
-void __stdcall gos_SetScreenMode( DWORD Width, DWORD Height, DWORD bitDepth=16, DWORD Device=0, bool disableZBuffer=0, bool AntiAlias=0, bool RenderToVram=0, bool GotoFullScreen=0, int DirtyRectangle=0, bool GotoWindowMode=0, bool EnableStencil=0, DWORD Renderer=0 );
+void __stdcall gos_SetScreenMode( ULONG Width, ULONG Height, ULONG bitDepth=16, ULONG Device=0, UCHAR disableZBuffer=0, UCHAR AntiAlias=0, UCHAR RenderToVram=0, UCHAR GotoFullScreen=0, int DirtyRectangle=0, UCHAR GotoWindowMode=0, UCHAR EnableStencil=0, ULONG Renderer=0 );
 
 //
 // This API sets the current gamma correction value. The default value is 1.0 (no correction applied). All color values are effected by (value/255 ^ (1.0/gamma)).
 //
 void __stdcall gos_SetGammaValue( float Gamma );					// Default 1.0
-void __stdcall gos_SetBrightnessValue( DWORD Brightness );		// Value range 0-10,000, default 750 (See DirectX docs)
-void __stdcall gos_SetContrastValue( DWORD Contrast );			// Value range 0-20,000, default 10,000 (See DirectX docs)
+void __stdcall gos_SetBrightnessValue( ULONG Brightness );		// Value range 0-10,000, default 750 (See DirectX docs)
+void __stdcall gos_SetContrastValue( ULONG Contrast );			// Value range 0-20,000, default 10,000 (See DirectX docs)
 
 
 //
@@ -2530,7 +2439,7 @@ void __stdcall gos_SetContrastValue( DWORD Contrast );			// Value range 0-20,000
 //  (if you requested the Z buffer to be saved, it will also be copied).
 //  You should call this when you have drawn the initial background scene.
 //
-void __stdcall gosDirtyRectangleSaveTarget();
+void __stdcall gosDirtyRectangleSaveTarget(void);
 
 //
 // Specifies a region that has been rendered to on the back buffer.
@@ -2541,7 +2450,7 @@ void __stdcall gosDirtyRectangleSaveTarget();
 //  will be completly restored from the copy of the back buffer. This may be slower if the
 //  copy is in system memory, but at least all the debugger functions should still operate as normal.
 //
-void __stdcall gosDirtyRectangeRestoreArea( DWORD Left, DWORD Top, DWORD Right, DWORD Bottom );
+void __stdcall gosDirtyRectangeRestoreArea( ULONG Left, ULONG Top, ULONG Right, ULONG Bottom );
 
 //
 // The application should call this API at the start of UpdateRenderers.
@@ -2551,7 +2460,7 @@ void __stdcall gosDirtyRectangeRestoreArea( DWORD Left, DWORD Top, DWORD Right,
 //  and it is free to continue rendering. On some hardware, where it is not possible to save/restore
 //  the back buffer this may return true every frame.
 //
-bool __stdcall gosDirtyRectangeLostTarget();
+UCHAR __stdcall gosDirtyRectangeLostTarget(void);
 
 
 
@@ -2592,7 +2501,7 @@ typedef enum gos_TextureHints
 	gosHint_DisableMipmap=1,		// Do not mipmap this texture (HUD textures, fonts, animating textures maybe? etc...)
 	gosHint_AGPMemory=2,			// Store in AGP memory if possible (allows processor and video card fast access, not as fast rendering as VideoMemory though)
 	gosHint_VideoMemory=4,			// Store in "Local" memory on the video card, this is the fastest for the card to texture, but very slow for the processor to page or animate
-	gosHint_ReloadFromDisk=8,		// GameOS will not store a DWORD copy of the texture, it will reload it from disk on mode changes. (You cannot lock these textures)
+	gosHint_ReloadFromDisk=8,		// GameOS will not store a ULONG copy of the texture, it will reload it from disk on mode changes. (You cannot lock these textures)
 	gosHint_PageLast=16,			// Frequently used textures should have this set. These textures will be paged ONLY if there are no other HighPriority texture that could be paged
 	gosHint_PageFirst=32,			// Rarely used textures should have this set. These will be the first textures paged if paging needs to occur.
 	gosHint_DontShrink=64,			// GOS may shrink textures on a low memory card - this flag will prevent it. (ie: for fonts or HUD textures)
@@ -2612,14 +2521,14 @@ typedef enum gos_TextureHints
 //
 typedef struct
 {
-	DWORD*				pTexture;
-	DWORD				Width;				// In pixels
-	DWORD				Height;				// In pixels
-	DWORD				Pitch;				// In DWORDS (so can be added to pTexture to move down a line)
+	PULONG				pTexture;
+	ULONG				Width;				// In pixels
+	ULONG				Height;				// In pixels
+	ULONG				Pitch;				// In ULONGS (so can be added to pTexture to move down a line)
 	gos_TextureFormat	Type;				// Internal format of texture (Solid, Keyed or Alpha) - Useful when you have used DETECT	
 } TEXTUREPTR;
 
-typedef void (__stdcall *gos_RebuildFunction)( DWORD, void *);
+typedef void (__stdcall *gos_RebuildFunction)( ULONG, void *);
 
 //
 // Load a texture, returns a texture handle that can be passed as a renderstate
@@ -2634,7 +2543,7 @@ typedef void (__stdcall *gos_RebuildFunction)( DWORD, void *);
 // Hints should be set to any combination of gos_TextureHints or 0 is a good default.
 //
 //
-DWORD __stdcall gos_NewTextureFromFile( gos_TextureFormat Format, const char* FileName, DWORD Hints=0, gos_RebuildFunction pFunc=0, void *pInstance=0 );
+ULONG __stdcall gos_NewTextureFromFile( gos_TextureFormat Format, PCSTR FileName, ULONG Hints=0, gos_RebuildFunction pFunc=0, void *pInstance=0 );
 
 //
 // Loads a texture from a memory image, returns a texture handle
@@ -2650,7 +2559,7 @@ DWORD __stdcall gos_NewTextureFromFile( gos_TextureFormat Format, const char* Fi
 //
 // Hints should be set to any combination of gos_TextureHints or 0 is a good default.
 //
-DWORD __stdcall gos_NewTextureFromMemory( gos_TextureFormat Format, const char* FileName, BYTE* pBitmap, DWORD Size, DWORD Hints=0, gos_RebuildFunction pFunc=0, void *pInstance=0 );
+ULONG __stdcall gos_NewTextureFromMemory( gos_TextureFormat Format, PCSTR FileName, PUCHAR pBitmap, ULONG Size, ULONG Hints=0, gos_RebuildFunction pFunc=0, void *pInstance=0 );
 
 #define RECT_TEX(width,height) (((height)<<16)|(width))
 
@@ -2674,12 +2583,12 @@ DWORD __stdcall gos_NewTextureFromMemory( gos_TextureFormat Format, const char*
 // For square textures, place the width in HeightWidth
 // For Rectangular textures, use RECT_TEX(width,height) to pack the width and height values
 //
-DWORD __stdcall gos_NewEmptyTexture( gos_TextureFormat Format, const char* Name, DWORD HeightWidth, DWORD Hints=0, gos_RebuildFunction pFunc=0, void *pInstance=0 );
+ULONG __stdcall gos_NewEmptyTexture( gos_TextureFormat Format, PCSTR Name, ULONG HeightWidth, ULONG Hints=0, gos_RebuildFunction pFunc=0, void *pInstance=0 );
 
 //
 // Destroy a texture handle (unload from memory)
 //
-void __stdcall gos_DestroyTexture( DWORD Handle );
+void __stdcall gos_DestroyTexture( ULONG Handle );
 
 //
 // Locks a texture so you can modify it
@@ -2690,17 +2599,17 @@ void __stdcall gos_DestroyTexture( DWORD Handle );
 //
 // Note that GameOS returns a pointer to an 8888 version of every texture. When you unlock it, it will be format converted and reuploaded in the current pixel format (555/4444 etc...)
 //
-void __stdcall gos_LockTexture( DWORD Handle, DWORD MipMapSize, bool ReadOnly, TEXTUREPTR* TextureInfo );
+void __stdcall gos_LockTexture( ULONG Handle, ULONG MipMapSize, UCHAR ReadOnly, TEXTUREPTR* TextureInfo );
 
 //
 // Unlocks and updates a texture (may have to build and upload mipmaps)
 //
-void __stdcall gos_UnLockTexture( DWORD Handle );
+void __stdcall gos_UnLockTexture( ULONG Handle );
 
 //
 // Converts from 32bpp source to subrect of n-bpp dest, bypassing intermediate 32bpp buffer
 //
-void __stdcall gos_ConvertTextureRect( DWORD Handle, DWORD DestLeft, DWORD DestTop, DWORD *Source, DWORD SourcePitch, DWORD Width, DWORD Height );
+void __stdcall gos_ConvertTextureRect( ULONG Handle, ULONG DestLeft, ULONG DestTop, PULONG Source, ULONG SourcePitch, ULONG Width, ULONG Height );
 
 
 //
@@ -2708,15 +2617,15 @@ void __stdcall gos_ConvertTextureRect( DWORD Handle, DWORD DestLeft, DWORD DestT
 //
 // Returns false if not enough texture memory (reduce heap sizes)
 //
-bool __stdcall gos_RecreateTextureHeaps();
+UCHAR __stdcall gos_RecreateTextureHeaps(void);
 
 //
 // Preloads a texture into texture memory - this occurs after the endscene/blit. So may occur in parallel with the next game logic loop.
 //
-void __stdcall gos_PreloadTexture( DWORD Handle );
+void __stdcall gos_PreloadTexture( ULONG Handle );
 
-void __stdcall gos_SetTextureName( DWORD Handle, const char *name );
-const char* __stdcall gos_GetTextureName( DWORD Handle );
+void __stdcall gos_SetTextureName( ULONG Handle, PCSTR name );
+PCSTR __stdcall gos_GetTextureName( ULONG Handle );
 
 //
 // Render to a texture using blade.
@@ -2732,18 +2641,18 @@ const char* __stdcall gos_GetTextureName( DWORD Handle );
 //   . A texture that has been already used in the current frame cannot be rendered too.
 //   . No renderstates are allowed between these two calls.
 //
-void __stdcall gos_StartRenderToTexture( DWORD Handle );
+void __stdcall gos_StartRenderToTexture( ULONG Handle );
 //
 // When rendering to a texture is complete, this API must be called to process it.
 //
 // The 'ClearBorder' parameter will cause GameOS to clear a single pixel border around the texture. This allows the texture to be used in CLAMP mode with no artifacts.
 //
-void __stdcall gos_EndRenderToTexture( bool ClearBorder=0 );
+void __stdcall gos_EndRenderToTexture( UCHAR ClearBorder=0 );
 
 //
 // Returns true if the TGA has a valid header.
 //
-bool __stdcall gos_CheckValidTGA( BYTE *Data, DWORD DataSize );
+UCHAR __stdcall gos_CheckValidTGA( PUCHAR Data, ULONG DataSize );
 
 
 
@@ -2769,12 +2678,13 @@ bool __stdcall gos_CheckValidTGA( BYTE *Data, DWORD DataSize );
 // Statistics API - adds variables to a list that can be graphed or watched during gameplay
 //
 //
-enum gosType { gos_DWORD=1,gos_WORD,gos_BYTE,gos_int,gos_short,gos_char,gos_float,gos_double,gos_int64,gos_timedata,gos_cycledata };
+typedef enum gosType { 
+	gos_DWORD=1,gos_WORD,gos_BYTE,gos_int,gos_short,gos_char,gos_float,gos_double,gos_int64,gos_timedata,gos_cycledata 
+} gosType;
 ///
 // Flags used in AddStatistic
 //
-typedef enum StatFlags
-{
+typedef enum StatFlags {
 	Stat_AutoReset=1,				// After statistics read, zero memory variable
 	Stat_Graph=2,					// Enable graphing of this variable
 	Stat_1DP=4,						// Show one decimal place
@@ -2782,7 +2692,8 @@ typedef enum StatFlags
 	Stat_3DP=16,					// Show three decimal places
 	Stat_Total=32,					// Just display total - no minimum, maximum, average
 	Stat_GraphMax=64,				// The graph has a fixed maximum, which is passed as the initial value
-};
+} StatFlags;
+
 //
 // Adds a value to the list of variables being watched each frame
 //
@@ -2800,17 +2711,17 @@ typedef enum StatFlags
 //					It will be displayed as processor information. Eventually cycles, cache, bus etc..
 //
 //
-void __stdcall AddStatistic( char* Name, char* TypeName, gosType Type, void* Value, DWORD Flags );
+void __stdcall AddStatistic( PSTR Name, PSTR TypeName, gosType Type, PVOID Value, ULONG Flags );
 //
 // This command adds text to the statistic display and can be used for blank lines (eg: " ") or titles (eg: "Ai Logic variables")
 //
-void __stdcall StatisticFormat( char* String );
+void __stdcall StatisticFormat( PSTR String );
 
 //
 // This API will return the value for a statistic. If the statistic is a timer the value returned will always be in milliseconds, never percentage.
 // The 'Frame' parameter can be used to return old data from previous frames. The values 0 to -511 are valid.
 //
-float __stdcall gos_ReturnStatistic( const char* Name, int Frame=0 );
+float __stdcall gos_ReturnStatistic( PCSTR Name, int Frame=0 );
 
 
 
@@ -2823,7 +2734,7 @@ void __stdcall EndCycleTiming( struct gos_CycleData* Time );
 //
 // This API is only to be used with a 'gos_timedata' AddStatistic. When called will return the current time in cycles.
 //
-__int64 __stdcall GetCycles();
+__int64 __stdcall GetCycles(void);
 
 //
 // Adds a menu item to the ^Break debugger.
@@ -2845,9 +2756,8 @@ __int64 __stdcall GetCycles();
 //
 // Note, these enums may be expanded in the future, the application should return 0 to any other unknown Menu requests.
 //
-typedef enum
-{
-	gosMenu_Name,			// The name of the menu should be returned ie: return (DWORD)"Tank Alpha";  (If 0 is returned the default name the menu was created with will be printed)
+typedef enum _gosMenuDebugger_const {
+	gosMenu_Name,			// The name of the menu should be returned ie: return (ULONG)"Tank Alpha";  (If 0 is returned the default name the menu was created with will be printed)
 	gosMenu_CheckMark,		// True or False should be returned if the menu has a check mark next to it
 	gosMenu_Greyed,			// True or False should be returned if the menu is greyed out
 	gosMenu_Activated,		// This will be called when the menu is activated. If it returns true, the menu will stay open.
@@ -2855,12 +2765,12 @@ typedef enum
 //
 //
 //
-void __stdcall AddDebuggerMenuItem( char* Name, bool(__stdcall *CheckMark)(), void(__stdcall *Activated)(), bool(__stdcall *Greyed)()=0, DWORD(__stdcall *Callback)( char* Name, DWORD MenuFunction)=0 );
+void __stdcall AddDebuggerMenuItem( PSTR Name, UCHAR(__stdcall *CheckMark)(), void(__stdcall *Activated)(), UCHAR(__stdcall *Greyed)()=0, ULONG(__stdcall *Callback)( PSTR Name, ULONG MenuFunction)=0 );
 
 //
 // Deletes a debugger menu item
 //
-void __stdcall DelDebuggerMenuItem( char* Name );
+void __stdcall DelDebuggerMenuItem( PSTR Name );
 
 //
 // This API can be used to query the status of the CheckMark, if the menu is Greyed or be used to trigger the menu as if the user had selected it.
@@ -2869,7 +2779,7 @@ void __stdcall DelDebuggerMenuItem( char* Name );
 //  if called with gosMenu_Name as the function it will return true or false if the menu exists. Other functions will be ignored if the menu does not exist.
 //  Note Debugger\\, Rasterizer\\ and Libraries\\ must appear at the start of the name, but for application menu items, no app name is needed.
 //
-DWORD __stdcall CallDebuggerMenuItem( const char* Name, DWORD MenuFunction );
+ULONG __stdcall CallDebuggerMenuItem( PCSTR Name, ULONG MenuFunction );
 
 //
 // This function enables or disables the math exception handler
@@ -2881,8 +2791,8 @@ DWORD __stdcall CallDebuggerMenuItem( const char* Name, DWORD MenuFunction );
 //
 // You can get the current states (for pushing and poping for example) with GetMathExceptions.
 //
-void __stdcall gos_MathExceptions( bool EnableExceptions, bool SinglePrecision );
-void __stdcall gos_GetMathExceptions( bool* Exceptions, bool* SinglePrecision );
+void __stdcall gos_MathExceptions( UCHAR EnableExceptions, UCHAR SinglePrecision );
+void __stdcall gos_GetMathExceptions( UCHAR* Exceptions, UCHAR* SinglePrecision );
 
 
 
@@ -2908,7 +2818,7 @@ typedef enum gosSetting
 	gos_Set_MouseCursor,					// 0=Disable cursor (default), 1=Enable cursor (Hardware if possible)
 	gos_Set_SkipRender,						// When this is set to 1 there will be no rendering for the current frame. Can be used to skip frames when behind.
 	gos_Set_NextGameLogicTime,				// Value is the number of Milliseconds between the last GameLogic and the next. GameOS will 'spin' until this time is met.
-	gos_Set_TriggerBrowser,					// Value is a (char*) pointing to an address ie: "http:\\microsoft.com"
+	gos_Set_TriggerBrowser,					// Value is a (PSTR) pointing to an address ie: "http:\\microsoft.com"
 	gos_Set_LoseFocusBehavior,				// 0=Slow to 10Hz (default), 1=Pause game, 2=Run at full speed, 3=run at full speed, max 60 Hz
 	gos_Set_IgnoreMaxUV,					// 1=Disable the maximum U,V message assert. This is for apps in development that have u,v's larger than the card can handle
 	gos_Set_IgnoreVSYNC,					// When 1 and in full sreen mode, GameOS will use BLT not FLIP. This means the game is not limited by the refresh rate.
@@ -2922,90 +2832,89 @@ typedef enum gosSetting
 //
 //
 //
-DWORD __stdcall gos_EnableSetting( gosSetting Setting, DWORD Value );
+ULONG __stdcall gos_EnableSetting( gosSetting Setting, ULONG Value );
 
 
 
 
 
-typedef enum MachineInfo
-{
-	gos_Info_HasAGPAvailable,				// (DWORD)  FALSE when no AGP memory available (assume a low end card)
-	gos_Info_HasGuardBandClipping,			// (DWORD)  TRUE when card be passed vertices from at least -2047,-2047 to 2047,2047 without errors
-	gos_Info_TextureOffset,					// (DWORD)  TRUE when a -0.625 texel offset is being applied to u,v coords to make text readable - Only the Riva128 requires this. (Normally 0.4375 is subtracted from the PIXEL x,y coords)
-	gos_Info_TextureSize,					// (DWORD)  Returns currently selected texture width/height in pixels (or 1 for no texture)
-
-	gos_Info_GetProcessorInfo,				// (char*)  Returns a user readable string that shows the processor (ie: Intel Pentium III)
-	gos_Info_GetNumberProcessors,			// (DWORD)	Returns the number of processors in the system
-	gos_Info_GetProcessorSpeed,				// (DWORD)	Returns the processor speed in MHz, ie: 400  (This is approximate, never check for ==400 or >200 - or anything similar. use >180 for 200Mhz or above for example)
-
-	gos_Info_GetOSInfo,						// (char*)	Returns a user readable string that shows the operating system (ie: Windows 98 GOLD)
-	gos_Info_GetMemorySize,					// (DWORD)  Returns the amount of memory the machine has in bytes
-	gos_Info_GetVirtualMemorySize,			// (DWORD)  Returns the amount of virutal memory the machine has in bytes
-	gos_Info_NumberDevices,					// (DWORD)  Number of devices GameOS can render to (always at least 1)
-	gos_Info_GetDeviceName,					// (char*)  Returns the name of the device specified in Param1 (Riva TNT, Voodoo 1 etc...)
-	gos_Info_GetDeviceVendorID,				// (DWORD)  Returns the vendor of the device specified in Param1 (0x121a=3Dfx for example - See Videocard.cpp for complete list)
-	gos_Info_GetDeviceDeviceID,				// (DWORD)  Returns the DeviceID of the device specified in Param1 (2=Voodoo2 for example - See Videocard.cpp for complete list)
-	gos_Info_GetDeviceVideoMemory,			// (DWORD)	Returns the amount of video memory available (for front/back/z buffers etc..) for device specified in Param1
-	gos_Info_GetDeviceLocalMemory,			// (DWORD)	Returns the amount of local video memory available (may be the same as above) for device specified in Param1
-	gos_Info_GetDeviceAGPMemory,			// (DWORD)	Returns the amount of AGP video memory available (may be 0 on non-agp cards) for device specified in Param1
-	gos_Info_GetDeviceDriverVersionHi,		// (DWORD)  Returns the Hi DWORD version number of the Device specified in param 0
-	gos_Info_GetDeviceDriverVersionLo,		// (DWORD)  Returns the Lo DWORD version number of the Device specified in param 0
-	gos_Info_NumberValidModes,				// (DWORD)	Returns the number of valid modes for device Param1, bitdepth Param2 (16 or 32 only)
-	gos_Info_GetValidMode,					// (DWORD)	Returns a DWORD containing HIWORD=Width, LOWORD=Height of device 'Param1' for bitdepth 'Param2', mode number Param3
-	gos_Info_ValidMode,						// (DWORD)  Param1=Device, Param2=Width, Param3=Height. Returns true if card supports mode (ie: 1024*768)
-	gos_Info_CanDeviceHardwareGamma,		// (DWORD)	Returns true if the gamma of the display will be adjusted using HARDWARE or SOFTWARE (software is much slower)
-	gos_Info_CanDeviceAntiAlias,			// (DWORD)  Returns true if the device specified in Param1 can render antialiased
-	gos_Info_CanDeviceRender32Bit,			// (DWORD)  Returns true if the device specified in Param1 can render in 32 bit mode
-	gos_Info_CanDeviceRenderStencil,		// (DWORD)  Returns 1 if the device specified in Param1 can render with a stencil buffer, 2 if the device requires 32 bit mode before stencils work
-
-	gos_Info_CanMultitextureLightMap,		// (DWORD)  TRUE when single pass light mapping is available
-	gos_Info_CanMultitextureSpecularMap,	// (DWORD)  TRUE when single pass specular mapping is available
-	gos_Info_CanMultitextureDetail,			// (DWORD)  TRUE when single pass detail texturing is available
-
-	gos_Info_CanAlphaOneOne,				// (DWORD)	TRUE when the card can support Alpha ONE:ONE blending
-	gos_Info_CanAlphaTest,					// (DWORD)	TRUE when the card can support Alpha testing (GameOS will enable AlphaInvAlpha blending)
-	gos_Info_CanClampTextures,				// (DWORD)	TRUE when texture address mode CLAMP is available (GameOS will default to wrap)
-	gos_Info_CanModulateAlpha,				// (DWORD)	TRUE when ModulateAlpha is a supported mode (GameOS will default to Modulate)
-	gos_Info_CanSpecular,					// (DWORD)	TRUE when specular is supported (GameOS will ignore all specular otherwise)
-
-	gos_Info_GetDoubleClickTime,			// (DWORD)  Number of milliseconds between mouse clicks
-
-	gos_Info_GetMaximumUVSize,				// (DWORD)  Returns the maximum U,V size for the texture size passed as Param1 (if 0 is returned, there is no maximum)
-	gos_Info_IsMouseInSideWindow,			// (DWORD)  Returns 0 when the windows mouse is OVER the game window, or in full screen mode. Otherwise returns the absolute number of pixels away from the window the mouse is.
-
-	gos_Info_GetPixelColor,					// (DWORD)	Returns a 32 bit ARGB value for the pixel at screen location Param1=x, Param2=y. Param3=0 for back buffer, 1 for CopyBuffer (Dirty Rectangle mode). This API only valid during GameLogic or before SetupViewPort.
-
-	gos_Info_CanHardwareTandL,				// (DWORD)	TRUE when current mode is using hardware T&L
-	gos_Info_GetMaximumActiveLights,		// (DWORD)	Maximum number of active lights allowed in current mode (Can be -1 for infinite)
-	gos_Info_GetVertexBlendMatrices,		// (DWORD)  Returns 0 or 1 currently. The is the maximum number of vertex blend weights the hardware can blend.
-
-	gos_Info_GetApplicationStatus,			// (DWORD)  Bit 0 is true when the app is active, Bit 1 is true when the app has keyboard focus, Bit 2 is true when no rendering can occur (ie: Control Alt Delete Pressed)
-	gos_Info_GetDesktopResolution,			// (DWORD)	Get the resolution of the desktop (high word is vertical, low word is horizontal)
-	gos_Info_GetDesktopBitDepth,			// (DWORD)	Get the bitdepth of the desktop
-
-	gos_Info_GetIMEStatus,					// (DWORD)  Bit 0 is true when the IME is open.
-	gos_Info_GetKeyboardLayout,				// (DWORD)	Returns the current users keyboard layout from windows
-
-	gos_Info_GetMaximumTextureWidth,		// (DWORD)  Maximum width in texels of a texture or mipmap level.
-	gos_Info_GetMaximumTextureHeight,		// (DWORD)  Maximum height in texels of a texture or mipmap level.
-
-	gos_Info_CanBumpEnvMap,					// (DWORD)	TRUE when current mode supports bump environment maps
-	gos_Info_CanBumpDotMap,					// (DWORD)  Returns 1 if the current mode supports normal maps (dotproduct3)
-
-	gos_Info_HardwareGammaControl,			// (DWORD)	TRUE if full screen and hardware gamma control possible. Otherwise slower software gamma emulation is used
-	gos_Info_HardwareBrightnessControl,		// (DWORD)	TRUE if full screen and hardware brightness control possible. Otherwise invalid
-	gos_Info_HardwareContrastControl,		// (DWORD)	TRUE if full screen and hardware brightness control possible. Otherwise invalid
-
-	gos_Info_UsingHardwareRenderer,			// (DWORD)	TRUE when using a hardware renderer, 0=Blade. (Environment.renderer may have not been able to support hardware)
-
-	gos_Info_GetIMECaretStatus,				// (DWORD)  TRUE if an edit box should show its caret. When it's FALSE, an edit box shouldn't display caret.
-};
+typedef enum MachineInfo {
+	gos_Info_HasAGPAvailable,				// (ULONG)  FALSE when no AGP memory available (assume a low end card)
+	gos_Info_HasGuardBandClipping,			// (ULONG)  TRUE when card be passed vertices from at least -2047,-2047 to 2047,2047 without errors
+	gos_Info_TextureOffset,					// (ULONG)  TRUE when a -0.625 texel offset is being applied to u,v coords to make text readable - Only the Riva128 requires this. (Normally 0.4375 is subtracted from the PIXEL x,y coords)
+	gos_Info_TextureSize,					// (ULONG)  Returns currently selected texture width/height in pixels (or 1 for no texture)
+
+	gos_Info_GetProcessorInfo,				// (PSTR)  Returns a user readable string that shows the processor (ie: Intel Pentium III)
+	gos_Info_GetNumberProcessors,			// (ULONG)	Returns the number of processors in the system
+	gos_Info_GetProcessorSpeed,				// (ULONG)	Returns the processor speed in MHz, ie: 400  (This is approximate, never check for ==400 or >200 - or anything similar. use >180 for 200Mhz or above for example)
+
+	gos_Info_GetOSInfo,						// (PSTR)	Returns a user readable string that shows the operating system (ie: Windows 98 GOLD)
+	gos_Info_GetMemorySize,					// (ULONG)  Returns the amount of memory the machine has in bytes
+	gos_Info_GetVirtualMemorySize,			// (ULONG)  Returns the amount of virutal memory the machine has in bytes
+	gos_Info_NumberDevices,					// (ULONG)  Number of devices GameOS can render to (always at least 1)
+	gos_Info_GetDeviceName,					// (PSTR)  Returns the name of the device specified in Param1 (Riva TNT, Voodoo 1 etc...)
+	gos_Info_GetDeviceVendorID,				// (ULONG)  Returns the vendor of the device specified in Param1 (0x121a=3Dfx for example - See Videocard.cpp for complete list)
+	gos_Info_GetDeviceDeviceID,				// (ULONG)  Returns the DeviceID of the device specified in Param1 (2=Voodoo2 for example - See Videocard.cpp for complete list)
+	gos_Info_GetDeviceVideoMemory,			// (ULONG)	Returns the amount of video memory available (for front/back/z buffers etc..) for device specified in Param1
+	gos_Info_GetDeviceLocalMemory,			// (ULONG)	Returns the amount of local video memory available (may be the same as above) for device specified in Param1
+	gos_Info_GetDeviceAGPMemory,			// (ULONG)	Returns the amount of AGP video memory available (may be 0 on non-agp cards) for device specified in Param1
+	gos_Info_GetDeviceDriverVersionHi,		// (ULONG)  Returns the Hi ULONG version number of the Device specified in param 0
+	gos_Info_GetDeviceDriverVersionLo,		// (ULONG)  Returns the Lo ULONG version number of the Device specified in param 0
+	gos_Info_NumberValidModes,				// (ULONG)	Returns the number of valid modes for device Param1, bitdepth Param2 (16 or 32 only)
+	gos_Info_GetValidMode,					// (ULONG)	Returns a ULONG containing HIWORD=Width, LOWORD=Height of device 'Param1' for bitdepth 'Param2', mode number Param3
+	gos_Info_ValidMode,						// (ULONG)  Param1=Device, Param2=Width, Param3=Height. Returns true if card supports mode (ie: 1024*768)
+	gos_Info_CanDeviceHardwareGamma,		// (ULONG)	Returns true if the gamma of the display will be adjusted using HARDWARE or SOFTWARE (software is much slower)
+	gos_Info_CanDeviceAntiAlias,			// (ULONG)  Returns true if the device specified in Param1 can render antialiased
+	gos_Info_CanDeviceRender32Bit,			// (ULONG)  Returns true if the device specified in Param1 can render in 32 bit mode
+	gos_Info_CanDeviceRenderStencil,		// (ULONG)  Returns 1 if the device specified in Param1 can render with a stencil buffer, 2 if the device requires 32 bit mode before stencils work
+
+	gos_Info_CanMultitextureLightMap,		// (ULONG)  TRUE when single pass light mapping is available
+	gos_Info_CanMultitextureSpecularMap,	// (ULONG)  TRUE when single pass specular mapping is available
+	gos_Info_CanMultitextureDetail,			// (ULONG)  TRUE when single pass detail texturing is available
+
+	gos_Info_CanAlphaOneOne,				// (ULONG)	TRUE when the card can support Alpha ONE:ONE blending
+	gos_Info_CanAlphaTest,					// (ULONG)	TRUE when the card can support Alpha testing (GameOS will enable AlphaInvAlpha blending)
+	gos_Info_CanClampTextures,				// (ULONG)	TRUE when texture address mode CLAMP is available (GameOS will default to wrap)
+	gos_Info_CanModulateAlpha,				// (ULONG)	TRUE when ModulateAlpha is a supported mode (GameOS will default to Modulate)
+	gos_Info_CanSpecular,					// (ULONG)	TRUE when specular is supported (GameOS will ignore all specular otherwise)
+
+	gos_Info_GetDoubleClickTime,			// (ULONG)  Number of milliseconds between mouse clicks
+
+	gos_Info_GetMaximumUVSize,				// (ULONG)  Returns the maximum U,V size for the texture size passed as Param1 (if 0 is returned, there is no maximum)
+	gos_Info_IsMouseInSideWindow,			// (ULONG)  Returns 0 when the windows mouse is OVER the game window, or in full screen mode. Otherwise returns the absolute number of pixels away from the window the mouse is.
+
+	gos_Info_GetPixelColor,					// (ULONG)	Returns a 32 bit ARGB value for the pixel at screen location Param1=x, Param2=y. Param3=0 for back buffer, 1 for CopyBuffer (Dirty Rectangle mode). This API only valid during GameLogic or before SetupViewPort.
+
+	gos_Info_CanHardwareTandL,				// (ULONG)	TRUE when current mode is using hardware T&L
+	gos_Info_GetMaximumActiveLights,		// (ULONG)	Maximum number of active lights allowed in current mode (Can be -1 for infinite)
+	gos_Info_GetVertexBlendMatrices,		// (ULONG)  Returns 0 or 1 currently. The is the maximum number of vertex blend weights the hardware can blend.
+
+	gos_Info_GetApplicationStatus,			// (ULONG)  Bit 0 is true when the app is active, Bit 1 is true when the app has keyboard focus, Bit 2 is true when no rendering can occur (ie: Control Alt Delete Pressed)
+	gos_Info_GetDesktopResolution,			// (ULONG)	Get the resolution of the desktop (high word is vertical, low word is horizontal)
+	gos_Info_GetDesktopBitDepth,			// (ULONG)	Get the bitdepth of the desktop
+
+	gos_Info_GetIMEStatus,					// (ULONG)  Bit 0 is true when the IME is open.
+	gos_Info_GetKeyboardLayout,				// (ULONG)	Returns the current users keyboard layout from windows
+
+	gos_Info_GetMaximumTextureWidth,		// (ULONG)  Maximum width in texels of a texture or mipmap level.
+	gos_Info_GetMaximumTextureHeight,		// (ULONG)  Maximum height in texels of a texture or mipmap level.
+
+	gos_Info_CanBumpEnvMap,					// (ULONG)	TRUE when current mode supports bump environment maps
+	gos_Info_CanBumpDotMap,					// (ULONG)  Returns 1 if the current mode supports normal maps (dotproduct3)
+
+	gos_Info_HardwareGammaControl,			// (ULONG)	TRUE if full screen and hardware gamma control possible. Otherwise slower software gamma emulation is used
+	gos_Info_HardwareBrightnessControl,		// (ULONG)	TRUE if full screen and hardware brightness control possible. Otherwise invalid
+	gos_Info_HardwareContrastControl,		// (ULONG)	TRUE if full screen and hardware brightness control possible. Otherwise invalid
+
+	gos_Info_UsingHardwareRenderer,			// (ULONG)	TRUE when using a hardware renderer, 0=Blade. (Environment.renderer may have not been able to support hardware)
+
+	gos_Info_GetIMECaretStatus,				// (ULONG)  TRUE if an edit box should show its caret. When it's FALSE, an edit box shouldn't display caret.
+} MachineInfo;
 
 //
 // Returns machine information, valid for THE CURRENT FRAME ONLY
 //
-DWORD __stdcall gos_GetMachineInformation( MachineInfo mi, int Param1=0, int Param2=0, int Param3=0, int Param4=0 );
+ULONG __stdcall gos_GetMachineInformation( MachineInfo mi, int Param1=0, int Param2=0, int Param3=0, int Param4=0 );
 
 
 
@@ -3034,36 +2943,35 @@ DWORD __stdcall gos_GetMachineInformation( MachineInfo mi, int Param1=0, int Par
 #define gos_ErrorAppendRoutine	8192// append ' in Routine()+xxx' to the error  (or address if no symbols)
 #define Stat_Format				(0x40000000)// Used for formatting in statistics
 #define gos_SpewNoAddCR			1	// Don't add "\n" to spew output
-extern char* gosErrorFile;
-extern DWORD gosErrorLine;
-extern void __cdecl InternalFunctionSpew( const char* Group, const char* Message, ... );
-extern void __cdecl InternalFunctionSpewV( int Flags, const char* Group, const char* Message, char* arglist );
-extern int __cdecl InternalFunctionStop( const char* Message, ... );
-extern int __cdecl InternalFunctionPause( const char* Message, ... );
-extern void __stdcall gosLabRatStart( DWORD Handle );
-extern void __stdcall gosLabRatEnd( DWORD Handle );
-extern void __stdcall gosLabRatSet( DWORD Handle, DWORD Value );
-extern void __stdcall gosLabRatSet( DWORD Handle, float Value );
-extern "C" int __stdcall ErrorHandler( int Flags, char* Text );
+extern PSTR gosErrorFile;
+extern ULONG gosErrorLine;
+extern void __cdecl InternalFunctionSpew( PCSTR Group, PCSTR Message, ... );
+extern void __cdecl InternalFunctionSpewV( int Flags, PCSTR Group, PCSTR Message, PSTR arglist );
+extern int __cdecl InternalFunctionStop( PCSTR Message, ... );
+extern int __cdecl InternalFunctionPause( PCSTR Message, ... );
+extern void __stdcall gosLabRatStart( ULONG Handle );
+extern void __stdcall gosLabRatEnd( ULONG Handle );
+extern void __stdcall gosLabRatSet( ULONG Handle, ULONG Value );
+extern void __stdcall gosLabRatSet( ULONG Handle, float Value );
+extern "C" int __stdcall ErrorHandler( int Flags, PSTR Text );
 extern gosEnvironment Environment;
-struct gos_CycleData
-{
-	DWORD	Count;
-	bool	InsideStartEnd;
-	DWORD	Cycles;
-	DWORD	StartProcessorCycles;
+
+typedef struct gos_CycleData {
+	ULONG	Count;
+	UCHAR	InsideStartEnd;
+	UCHAR	_padding1[3];
+	ULONG	Cycles;
+	ULONG	StartProcessorCycles;
 	__int64	TotalCounter[2];
 	__int64	StartCounter[2];
-};
+} gos_CycleData;
 #define SPEWALWAYS(x)	InternalFunctionSpew x
-#pragma pack(pop)
+//#pragma pack(pop)
 
 
 
 // LOGGING FOR GosView.exe
 
-#ifdef __cplusplus
-
 ///////////////////////////////////////////////////////////////////////////////
 /////////////////////////////// GosView Logging ///////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
@@ -3087,7 +2995,7 @@ struct gos_CycleData
 ///////////////////////////// EVENT LOGGING MACROS ////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
 
-#ifdef LAB_ONLY		// debug, armor, or profile
+#if defined(LAB_ONLY)	// debug, armor, or profile
 
 #define LOG_REF(refobj,reftype,refname) static GosLogRef refobj(GosLogRef::reftype,refname,__FILE__,__LINE__)
 #define LOG_BLOCK(funcname)											\
@@ -3095,7 +3003,7 @@ LOG_REF(gosLogFuncRef,logEnter,funcname);							\
 GosLogFuncScope gosLogFuncScope( gosLogFuncRef );
 
 #define LOG_START_CHECK												\
-GosEventLog::LogStartPoint();
+GosEventLog::LogStartPoint(void);
 
 #else	// retail
 #define LOG_BLOCK(funcname)												
@@ -3105,18 +3013,17 @@ GosEventLog::LogStartPoint();
 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////// CLASSES FOR GOS MACRO USE ONLY //////////////////////
 ///////////////////////////////////////////////////////////////////////////////
-
+#ifdef __cplusplus
 
 class GosLogRef
 {
 	unsigned long	m_Count;
 	///void			(*m_pFunc)(GosLogRef &);
 	///void			*m_pObj;
-	DWORD			m_id;
+	ULONG			m_id;
 public:
 
-	enum EventType
-	{
+	enum EventType {
 		logEnter = 0,	// return must be 1 more than enter
 		logReturn = 1,
 		logCount,
@@ -3127,55 +3034,55 @@ public:
 		logDelete,
 		log,
 	};
-	GosLogRef( EventType type, char *name, char *filename, int lineno );
-	operator DWORD() { return m_id; }
-	bool ShouldLog() {  m_Count++; return true; }	// change to return (m_pFunc != NULL);
+	GosLogRef( EventType type, PSTR name, PSTR filename, int lineno );
+	operator ULONG() { return m_id; }
+	UCHAR ShouldLog() {  m_Count++; return 1; }	// change to return (m_pFunc != NULL);
 };
 
-
 class GosEventLog
 {
-	static DWORD		*pLogBase;
-	static DWORD		LogOffset;		// Offset into log in DWORDS
-	static DWORD		LogMod;			// Mod in DWORDS
-	static DWORD		NullLog[16];
-	static bool			WaitingToStart;
-	static bool			LoggingInProgress;
+	static PULONG       pLogBase;
+	static ULONG		LogOffset;		// Offset into log in ULONGS
+	static ULONG		LogMod;			// Mod in ULONGS
+	static ULONG		NullLog[16];
+	static UCHAR			WaitingToStart;
+	static UCHAR			LoggingInProgress;
 
 	// after stopping, the following members point to the frozen log
-	static char *		m_pLogStart1;
-	static DWORD		m_nLogSize1;	// size of first part in bytes
-	static char *		m_pLogStart2;
-	static DWORD		m_nLogSize2;	// size of second part in bytes
+	static PSTR 		m_pLogStart1;
+	static ULONG		m_nLogSize1;	// size of first part in bytes
+	static PSTR 		m_pLogStart2;
+	static ULONG		m_nLogSize2;	// size of second part in bytes
 
 public:
-	static void Log( DWORD id )
+	static void Log( ULONG id )
 	{
-		unsigned long time;
+		ULONG time;
 		LogOffset &= LogMod;
 		pLogBase[LogOffset++] = id;
-		_asm rdtsc
-		_asm mov time,eax
+		// _asm rdtsc
+		// _asm mov time,eax
+		time = (ULONG)__rdtsc();
 		pLogBase[LogOffset++] = time;
 	}
-	static void LogStart();
-	static void LogStartPoint();
-	static void LogStop();
-	static void PushStop();
-	static void PopStop();
-	static char *LogAddr( int part ) { return part?m_pLogStart2:m_pLogStart1; }
-	static DWORD LogBytes( int part ) { return part?m_nLogSize2:m_nLogSize1; }
-	static bool Logging() { return LoggingInProgress; }
-	static void Cleanup();
+	static void LogStart(void);
+	static void LogStartPoint(void);
+	static void LogStop(void);
+	static void PushStop(void);
+	static void PopStop(void);
+	static PSTR LogAddr( int part ) { return part?m_pLogStart2:m_pLogStart1; }
+	static ULONG LogBytes( int part ) { return part?m_nLogSize2:m_nLogSize1; }
+	static UCHAR Logging() { return LoggingInProgress; }
+	static void Cleanup(void);
 };
 
 class GosLogFuncScope
 {
 private:
-	DWORD		 m_Caller;
-	static DWORD Current;
+	ULONG		 m_Caller;
+	static ULONG Current;
 public:
-	GosLogFuncScope( DWORD newId )
+	GosLogFuncScope( ULONG newId )
 	{
 		m_Caller = Current;
 		GosEventLog::Log(newId);


  ================================================
diff --git a/source/gameos/include/hash.h b/source/gameos/include/hash.h
index c856bbc..f5a2bac 100755
--- a/source/gameos/include/hash.h
+++ b/source/gameos/include/hash.h
@@ -13,7 +13,7 @@
 #ifndef __HASH_H__
 #define __HASH_H__
 
-#pragma warning( disable : 4244 )
+//#pragma warning( disable : 4244 )
 
 //
 // Node structures
@@ -495,6 +495,6 @@ void  CHash<T,K>::TrashDay()
 }
 
 
-#pragma warning( default : 4244 )
+//#pragma warning( default : 4244 )
 
 #endif //!__HASH_H__


  ================================================
diff --git a/source/gameos/include/memorymanager.hpp b/source/gameos/include/memorymanager.hpp
index 6bb25a3..54d2df2 100755
--- a/source/gameos/include/memorymanager.hpp
+++ b/source/gameos/include/memorymanager.hpp
@@ -47,7 +47,7 @@ const int MemoryEndMarker=0x7fb1deaf;			// Placed at the end of allocations in _
 //
 typedef struct
 {
-#ifdef LAB_ONLY
+#if defined(LAB_ONLY)
 	BYTE			Size;						// Size of block (note pools are always <64K)
 #endif
 #ifdef _DEBUG
@@ -61,7 +61,7 @@ typedef struct
 //
 typedef struct
 {
-#ifdef LAB_ONLY
+#if defined(LAB_ONLY)
 	WORD			Size;						// Size of block (note pools are always <64K)
 #endif
 #ifdef _DEBUG
@@ -106,7 +106,7 @@ typedef struct _MEMORYPOOL
 	BYTE*				pMemoryPool;			// Pointer to the base of the memory blocks (pointer to header byte before allocation)
 	WORD				wBlockSize;				// what is the size of the individual blocks?
 	WORD				wTotalBlocks;			// Total blocks available
-	#ifdef LAB_ONLY
+	#if defined(LAB_ONLY)
 	WORD				wUserBytes;				// the amount of memory in the pool that is actual user data
 	#endif
 	WORD				AllocCount[16];			// Number of blocks allocated in each 4K page (when 0, block can be decommitted)
@@ -117,16 +117,16 @@ typedef struct _MEMORYPOOL
 //
 // Used to hold GameOS level heap information
 //
-struct gos_Heap
+typedef struct gos_Heap
 {
 	gos_Heap*	pParent;
 	gos_Heap*	pNext;
 	gos_Heap*	pChild;
-	DWORD		Magic;
+	ULONG		Magic;
 	int			Instances;
 	char		Name[128];
-#ifdef LAB_ONLY
-	DWORD		MaximumSize;
+#if defined(LAB_ONLY)
+	ULONG		MaximumSize;
 	int			BytesAllocated;
 	int			TotalAllocatedLastLoop;
 	int			BytesAllocatedThisLoop;
@@ -143,7 +143,7 @@ struct gos_Heap
 	int			DXAllocated;
 #endif
 	BYTE		HeapNumber;							// Heap number in HeapList[]  (<<24)
-};
+} gos_Heap;
 #pragma pack(pop)
 
 


  ================================================
diff --git a/source/gameos/include/mfcplatform.hpp b/source/gameos/include/mfcplatform.hpp
index bb6fede..67e560b 100755
--- a/source/gameos/include/mfcplatform.hpp
+++ b/source/gameos/include/mfcplatform.hpp
@@ -12,7 +12,7 @@
 #include <Platform.hpp>
 #include <GameOS.hpp>
 
-long _stdcall ProcessException( EXCEPTION_POINTERS* ep );
+NTSTATUS _stdcall ProcessException( PEXCEPTION_POINTERS ep );
 void _stdcall InitExceptionHandler( char* CommandLine );
 void _stdcall InitGameOS( HINSTANCE hInstance, HWND hWindow, char* CommandLine );
 LRESULT CALLBACK GameOSWinProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );


  ================================================
diff --git a/source/gameos/include/networkmessages.hpp b/source/gameos/include/networkmessages.hpp
index 04afd72..eb8c26f 100755
--- a/source/gameos/include/networkmessages.hpp
+++ b/source/gameos/include/networkmessages.hpp
@@ -144,7 +144,7 @@ class FIGuaranteedMessageHeader: public FIMessageHeader,public MessageTagger
 };
 
 
-#pragma warning (disable : 4200)
+//#pragma warning (disable : 4200)
 class FIGenericGuaranteedMessage:public FIGuaranteedMessageHeader
 {
 private:
@@ -255,7 +255,7 @@ public:
 
 
 
-#pragma warning (default : 4200)
+//#pragma warning (default : 4200)
 
 
 #pragma pack()


  ================================================
diff --git a/source/gameos/include/pch.hpp b/source/gameos/include/pch.hpp
index 1204f92..21150d8 100755
--- a/source/gameos/include/pch.hpp
+++ b/source/gameos/include/pch.hpp
@@ -1,11 +1,13 @@
-#pragma once
-#define DIRECTINPUT_VERSION 0x0700
 //===========================================================================//
 // File:	 pch.hpp														 //
 // Contents: Precompiled header file - heads that don't change much			 //
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+
+#pragma once
+#define DIRECTINPUT_VERSION 0x0700
+
 #pragma pack(4)
 //
 // These are used to disable features of GameOS
@@ -62,20 +64,20 @@
 //
 // Disable stupid warnings (So warning 4 can be used)
 //
-#pragma warning( disable: 4018 )	// signed/unsigned mismatches
-#pragma warning( disable: 4097 )	// typedef synonyms
-#pragma warning( disable: 4100 )	// unreferenced formal parameter
-#pragma warning( disable: 4102 )	// unreferenced labels
-#pragma warning( disable: 4127 )	// conditional expression is constant eg: While(1)
-#pragma warning( disable: 4201 )	// nameless struct/union
-#pragma warning( disable: 4245 )	// conversion from 'const int' to 'unsigned long', signed/unsigned mismatch
-#pragma warning( disable: 4355 )	// this used in base initializers
-#pragma warning( disable: 4511 )	// no copy constructor
-#pragma warning( disable: 4512 )	// no assignment operator
-#pragma warning( disable: 4514 )	// unreferenced inline function has been removed
-#pragma warning( disable: 4702 )	// Unreachable code
-#pragma warning( disable: 4710 )	// inline not expanded
-#pragma warning( disable: 4711 )	// auto-inline selection
+//#pragma warning( disable: 4018 )	// signed/unsigned mismatches
+//#pragma warning( disable: 4097 )	// typedef synonyms
+//#pragma warning( disable: 4100 )	// unreferenced formal parameter
+//#pragma warning( disable: 4102 )	// unreferenced labels
+//#pragma warning( disable: 4127 )	// conditional expression is constant eg: While(1)
+//#pragma warning( disable: 4201 )	// nameless struct/union
+//#pragma warning( disable: 4245 )	// conversion from 'const int' to 'unsigned long', signed/unsigned mismatch
+//#pragma warning( disable: 4355 )	// this used in base initializers
+//#pragma warning( disable: 4511 )	// no copy constructor
+//#pragma warning( disable: 4512 )	// no assignment operator
+//#pragma warning( disable: 4514 )	// unreferenced inline function has been removed
+//#pragma warning( disable: 4702 )	// Unreachable code
+//#pragma warning( disable: 4710 )	// inline not expanded
+//#pragma warning( disable: 4711 )	// auto-inline selection
 //
 // Common synonyms
 //
@@ -134,16 +136,16 @@ typedef float			real;
 //
 // So the GameOS can call it's own functions, GameOS.hpp is included
 //
-#include "GameOS.hpp"
-#include "ToolOS.hpp"
-#include "Platform.hpp"
+#include "gameos.hpp"
+#include "toolos.hpp"
+#include "platform.hpp"
 #include "eax.h"
-#include "Language.h"
+#include "language.h"
 //
 // Reads time stamp into an __int64, End finds difference
 //
-#define GetTimeStampStart(x) { _asm push eax  _asm push edx _asm rdtsc __asm mov dword ptr x,eax __asm mov dword ptr x+4,edx _asm pop edx _asm pop eax}
-#define GetTimeStampEnd(x) {  _asm push eax _asm push edx _asm rdtsc __asm sub eax,dword ptr x __asm sbb edx,dword ptr x+4 __asm mov dword ptr x,eax __asm mov dword ptr x+4,edx _asm pop edx _asm pop eax}
+//#define GetTimeStampStart(x) { _asm push eax  _asm push edx _asm rdtsc __asm mov dword ptr x,eax __asm mov dword ptr x+4,edx _asm pop edx _asm pop eax}
+//#define GetTimeStampEnd(x) {  _asm push eax _asm push edx _asm rdtsc __asm sub eax,dword ptr x __asm sbb edx,dword ptr x+4 __asm mov dword ptr x,eax __asm mov dword ptr x+4,edx _asm pop edx _asm pop eax}
 //
 // Faster float to long  (Always rounds to nearest)  ie: -2.7 goes to 3
 //


  ================================================
diff --git a/source/gameos/include/perf.h b/source/gameos/include/perf.h
index be77bae..e22b9f4 100755
--- a/source/gameos/include/perf.h
+++ b/source/gameos/include/perf.h
@@ -9,18 +9,18 @@
 //========================================================================
 // types
 //========================================================================
-typedef HRESULT (WINAPI * PERFMONCALLBACK)(char *szDescription, DWORD dwFlags, DWORD dwId);
+typedef HRESULT (__stdcall * PERFMONCALLBACK)(char *szDescription, DWORD dwFlags, DWORD dwId);
 
 //========================================================================
 // external functions
 //========================================================================
-extern HRESULT WINAPI InitPerformanceMonitorLibrary(void);
-extern HRESULT WINAPI TermPerformanceMonitorLibrary(void);
+extern HRESULT __stdcall InitPerformanceMonitorLibrary(void);
+extern HRESULT __stdcall TermPerformanceMonitorLibrary(void);
 
-extern HRESULT WINAPI EnumeratePerformanceMonitors(PERFMONCALLBACK lpfCallback);
-extern HRESULT WINAPI SetPerformanceMonitor(DWORD dwId);
-extern double DecodePerformanceMonitors( __int64 *Registers );
-extern BOOL WINAPI ReadPerformanceMonitorRegisters(__int64 *result);
+extern HRESULT __stdcall EnumeratePerformanceMonitors(PERFMONCALLBACK lpfCallback);
+extern HRESULT __stdcall SetPerformanceMonitor(DWORD dwId);
+extern double __stdcall DecodePerformanceMonitors( __int64 *Registers );
+extern BOOL __stdcall ReadPerformanceMonitorRegisters(__int64 *result);
 
 
 //========================================================================


  ================================================
diff --git a/source/gameos/include/platform.hpp b/source/gameos/include/platform.hpp
index fec9c95..b0561a3 100755
--- a/source/gameos/include/platform.hpp
+++ b/source/gameos/include/platform.hpp
@@ -1,22 +1,18 @@
-#pragma once
 //===========================================================================//
 // File:	 Platform.cpp													 //
 // Contents: Setup GameOS for running games, MFC or DLL's					 //
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#pragma once
 
 
-typedef enum PlatformType
-{
+typedef enum PlatformType {
 	Platform_Game,
 	Platform_MFC,
 	Platform_DLL
-};
-
-
-
+} PlatformType;
 extern PlatformType Platform;
 
-extern void _stdcall RunFromOtherApp( HINSTANCE hInstance, HWND hWnd, char* CommandLine );
-extern int APIENTRY RunFromWinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow );
+extern void _stdcall RunFromOtherApp(HINSTANCE hInstance, HWND hWnd, PSTR CommandLine);
+extern int _stdcall RunFromWinMain( HINSTANCE hInst, HINSTANCE hPrevInst, PSTR lpCmdLine, int nCmdShow );


  ================================================
diff --git a/source/gameos/include/profiler.hpp b/source/gameos/include/profiler.hpp
index ceed8f9..bcde548 100755
--- a/source/gameos/include/profiler.hpp
+++ b/source/gameos/include/profiler.hpp
@@ -6,7 +6,7 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-extern DWORD* TraceBuffer;
+extern ULONG* TraceBuffer;
 extern gos_VERTEX* LineBuffer;
 
 
@@ -14,7 +14,7 @@ extern gos_VERTEX* LineBuffer;
 
 
 extern BYTE	ProfileFlags[32];			// Remember graphs activated 
-extern DWORD DebuggerTextures;
+extern ULONG DebuggerTextures;
 extern float PercentHistory[512];		// Used to remember cycles per frame
 extern bool NewPerformanceRegister;
 
@@ -24,11 +24,11 @@ extern bool NewPerformanceRegister;
 typedef struct _Stat
 {
 	_Stat*			pNext;				// Pointer to Next
-	DWORD			Flags;				// flags
-	char*			TypeName;			// Pointer to type name
+	ULONG			Flags;				// flags
+	PSTR			TypeName;			// Pointer to type name
 	gosType			Type;				// Type of variable
-	DWORD			Count;				// Count for average
-	void*			pVariable;			// Pointer to the variable in question
+	ULONG			Count;				// Count for average
+	PVOID			pVariable;			// Pointer to the variable in question
 		
 	float			MaxPercentage;		// Max percentage
 	float			MinPercentage;		// Min percentage
@@ -48,33 +48,31 @@ typedef struct _Stat
 
 const int StatsInBlock=32;				// Number of stats in a single block
 
-__inline float GetHistory( Stat* pStat, int GraphHead )
+__inline float __stdcall GetHistory( Stat* pStat, int GraphHead )
 {
 	return pStat->History[GraphHead*StatsInBlock];
 }
-__inline void SetHistory( Stat* pStat, int GraphHead, float Value )
+__inline void __stdcall SetHistory( Stat* pStat, int GraphHead, float Value )
 {
 	pStat->History[GraphHead*StatsInBlock]=Value;
 }
 
 
 extern Stat*	pStatistics;		// Pointer to chain of statistics
-extern DWORD	GraphHead;			// Pointer to current element in statistics History
-extern DWORD	NumberStatistics;	// Entries in statistic list
+extern ULONG	GraphHead;			// Pointer to current element in statistics History
+extern ULONG	NumberStatistics;	// Entries in statistic list
 extern Stat* GraphsActive[20];		// Number of frame graphs active
-extern DWORD NumberGraphsActive;
+extern ULONG NumberGraphsActive;
 
+void __stdcall UpdateGraphs(void);
+void __stdcall InitStatistics(void);
+void __stdcall DestroyStatistics(void);
+void __stdcall UpdateStatistics(void);
+void __stdcall ResetStatistics(void);
 
-
-void UpdateGraphs();
-void InitStatistics();
-void DestroyStatistics();
-void UpdateStatistics();
-void ResetStatistics();
-
-#ifdef LAB_ONLY
-void SaveStatistics();
-void RestoreStatistics();
+#if defined(LAB_ONLY)
+void __stdcall SaveStatistics(void);
+void __stdcall RestoreStatistics(void);
 #endif
 
 


  ================================================
diff --git a/source/gameos/include/registry.hpp b/source/gameos/include/registry.hpp
index 5ee58bb..7964df1 100755
--- a/source/gameos/include/registry.hpp
+++ b/source/gameos/include/registry.hpp
@@ -1,19 +1,17 @@
-#pragma once
 //==========================================================================//
 // File:	 Registry.cpp													//
 // Contents: Registry routines												//
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#pragma once
 
 #include "String.hpp"
 
-void RegistryManagerInstall();
-void RegistryManagerUninstall();
-char* ReadRegistry( char* KeyName, char* ValueName, bool LocalMachine );
-char* ReadRegistryHKCU( char* KeyName, char* ValueName, bool LocalMachine );
-
-
-extern DWORD UpdatedExe;					// Has the exe been updated since last run?
+void __stdcall RegistryManagerInstall(void);
+void __stdcall RegistryManagerUninstall(void);
+PSTR __stdcall ReadRegistry( PSTR KeyName, PSTR ValueName, bool LocalMachine );
+PSTR __stdcall ReadRegistryHKCU( PSTR KeyName, PSTR ValueName, bool LocalMachine );
 
+extern ULONG UpdatedExe;					// Has the exe been updated since last run?
 


  ================================================
diff --git a/source/gameos/include/sessionmanager.hpp b/source/gameos/include/sessionmanager.hpp
index 89e0105..fc8bdeb 100755
--- a/source/gameos/include/sessionmanager.hpp
+++ b/source/gameos/include/sessionmanager.hpp
@@ -10,14 +10,10 @@
 #include "netplayer.hpp"
 #include "networkmessages.hpp"
 
-typedef void(*LPVOIDCALLBACK)();
+typedef void(*LPVOIDCALLBACK)(void);
 
-#include "Network.hpp"
+#include "network.hpp"
 
-
-
-
-//
 //============================================================
 //
 // Contents:  Low level networking
@@ -27,7 +23,7 @@ typedef void(*LPVOIDCALLBACK)();
 // All Rights reserved worldwide (c) Microsoft
 // This unpublished sourcecode is PROPRIETARY and CONFIDENTIAL               
 //============================================================
-//
+
 #include "session.hpp"
 
 
@@ -37,85 +33,56 @@ typedef void(*LPVOIDCALLBACK)();
 //
 extern FIDPSession *currentSession;
 
-
-
 //
 // Current connection
 //
 extern int currentConnectionType;
 extern bool Connected;
 
-
-
-
 //
 // Modem/Serial has dialed
 //
 extern bool Connected;
 
-
-
-
 //
 // Modem variables
 //
 extern char modemNames[10][64];
-extern DWORD NumModems;
+extern ULONG NumModems;
 extern bool modemChecked;
 extern bool hasModem;
-bool __stdcall FindModems();
+bool __stdcall FindModems(void);
 bool __stdcall gos_ConnectModem( char *phone_number, char *modem_name );
 
-
 //
 // COM port variables
 //
-bool __stdcall gos_ConnectComPort(DWORD com_port);
+bool __stdcall gos_ConnectComPort(ULONG com_port);
 
 
 //
 // IPX variables
 //
 extern bool hasIPX;
-bool __stdcall gos_ConnectIPX();
-
-
+bool __stdcall gos_ConnectIPX(void);
 
 //
 // TCPIP variables
 //
 extern bool hasTCP;
-bool __stdcall gos_ConnectTCP( char *ip_address, WORD port );
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+bool __stdcall gos_ConnectTCP( char *ip_address, USHORT port );
 
 /////  AddressInfo is used in connections initialized entirely by
 // user defined data, such as a TCP connection created by calling
 // the CreateCompoundAddress function and using it as the connection.
 typedef struct _DPAddressInfo
 {
-	DWORD	type;
-	DWORD	size;
-	LPVOID	data;
+	ULONG	type;
+	ULONG	size;
+	PVOID	data;
 } DPAddressInfo;
 
 
-
-
-
-
 //////////////////////////////////////////////////////////////////////
 // SessionManager class.  The SessionManager deals with all DirectPlay
 // specific functionality.  It allows the user to call a few simple functions
@@ -189,7 +156,7 @@ class SessionManager
 	DPID thisPlayerID;
 	DPID serverID;
 	FIDPPlayer *thisPlayer;
-	DWORD threadID;
+	ULONG threadID;
 
 	BOOL launchedFromLobby; // TRUE if this app was launched through a DPlay lobby.
 	BOOL lobbyChecked; // TRUE if we have initialized launchedFromLobby.
@@ -207,7 +174,7 @@ class SessionManager
 
 	// enableAutoDialValue is the value of the EnableAutodial key in the
 	// registry.  
-	DWORD enableAutodialValue;
+	ULONG enableAutodialValue;
 
 	HANDLE ReceiveMutex;
 	HANDLE EmptyMessageListMutex;
@@ -227,7 +194,7 @@ class SessionManager
 
 	int NetworkProtocolFlags;
 	
-	unsigned char messageBuffer[1024];
+	UCHAR messageBuffer[1024];
 
 
 	DPID newPlayerNumbers[MAXPLAYERS];
@@ -252,18 +219,18 @@ class SessionManager
 	DPID receiveThreadPlayerIDs[MAXPLAYERS];
 	
 	int serverOrder[MAXPLAYERS];
-	DWORD pingUpdateTime;
-	DWORD pingUpdateFrequency;
+	ULONG pingUpdateTime;
+	ULONG pingUpdateFrequency;
 
 
-	HRESULT	ResetDirectPlayInterface();
+	HRESULT	ResetDirectPlayInterface(void);
 
 	HRESULT CreatePlayer(char *player_name);
 
 
 	inline HRESULT SetSessionDescriptor(FIDPSession *ss)
 	{
-		return wSetSessionDesc(dplay4, ss -> GetSessionDescriptor(),0);
+		return wSetSessionDesc(dplay4, ss -> GetSessionDescriptor(void),0);
 	}
 
 
@@ -273,43 +240,43 @@ class SessionManager
 	void EnumeratePlayers(FIDPSession *session);
 
 	void AddPlayerOrGroup(
-						DWORD dwPlayerType,
+						ULONG dwPlayerType,
 						DPID dpId,
 						DPID dpIdParent,
 						LPDPNAME dpnName,
-						DWORD dwFlags);
+						ULONG dwFlags);
 	
 	// DeletePlayerOrGroup is called when a player or group leaves the
 	// game -- after calling AppCallback.  It actually deletes this player
 	// or group from the linked list.
 	void DeletePlayerOrGroup(
-						DWORD dwPlayerType,
+						ULONG dwPlayerType,
 						DPID dpId);
 
 
 	// PlayerOrGroupLeaving is called when a player or group leaves the
 	// game -- before calling AppCallback.
-	void PlayerOrGroupLeaving(	DWORD dwPlayerType,
+	void PlayerOrGroupLeaving(	ULONG dwPlayerType,
 								DPID dpId);
 	
 	void HandleApplicationMessage(FIDPMessage *msg);
 
 	void UpdatePlayerGuaranteedMessages
-			(FIDPPlayer *player, DWORD time);
+			(FIDPPlayer *player, ULONG time);
 
 	// ProcessGuaranteedMessages is called by ProcessApplicationMessages
 	// once all messages have been initially handled.  Guaranteed messages
 	// are processed in 2 steps.  The first puts them in the proper hold 
 	// buffers.  The second gets messages ready to be processed from the
 	// hold buffers.
-	void ProcessGuaranteedMessages();
+	void ProcessGuaranteedMessages(void);
 
 	// The following 2 functions are called to add and remove messages from
 	// the empty message queue.  They use mutexes so the 2 threads don't
 	// both access the queue at the same time.
 	void AddMessageToEmptyQueue(FIDPMessage *msg);
 
-	FIDPMessage *GetMessageFromEmptyQueue();
+	FIDPMessage *GetMessageFromEmptyQueue(void);
 
 
 
@@ -328,23 +295,23 @@ private:
 	// bounces the message into the class using the lpContext member.
 	BOOL FAR PASCAL AddConnection(
 						LPCGUID     lpguidSP,
-						LPVOID		lpConnection,
-						DWORD		dwConnectionSize,
+						PVOID		lpConnection,
+						ULONG		dwConnectionSize,
 						LPCDPNAME   lpName,
-						DWORD 		dwFlags,
-						LPVOID 		lpContext);
+						ULONG 		dwFlags,
+						PVOID 		lpContext);
 
 	BOOL FAR PASCAL AddSession(
 						LPCDPSESSIONDESC2 lpThisSD,
 						LPDWORD lpdwTimeOut,
-						DWORD dwFlags,
-						LPVOID lpContext
+						ULONG dwFlags,
+						PVOID lpContext
 						);
 
 	BOOL FAR PASCAL NewPlayerEnumeration(DPID dp_id,
-										DWORD dwPlayerType,
+										ULONG dwPlayerType,
 										LPCDPNAME lpName,
-										DWORD dwFlags);
+										ULONG dwFlags);
 
 	// RTProcessApplicationMessage is called by the receive thread when
 	// a new application message arrives.
@@ -359,7 +326,7 @@ private:
 	
 	FIDPPlayer *RTGetPlayer(DPID id);
 
-	void ClearSessionList();
+	void ClearSessionList(void);
 	
 
 	void HandlePreSystemMessage(FIDPMessage *msg);
@@ -371,7 +338,7 @@ private:
 
 	// SendPreIDGuaranteedMessages is called once when the new player
 	// gets a list of player numbers and the server ID.
-	void SendPreIDGuaranteedMessages();
+	void SendPreIDGuaranteedMessages(void);
 
 	// GivePlayerAnID assigns the first available playerNumber to 
 	// this player.  If there is no gap in assigned numbers, this
@@ -383,7 +350,7 @@ private:
 		
 		SessionManager(GUID app_guid);
 		
-		virtual ~SessionManager();
+		virtual ~SessionManager(void);
 
 		virtual void destroy (void);
 
@@ -391,47 +358,47 @@ private:
 		friend BOOL FAR PASCAL DPSessionMgrSessionsCallback(
 						LPCDPSESSIONDESC2	lpSessionDesc,
 						LPDWORD				lpdwTimeOut,
-						DWORD				dwFlags,
-						LPVOID				lpContext);
+						ULONG				dwFlags,
+						PVOID				lpContext);
 
 		friend BOOL FAR PASCAL EnumPlayersCallback (DPID dpId,
-										DWORD dwPlayerType,
+										ULONG dwPlayerType,
 										LPCDPNAME lpName,
-										DWORD dwFlags,
-										LPVOID lpContext);
+										ULONG dwFlags,
+										PVOID lpContext);
 
 		friend BOOL FAR PASCAL EnumGroupsCallback (DPID dpId,
-									  DWORD dwPlayerType,
+									  ULONG dwPlayerType,
 									  LPCDPNAME lpName,
-									  DWORD dwFlags,
-									  LPVOID lpContext);
+									  ULONG dwFlags,
+									  PVOID lpContext);
 
-		friend DWORD WINAPI
-			SessionManagerReceiveThread(LPVOID lpThreadParameter);
+		friend ULONG WINAPI
+			SessionManagerReceiveThread(PVOID lpThreadParameter);
 
 
 		// ReceiveThread is called by the SessionManagerReceiveThread
 		// callback to handle thread events.
-		int ReceiveThread();
+		int ReceiveThread(void);
 
 
 
 		// InitializeConnection is called by one of the following functions
 		// to allow the user to bypass the crappy windows dialogs.
-		long InitializeConnection(DPCOMPOUNDADDRESSELEMENT *compound_address, 
-							int n_items);
+		long InitializeConnection(
+			DPCOMPOUNDADDRESSELEMENT *compound_address, int n_items);
 
-		long Dial();
-		void CancelDialing();
+		long Dial(void);
+		void CancelDialing(void);
 
 
 		// Call this function at program start up to find out if
 		// we were launched from a lobby.
-		BOOL WasLaunchedFromLobby();
+		BOOL WasLaunchedFromLobby(void);
 
 		// If we were launched from a lobby, SetupLobbyConnection creates
 		// a protocol, session, and player to start the game.
-		DWORD SetupLobbyConnection(LPVOIDCALLBACK create_callback,LPVOIDCALLBACK destroy_callback);
+		ULONG SetupLobbyConnection(LPVOIDCALLBACK create_callback,LPVOIDCALLBACK destroy_callback);
 
 
 		// returns the name of the modem at index or NULL if index
@@ -451,24 +418,24 @@ private:
 
 		// LockSession can only be done by the host.  If successful, it
 		// returns 1, else it returns 0
-		int LockSession();
+		int LockSession(void);
 
 		// LeaveSession kills the current player and removes him from the session.
-		int LeaveSession();
+		int LeaveSession(void);
 
 
 		void CreateGroup 
 			(	LPDPID id, 
 				char* name, 
-				LPVOID data = NULL, 
-				DWORD size = 0, 
-				DWORD flags = 0);
+				PVOID data = NULL, 
+				ULONG size = 0, 
+				ULONG flags = 0);
 
 		void SetGroupData 
 			(	DPID id, 
-				LPVOID data, 
-				DWORD size, 
-				DWORD flags = 0);
+				PVOID data, 
+				ULONG size, 
+				ULONG flags = 0);
 
 		// If player_id is 0 or not filled in, the local player is
 		// added.  If the group doesn't exist, the player isn't added.
@@ -497,34 +464,34 @@ private:
 		void SendMessageToGroupGuaranteed(
 						DPID group_id, 
 						FIGuaranteedMessageHeader *message, 
-						DWORD size);
+						ULONG size);
 		
 		void SendMessageToPlayerGuaranteed(
 						DPID player_id, 
 						FIGuaranteedMessageHeader *message, 
-						DWORD size,
+						ULONG size,
 						BOOL set_send_count = TRUE);
 		
 		void SendMessageToServerGuaranteed(
 						FIGuaranteedMessageHeader *message, 
-						DWORD size);
+						ULONG size);
 						
-		void BroadcastMessage(FIMessageHeader *message, DWORD size);
+		void BroadcastMessage(FIMessageHeader *message, ULONG size);
 		
 		void SendMessageToServer(
 						FIMessageHeader *message, 
-						DWORD size);
+						ULONG size);
 		
 		HRESULT SendMessage(
 						DPID group_or_player_id,
 						FIMessageHeader *message, 
-						DWORD size);
+						ULONG size);
 
 		HRESULT SendGOSMessage(NetworkMessageContainer& message_info);
 
 		void SendMessageFromInfo(FIDPMessage *message);
 
-		int SendVerifies();
+		int SendVerifies(void);
 
 
 		// Accessor functions to update lists of network specifics
@@ -532,17 +499,17 @@ private:
 		FLinkedList<FIDPPlayer> *GetPlayers(FIDPSession *session=NULL);
 		
 
-		inline FIDPSession *GetCurrentSession()
+		inline FIDPSession *GetCurrentSession(void)
 		{
 			return currentSession;
 		}
 
-		inline FIDPPlayer *GetLocalPlayer()
+		inline FIDPPlayer *GetLocalPlayer(void)
 		{
 			return thisPlayer;
 		}
 
-		DPID GetServerID()
+		DPID GetServerID(void)
 		{
 			return serverID;
 		}
@@ -560,7 +527,7 @@ private:
 
 		FIDPPlayer *GetPlayer(unsigned long id);
 
-		inline BOOL IsLocalHost()
+		inline BOOL IsLocalHost(void)
 		{
 			return bSessionHost;
 		}
@@ -568,17 +535,17 @@ private:
 
 		// ProcessMessages should be called to get all new messages and
 		// send guaranteed and file messages.
-		void ProcessMessages();
+		void ProcessMessages(void);
 
 		//ProcessSystemMessages processes all of the system messages in the
 		//receive buffer.  If the application needs to deal with them
 		//individually, the sys_callback function is called for each one.
-		int ProcessSystemMessages();
+		int ProcessSystemMessages(void);
 
-		int ProcessApplicationMessages();
+		int ProcessApplicationMessages(void);
 
 		// UpdateGuaranteedMessages should be sent by the application???
-		void UpdateGuaranteedMessages();
+		void UpdateGuaranteedMessages(void);
 
 		
 		
@@ -587,5 +554,5 @@ private:
 
 extern SessionManager *globalSessionManager;
 
-void InitNetworking();
+void __stdcall InitNetworking(void);
 


  ================================================
diff --git a/source/gameos/include/sound_renderer.hpp b/source/gameos/include/sound_renderer.hpp
index 9e0d342..494315f 100755
--- a/source/gameos/include/sound_renderer.hpp
+++ b/source/gameos/include/sound_renderer.hpp
@@ -6,14 +6,12 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "LinkedList.hpp"
-#include "DirectX.hpp"
-#include "Sound Resource.hpp"
-#include "Sound DS3DChannel.hpp"
-#include "Sound DS3DMixer.hpp"
+#include "linkedlist.hpp"
+#include "directx.hpp"
+#include "sound_resource.hpp"
+#include "sound_ds3dchannel.hpp"
+#include "sound_ds3dmixer.hpp"
 
-
-//
 // This structure is used to initialize sound channels
 //
 // When GameOS is started, the init structure passed to GameOS by the application will contain a master frequency (11025,22050 or 44100), a number of channels (int) and a pointer to an array, a byte per channel containing flags listed above.
@@ -25,14 +23,12 @@
 //
 // Used for sound device enumeration - Maximum of 8 devices
 //
-typedef struct
-{
+typedef struct SoundDeviceInfo {
 	GUID				Guid;
 	char				Description[128];
 	char				Driver[128];
 	char				Version[256];
 	DSCAPS				Caps;
-
 } SoundDeviceInfo;
 
 #define MAX_SOUNDCHANNELS 64
@@ -59,52 +55,39 @@ typedef struct _srdata
 		m_workBuffer;
 
 	SoundDeviceInfo m_DeviceArray[8];
-	DWORD m_numDevices;
-	DWORD m_PreferredDevice;
+	ULONG m_numDevices;
+	ULONG m_PreferredDevice;
 	bool m_reset;
 	bool m_allPaused;
-#ifdef LAB_ONLY
+#if defined(LAB_ONLY)
 	char m_playHistory[32][128];
 	bool m_verboseDebugger;
-	DWORD m_playHistoryItr;
+	ULONG m_playHistoryItr;
 #endif
 
 } SoundRendererData;
 
 extern HGOSHEAP SoundHeap;
 
-void SoundRendererInstall(int);
-
-void SoundRendererStartFrame();
-
-void SoundRendererEndFrame();
-
-DWORD WINAPI SoundRendererUpdate( LPVOID ThreadParam );
-
-void SoundRendererUninstall();
-
-void SoundRendererCreateTimer();
-
-void SoundRendererDestroyTimer();
-
-void SoundRendererPause();
-
-void SoundRendererContinue();
-
-void SoundRendererFF(double sec);
-
-bool IsValidSoundResource(HGOSAUDIO gosAudio);
-
-
-void CALLBACK 
-	TimeFunc
-( 
+void __stdcall SoundRendererInstall(int);
+void __stdcall SoundRendererStartFrame();
+void __stdcall SoundRendererEndFrame();
+ULONG __stdcall SoundRendererUpdate( PVOID ThreadParam );
+void __stdcall SoundRendererUninstall();
+void __stdcall SoundRendererCreateTimer();
+void __stdcall SoundRendererDestroyTimer();
+void __stdcall SoundRendererPause();
+void __stdcall SoundRendererContinue();
+void __stdcall SoundRendererFF(double sec);
+bool __stdcall IsValidSoundResource(HGOSAUDIO gosAudio);
+
+void __stdcall TimeFunc( 
 	UINT uTimerID, 
 	UINT uMsg, 
-	DWORD dwUser,
-	DWORD dw1, 
-	DWORD dw2 
+	ULONG dwUser,
+	ULONG dw1, 
+	ULONG dw2 
 );
 
-void SoundRendererNotify();
+void __stdcall SoundRendererNotify();
 


  ================================================
diff --git a/source/gameos/include/sound_resource.hpp b/source/gameos/include/sound_resource.hpp
index 8f44944..db9531c 100755
--- a/source/gameos/include/sound_resource.hpp
+++ b/source/gameos/include/sound_resource.hpp
@@ -6,7 +6,7 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "Music.hpp"
+#include "music.hpp"
 
 struct SoundResource
 {


  ================================================
diff --git a/source/gameos/include/string.hpp b/source/gameos/include/string.hpp
index 5938471..b1fc1f0 100755
--- a/source/gameos/include/string.hpp
+++ b/source/gameos/include/string.hpp
@@ -20,8 +20,8 @@ class FixedLengthString
 //
 // Data
 //
-	int MaximumLength;
-	int CurrentSize;
+	size_t MaximumLength;
+	size_t CurrentSize;
 	char* Text;
 //
 // Visible stuff
@@ -30,13 +30,13 @@ class FixedLengthString
 //
 // Constructor
 //
-	inline FixedLengthString( int Length )
+	inline FixedLengthString(size_t Length )
 	{
 		gosASSERT( Length!=0 );
 		Text=(char*)malloc(Length);
 		MaximumLength=Length;
 		CurrentSize=0;
-		*Text=0;
+		if (Text) *Text=0;
 	}
 //
 // Destructor
@@ -55,7 +55,7 @@ class FixedLengthString
 //
 // Individual chars can be referenced
 //
-	inline char operator [] ( int Offset) const
+	inline char operator [] ( size_t Offset) const
 	{
 		if( Offset<=CurrentSize )
 			return *(Text+Offset);
@@ -65,7 +65,7 @@ class FixedLengthString
 //
 // Get Length
 //
-	inline int Length()
+	inline size_t Length()
 	{
 		return CurrentSize;
 	}
@@ -91,7 +91,7 @@ class FixedLengthString
 	{
 		if( Source )
 		{
-			int Length=strlen(Source)+1;
+			size_t Length=strlen(Source)+1;
 
 			if( Length>MaximumLength )
 				Length=MaximumLength;
@@ -109,7 +109,7 @@ class FixedLengthString
 //
 	inline FixedLengthString& operator += (char* Source)
 	{
-		int Length=strlen(Source)+1;
+		size_t Length=strlen(Source)+1;
 
 		if( CurrentSize+Length>MaximumLength )
 			Length=MaximumLength-CurrentSize;
@@ -129,7 +129,7 @@ class FixedLengthString
 	{
 		if( Source )
 		{
-			int Length=strlen(Source)+1;
+			size_t Length=strlen(Source)+1;
 
 			if( CurrentSize+Length>MaximumLength )
 				Length=MaximumLength-CurrentSize;
@@ -151,7 +151,7 @@ class FixedLengthString
 		
 		_itoa(Value, Source, 10);
 
-		int Length=strlen(Source)+1;
+		size_t Length=strlen(Source)+1;
 
 		if( CurrentSize+Length>MaximumLength )
 			Length=MaximumLength-CurrentSize;
@@ -173,7 +173,7 @@ class FixedLengthString
 		
 		_itoa(Value, Source, 10);
 
-		int Length=strlen(Source)+1;
+		size_t Length=strlen(Source)+1;
 
 		if( CurrentSize+Length>MaximumLength )
 			Length=MaximumLength-CurrentSize;


  ================================================
diff --git a/source/gameos/include/texture_manager.hpp b/source/gameos/include/texture_manager.hpp
index 77b06d0..5f56cd7 100755
--- a/source/gameos/include/texture_manager.hpp
+++ b/source/gameos/include/texture_manager.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 Texture Manager.hpp											 //
 // Contents: Texture Mananger												 //
@@ -6,17 +5,18 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-class CTexInfo;	// Per-texture class defined below
+#pragma once
 
+class CTexInfo;	// Per-texture class defined below
 
 //
 // List of video memory textures (so we don't delete on some cards)
 //
 typedef struct _VidMemHeap
 {
-	_VidMemHeap*			pNext;
+	struct _VidMemHeap*		pNext;
 	DDSURFACEDESC2			ddsd;
-	IDirectDrawSurface7*	Surface;
+	LPDIRECTDRAWSURFACE7	Surface;
 
 } VidMemHeap;
 
@@ -26,7 +26,7 @@ extern VidMemHeap* pFreeVidMemTextures;
 
 #if 1
 	#define TEXHANDLE_TO_PTR(handle) ((CTexInfo *)(handle))
-	#define TEXPTR_TO_HANDLE(ptr) ((DWORD)(ptr))
+	#define TEXPTR_TO_HANDLE(ptr) ((ULONG)(ptr))
 #else
 	#define TEXHANDLE_TO_PTR(handle) (CTexInfo::TextureHandleToPtr(handle))
 	#define TEXPTR_TO_HANDLE(ptr) (ptr->TexturePointerToHandle())
@@ -36,54 +36,56 @@ extern int						HasMipMap;					// Can do mipmapping
 extern D3DDEVICEDESC7			CapsDirect3D;				// Current 3D device caps
 
 // Pixel conversion helper functions
-DWORD GetPixelColor( DWORD In );
-DWORD GetBackBufferColor( WORD In );
+ULONG GetPixelColor( ULONG In );
+ULONG GetBackBufferColor( USHORT In );
 void UpdateBackBufferFormat();
 
-void DecodeBMPDimensions( const char* FileName, BYTE *Data, DWORD DataSize, DWORD* pTextureWidth, DWORD* pTextureHeight );
-void DecodeJPGDimensions( const char* FileName, BYTE *Data, DWORD DataSize, DWORD* pTextureWidth, DWORD* pTextureHeight );
+void __stdcall DecodeBMPDimensions( PCSTR FileName, PUCHAR Data, ULONG DataSize, PULONG pTextureWidth, PULONG pTextureHeight );
+void __stdcall DecodeJPGDimensions( PCSTR FileName, PUCHAR Data, ULONG DataSize, PULONG pTextureWidth, PULONG pTextureHeight );
 #ifdef USEPNG
-void* DecodePNG( const char* FileName, BYTE* Data, DWORD DataSize, DWORD* TextureWidth, DWORD* TextureHeight, bool TextureLoad, void *pDestSurf=NULL );
-void DecodePNGDimensions( const char* FileName, BYTE *Data, DWORD DataSize, DWORD* pTextureWidth, DWORD* pTextureHeight );
+PVOID __stdcall DecodePNG( PCSTR FileName, PUCHAR Data, ULONG DataSize, PULONG TextureWidth, PULONG TextureHeight, bool TextureLoad, PVOID pDestSurf=NULL );
+void __stdcall DecodePNGDimensions( PCSTR FileName, PUCHAR Data, ULONG DataSize, PULONG pTextureWidth, PULONG pTextureHeight );
 #endif
-void DecodeTGADimensions( const char* FileName, BYTE *Data, DWORD DataSize, DWORD* pTextureWidth, DWORD* pTextureHeight );
+void DecodeTGADimensions( PCSTR FileName, PUCHAR Data, ULONG DataSize, PULONG pTextureWidth, PULONG pTextureHeight );
 
-void* DecodeBMP( const char* FileName, BYTE* Data, DWORD DataSize, DWORD* TextureWidth, DWORD* TextureHeight, bool TextureLoad, void *pDestSurf=NULL );
-void* DecodeJPG( const char* FileName, BYTE* Data, DWORD DataSize, DWORD* TextureWidth, DWORD* TextureHeight, bool TextureLoad, void *pDestSurf=NULL );
-void* DecodeTGA( const char* FileName, BYTE* Data, DWORD DataSize, DWORD* TextureWidth, DWORD* TextureHeight, bool TextureLoad, void *pDestSurf=NULL );
+PVOID DecodeBMP( PCSTR FileName, PUCHAR Data, ULONG DataSize, PULONG TextureWidth, PULONG TextureHeight, bool TextureLoad, PVOID pDestSurf=NULL );
+PVOID DecodeJPG( PCSTR FileName, PUCHAR Data, ULONG DataSize, PULONG TextureWidth, PULONG TextureHeight, bool TextureLoad, PVOID pDestSurf=NULL );
+PVOID DecodeTGA( PCSTR FileName, PUCHAR Data, ULONG DataSize, PULONG TextureWidth, PULONG TextureHeight, bool TextureLoad, PVOID pDestSurf=NULL );
 
-int MipLevelsRequired( WORD Width, WORD Height );
+int MipLevelsRequired( USHORT Width, USHORT Height );
 
 // GOS Internal textures
-extern DWORD FontTexture;						// The font and mouse pointer
-extern DWORD ChessTexture;						// Checkerboard pattern
-extern DWORD MipColorTexture;					// The mipmap color texture
+extern ULONG FontTexture;						// The font and mouse pointer
+extern ULONG ChessTexture;						// Checkerboard pattern
+extern ULONG MipColorTexture;					// The mipmap color texture
 
 // Valid surface descriptions
 extern DDSURFACEDESC2 TextureDesc[5][2][4];		// arranged by:  [Format][want32bpp][compression]
 extern int TextureDescScore[5][2][4];			// validity of current entry in TextrueDesc
 
 // Maximum number of textures that are supported (can be altered independently from display cards)
-const DWORD					MaximumTextures=3000;
-extern DWORD				MaximumVidTextures;	// limit the number simultaneously loaded
+const ULONG					MaximumTextures=3000;
+extern ULONG				MaximumVidTextures;	// limit the number simultaneously loaded
 
-const DWORD					MaximumTextureLogs=32;
+const ULONG					MaximumTextureLogs=32;
 // Texture flags
-const WORD					tFlag_InVidMem=1;	// Currently loaded in Video Memory or AGP
-const WORD					tFlag_InAGP=2;		// Allocation is in AGP ( tFlag_InVidMem set separately )
-const WORD					tFlag_Valid=4;		// This CTexInfo has been allocated
-const WORD					tFlag_Alpha=8;		// Texture format has ALPHA (either keyed or full channel)
-const WORD					tFlag_InSysMem=16;	// Texture has been converted into system memory format
-const WORD					tFlag_LockRW=32;	// Set when a texture is locked for writing
-const WORD					tFlag_Preload=64;	// Preload this texture at the end of the current frame
-const WORD					tFlag_Locked=128;	// Set when texture locked
-const WORD					tFlag_Filler=256;	// Indicates a debug texture used to fill vidmem
-const WORD					tFlag_Detect=512;	// GameOS detected the format
+const USHORT					tFlag_InVidMem=1;	// Currently loaded in Video Memory or AGP
+const USHORT					tFlag_InAGP=2;		// Allocation is in AGP ( tFlag_InVidMem set separately )
+const USHORT					tFlag_Valid=4;		// This CTexInfo has been allocated
+const USHORT					tFlag_Alpha=8;		// Texture format has ALPHA (either keyed or full channel)
+const USHORT					tFlag_InSysMem=16;	// Texture has been converted into system memory format
+const USHORT					tFlag_LockRW=32;	// Set when a texture is locked for writing
+const USHORT					tFlag_Preload=64;	// Preload this texture at the end of the current frame
+const USHORT					tFlag_Locked=128;	// Set when texture locked
+const USHORT					tFlag_Filler=256;	// Indicates a debug texture used to fill vidmem
+const USHORT					tFlag_Detect=512;	// GameOS detected the format
 const int					tFlag_FormatShift = 10;	// Bits 10,11,12 used for format
-const WORD					FormatMask = (7<<tFlag_FormatShift);
-const WORD					tFlag_Special=8192;	// Special texture (font, chess, or color mipmap)
+const USHORT					FormatMask = (7<<tFlag_FormatShift);
+const USHORT					tFlag_Special=8192;	// Special texture (font, chess, or color mipmap)
 
-enum EGraphicsMemType { gmt_All, gmt_Original, gmt_SysMem, gmt_VidMem };
+typedef enum EGraphicsMemType { 
+	gmt_All, gmt_Original, gmt_SysMem, gmt_VidMem
+} EGraphicsMemType;
 
 //
 //	CTexInfo
@@ -93,23 +95,23 @@ enum EGraphicsMemType { gmt_All, gmt_Original, gmt_SysMem, gmt_VidMem };
 class CTexInfo
 {
 private:
-	WORD					m_nWidth;			// Width in texels of original image
-	WORD					m_nHeight;			// Height of original image
-	WORD					m_Flags;			// tFlag_...
-	WORD					m_Hints;			// gosHint_...
-	IDirectDrawSurface7*	m_pOriginalSurf;	// Original 32bpp image (if any)
-	IDirectDrawSurface7*	m_pSysMemSurf;		// Converted image in system memory
-	IDirectDrawSurface7*	m_pVidMemSurf;		// Image in VRAM or AGP
-	char *					m_pName;			// Name of texture (or file)
-	WORD					m_nLockedLevel;		// Level currently locked
-	WORD					m_NextOffset;		// Forward-only linked list (free or used)
+	USHORT					m_nWidth;			// Width in texels of original image
+	USHORT					m_nHeight;			// Height of original image
+	USHORT					m_Flags;			// tFlag_...
+	USHORT					m_Hints;			// gosHint_...
+	LPDIRECTDRAWSURFACE7	m_pOriginalSurf;	// Original 32bpp image (if any)
+	LPDIRECTDRAWSURFACE7	m_pSysMemSurf;		// Converted image in system memory
+	LPDIRECTDRAWSURFACE7	m_pVidMemSurf;		// Image in VRAM or AGP
+	PSTR 					m_pName;			// Name of texture (or file)
+	USHORT					m_nLockedLevel;		// Level currently locked
+	USHORT					m_NextOffset;		// Forward-only linked list (free or used)
 	gos_RebuildFunction		m_pRebuild;			// Application function to repopulate surface
-	void *					m_pInstance;		// Instance handle to pass to rebuild function
-	DWORD					m_nLastFrameUsed;	// Frame number when this texture was last used
-	DWORD					m_nLastTimeUsed;	// Value of TimeNo when this texture was last used
-	DWORD					m_nOriginalBytes;	// Size of m_pOriginalSurf (even if not allocated)
-	DWORD					m_nSysMemBytes;		// Size of m_pSysMemSurf (even if not allocated)
-	DWORD					m_nVidMemBytes;		// Size of m_pVidMemSurf (even if not allocated)
+	PVOID 					m_pInstance;		// Instance handle to pass to rebuild function
+	ULONG					m_nLastFrameUsed;	// Frame number when this texture was last used
+	ULONG					m_nLastTimeUsed;	// Value of TimeNo when this texture was last used
+	ULONG					m_nOriginalBytes;	// Size of m_pOriginalSurf (even if not allocated)
+	ULONG					m_nSysMemBytes;		// Size of m_pSysMemSurf (even if not allocated)
+	ULONG					m_nVidMemBytes;		// Size of m_pVidMemSurf (even if not allocated)
 
 // List management globals
 static bool					Initialized;		// Texture manager has been initialized
@@ -118,11 +120,11 @@ static int					NumPreload;			// Number of textures in PreloadList
 static CTexInfo	*			TexInfo;			// Array of CTexInfo for all textures
 static CTexInfo *			pFirstFreeTexture;	// Free linked list (using m_NextOffest)
 static CTexInfo *			pFirstUsedTexture;	// Used linked list (using m_NextOffest)
-static DWORD				FrameNo;			// Current Frame number (incremented by PreloadTextures())
-static DWORD				TimeNo;				// Count of setrenderstate calls for LRU
-static DWORD				AGPUsed;			// Bytes of AGP reserved (for debug limits)
+static ULONG				FrameNo;			// Current Frame number (incremented by PreloadTextures())
+static ULONG				TimeNo;				// Count of setrenderstate calls for LRU
+static ULONG				AGPUsed;			// Bytes of AGP reserved (for debug limits)
 static int					NumDummyTextures;	// number of valid textures in pDummyTex[]
-static IDirectDrawSurface7 *pDummyTex[1024];	// Video surfaces created to fill vidmem for debugger
+static LPDIRECTDRAWSURFACE7 pDummyTex[1024];	// Video surfaces created to fill vidmem for debugger
 static int					ScaleShift;			// 0 = no downscale, 1 = W/2,H/2, 2=W/4,H/4..
 static int					NumVidTextures;		// The number of textures currently in video+AGP
 static CTexInfo				MostRecentOriginal;	// A recently freed "original" - ony m_pOriginalSurf is valid
@@ -130,9 +132,9 @@ static CTexInfo				MostRecentSysMem;	// A recently freed "sysmem" - ony m_pSysMe
 
 public:
 	// Read-only operations
-	WORD					Width() { return m_nWidth; }
-	WORD					Height() { return m_nHeight; }
-	WORD					Hints() { return m_Hints; }
+	USHORT					Width() { return m_nWidth; }
+	USHORT					Height() { return m_nHeight; }
+	USHORT					Hints() { return m_Hints; }
 	bool					HasAlpha() { return (m_Flags & tFlag_Alpha)!=0; }
 	bool					IsLocked() { return (m_Flags & tFlag_Locked)!=0; }
 	bool					InVidMem() { return (m_Flags & tFlag_InVidMem)!=0; }
@@ -142,10 +144,10 @@ public:
 	bool					MipmapDisabled() { return (m_Hints & gosHint_DisableMipmap)!=0; }
 	bool					CanRebuild() { return m_pRebuild!=NULL; }
 	int						MipFilter() { return ( m_Hints / gosHint_MipmapFilter0 ) & 3; }
-	DWORD					Area() { return m_nWidth * m_nHeight; }
+	ULONG					Area() { return ULONG(m_nWidth * m_nHeight); }
 	int						MipMapLevels() { return (MipmapDisabled())?1:MipLevelsRequired(m_nWidth,m_nHeight); }
-	const char *			Name() { return m_pName; }
-	void *					pInstance() { return m_pInstance; }
+	PCSTR 					Name() { return m_pName; }
+	PVOID 					pInstance() { return m_pInstance; }
 	DDSURFACEDESC2 *		Description() { return &TextureDesc[Format()][(m_Hints&gosHint_Try32bpp)?1:0][(m_Hints&(gosHint_Compress0|gosHint_Compress1))/gosHint_Compress0]; }
 static bool					ManagerInitialized() { return Initialized; }
 	bool					ValidTexture() { return (CTexInfo::Initialized)&&(this>=TexInfo)&&(this-MaximumTextures<TexInfo)&&(m_Flags&tFlag_Valid); }
@@ -156,9 +158,9 @@ static bool					ManagerInitialized() { return Initialized; }
 	CTexInfo *				NextTexture() { return m_NextOffset?(this+m_NextOffset):NULL; }
 	gos_TextureFormat		Format() { return (gos_TextureFormat)((m_Flags&FormatMask)>>tFlag_FormatShift); }
 	bool					Used() { return m_nLastFrameUsed == FrameNo; }
-	WORD					ScaledHeightWidth( bool WantHeight );
-	WORD					ScaledWidth() { return ScaledHeightWidth(false); }
-	WORD					ScaledHeight() { return ScaledHeightWidth(true); }
+	USHORT					ScaledHeightWidth( bool WantHeight );
+	USHORT					ScaledWidth() { return ScaledHeightWidth(false); }
+	USHORT					ScaledHeight() { return ScaledHeightWidth(true); }
 	static int				GlobalScaleShift() { return ScaleShift; }
 	bool					SysMemSurfUsable();
 // Texture Update.cpp
@@ -177,26 +179,26 @@ static bool					ManagerInitialized() { return Initialized; }
 // Texture Create.cpp
 	// Fundamental new/init/delete of a CtexInfo
 	static CTexInfo *		Allocate();
-	void					Initialize( gos_TextureFormat Format, const char* FileName, BYTE* pBitmap, DWORD Size,
-								WORD Width, WORD Height, DWORD Hints, gos_RebuildFunction pFunc, void *pInstance );
+	void					Initialize( gos_TextureFormat Format, PCSTR FileName, PUCHAR pBitmap, ULONG Size,
+								USHORT Width, USHORT Height, ULONG Hints, gos_RebuildFunction pFunc, PVOID pInstance );
 	void					Free();
 
 // Texture Update.cpp	
 	// Rebuild / Reload / Convert / Upload as required to get a usable texture handle
-	DWORD					GetD3DTextureHandle(); // HW Rasterizer: VidMemSurf, SW Rasterizer: SysMemSurf
+	ULONG					GetD3DTextureHandle(); // HW Rasterizer: VidMemSurf, SW Rasterizer: SysMemSurf
 	// Altering the surface contents of a texture
-	void					Lock( DWORD MipMapWidth, bool ReadOnly, TEXTUREPTR* TextureInfo );
+	void					Lock( ULONG MipMapWidth, bool ReadOnly, TEXTUREPTR* TextureInfo );
 	void					Unlock();
 	void					InvalidateVidMem();	// mark vidmem as invalid and check if current texture
-	void					UpdateRect( DWORD DestLeft, DWORD DestTop, DWORD *Source, DWORD SourcePitch, DWORD Width,
-								DWORD Height );
+	void					UpdateRect( ULONG DestLeft, ULONG DestTop, ULONG *Source, ULONG SourcePitch, ULONG Width,
+								ULONG Height );
 	// Various setters
 	void					SetPreload();
-	void					SetName( const char *name );
+	void					SetName( PCSTR name );
 	void					SetUsed() { m_nLastFrameUsed = FrameNo; m_nLastTimeUsed = TimeNo++; }
 	// Active private routines used within the texture manager
 
-	// Notes on Get...( bool populate, WORD MipMapWidth=0 )
+	// Notes on Get...( bool populate, USHORT MipMapWidth=0 )
 	//		Get..() Allocates, and/or populates the different versions of the texture
 	//		Each function allocates the surface if required and if populate is true and the surface
 	//		contents are not already valid, copies/converts the contents from the prior level(s)
@@ -217,44 +219,44 @@ static bool					ManagerInitialized() { return Initialized; }
 // Texture Original.cpp
 	// Original surface
 public:
-	IDirectDrawSurface7*	GetOriginalSurf( bool populate, WORD MipMapWidth=0 );
+	LPDIRECTDRAWSURFACE7	GetOriginalSurf( bool populate, USHORT MipMapWidth=0 );
 private:
 	void					AllocateOriginal();	// Allocates original 32bpp surface
 	void					PopulateOriginal();	// Rebuilds or Reloads (assumes surface exists but is not valid)
-	void					Reload( BYTE *pData, DWORD Size, bool Detect ); // reloads 32bpp surface from file or pData
+	void					Reload( PUCHAR pData, ULONG Size, bool Detect ); // reloads 32bpp surface from file or pData
 	void					Rebuild();			// Calls rebuild function of app to re-populate the surface
 	void					FreeOriginal();		// Frees the original surface (assumes it exists and is ok to free)
-	void					DecodeImageLevel( const char *FileName, BYTE *pSourceData, DWORD Size, IDirectDrawSurface7 *pSurface );
+	void					DecodeImageLevel( PCSTR FileName, PUCHAR pSourceData, ULONG Size, LPDIRECTDRAWSURFACE7 pSurface );
 // Texture SysMem.cpp
 	// System Memory Surface
 public:
-	IDirectDrawSurface7*	GetSysMemSurf( bool populate, WORD MipMapWidth=0 );
+	LPDIRECTDRAWSURFACE7	GetSysMemSurf( bool populate, USHORT MipMapWidth=0 );
 private:
 	void					AllocateSysMem();	// Allocates (probably 16bpp) system memory surface
 	void					PopulateSysMem();	// (Assumes valid original) Converts the Original Level(s)
-	void					ConvertLevel( IDirectDrawSurface7 *dest, IDirectDrawSurface7 *source );
+	void					ConvertLevel( LPDIRECTDRAWSURFACE7 dest, LPDIRECTDRAWSURFACE7 source );
 												// ...Converts one level from original to sysmem
 	void					FreeSysMem();		// Frees the SysMem surface/chain (assumes it exists and is ok to free)
 // Mipmap.cpp
 	void					GenerateMipMaps();	// Filters top level of SysMem chain to all lower levels
 // Texture VidMem.cpp
 	// Video Memory or AGP Surface
-	IDirectDrawSurface7*	GetVidMemSurf( bool populate, WORD MipMapWidth=0 );
+	LPDIRECTDRAWSURFACE7	GetVidMemSurf( bool populate, USHORT MipMapWidth=0 );
 	bool					CreateTexture();	// Called by AllocateVidMem() to attempt texture creation
 	void					AllocateVidMem();	// Uses various techniques to allocate video memory
 	void					PopulateVidMem();	// Uploads level(s) from SysMem to VidMem/AGP
-	void					UploadLevel( IDirectDrawSurface7 *dest, IDirectDrawSurface7 *source );
+	void					UploadLevel( LPDIRECTDRAWSURFACE7 dest, LPDIRECTDRAWSURFACE7 source );
 public:
 	void					FreeVidMem();		// Frees the Vidmem Surface(s) (assumes it exists and is ok to free)
 private:
 
 	// Private helper function(s)
-	void					SetFormat( gos_TextureFormat Format ){m_Flags= (WORD)((m_Flags & ~FormatMask )
-																	| ( (WORD)(Format) << tFlag_FormatShift));}
-	IDirectDrawSurface7 *	FindTextureLevel( IDirectDrawSurface7 *pSurf, WORD MipMapWidth ); // Helper function
+	void					SetFormat( gos_TextureFormat Format ){m_Flags= (USHORT)((m_Flags & ~FormatMask )
+																	| ( (USHORT)(Format) << tFlag_FormatShift));}
+	LPDIRECTDRAWSURFACE7 	FindTextureLevel( LPDIRECTDRAWSURFACE7 pSurf, USHORT MipMapWidth ); // Helper function
 public:
-	static CTexInfo *		TextureHandleToPtr( DWORD Handle );
-	DWORD					TexturePointerToHandle();
+	static CTexInfo *		TextureHandleToPtr( ULONG Handle );
+	ULONG					TexturePointerToHandle();
 
 	static void				NewAGPLimit();		// called by debugger when AGP limit changes
 	static void				NewLocalLimit();	// called by debugger when local limit changes
@@ -269,48 +271,46 @@ private:
 
 	static void				PurgeTextures();	// removes all app textures and does flip's to let them go
 
-#ifdef LAB_ONLY
+#if defined(LAB_ONLY)
 	static char				LogString[MaximumTextureLogs][256];
 	static int				LogCount;			// 0..MaximumTextureLogs
 	static int				LogNext;			// index of next string to write to in circular log
 	static bool				Logging;
-	void					LogTextureEvent( char *description );
+	void					LogTextureEvent( PSTR description );
 public:
-	static char *			GetTextureEvent( int offset ) { return (offset>=LogCount)?(NULL):(LogString[(LogNext+MaximumTextureLogs-1-offset)%MaximumTextureLogs]); }
+	static PSTR 			GetTextureEvent( int offset ) { return (offset>=LogCount)?(NULL):(LogString[(LogNext+MaximumTextureLogs-1-offset)%MaximumTextureLogs]); }
 	static bool				LogEnable( bool enable = Logging ) { Logging = enable; return Logging; }
 #else
-	void					LogTextureEvent( char *description ) { ; }
+	void					LogTextureEvent( PSTR /*description*/ ) { ; }
 public:
-	static char *			GetTextureEvent( int offset ) { return NULL; }
-	static bool				LogEnable( bool enable = false ) { return false; }
+	static PSTR 			GetTextureEvent( int /*offset*/ ) { return NULL; }
+	static bool				LogEnable( bool /*enable = false*/ ) { return false; }
 #endif
 
 };
 
 // Texture management API
-inline void CheckPreloadTextures() { CTexInfo::PreloadTextures(); }
-inline void ReleaseTextureHeap( bool ReleaseSysmem ) { CTexInfo::ReleaseTextures(ReleaseSysmem); }
-inline void InitTextureManager() { CTexInfo::InitializeTextureManager(); }
-inline void DestroyTextureManager() { CTexInfo::DestroyTextureManager(); }
+inline void __stdcall CheckPreloadTextures(void) { CTexInfo::PreloadTextures(); }
+inline void __stdcall ReleaseTextureHeap( bool ReleaseSysmem ) { CTexInfo::ReleaseTextures(ReleaseSysmem); }
+inline void __stdcall InitTextureManager(void) { CTexInfo::InitializeTextureManager(); }
+inline void __stdcall DestroyTextureManager(void) { CTexInfo::DestroyTextureManager(); }
 
-DWORD GetTexturesUsed();
+ULONG __stdcall GetTexturesUsed(void);
 
-//
 // Statistics
-//
-extern DWORD TexturesUsed;
-extern DWORD TextureKUsed;
-extern DWORD TextureVKUsed;
-extern DWORD AlphaTextureKUsed;
-extern DWORD TexturesSwapped;
-extern DWORD TextureBytesPaged;
-extern DWORD TextureBytesPaged1;
-extern DWORD TexturesDestroyed;
-extern DWORD TotalTexMemoryAllocated;
-extern DWORD TexturesChanged;
-extern DWORD VidMemUsed;				// Number of textures actually allocated in video memory
-extern DWORD TexturesBumped;
+extern ULONG TexturesUsed;
+extern ULONG TextureKUsed;
+extern ULONG TextureVKUsed;
+extern ULONG AlphaTextureKUsed;
+extern ULONG TexturesSwapped;
+extern ULONG TextureBytesPaged;
+extern ULONG TextureBytesPaged1;
+extern ULONG TexturesDestroyed;
+extern ULONG TotalTexMemoryAllocated;
+extern ULONG TexturesChanged;
+extern ULONG VidMemUsed;				// Number of textures actually allocated in video memory
+extern ULONG TexturesBumped;
 extern float TextureAGPMegs;
 extern float TextureLocalMegs;
-extern DWORD TexturesLoaded;
-extern DWORD TexturesCreated;
+extern ULONG TexturesLoaded;
+extern ULONG TexturesCreated;


  ================================================
diff --git a/source/gameos/include/time.hpp b/source/gameos/include/time.hpp
index 8bb2207..5a02428 100755
--- a/source/gameos/include/time.hpp
+++ b/source/gameos/include/time.hpp
@@ -7,12 +7,12 @@
 //===========================================================================//
 
 
-void TimeManagerInstall();
-void StartTimeManager();
-void TimeManagerUpdate();
-void TimeManagerUninstall();
-void StartPauseTime();
-void EndPauseTime();
+void __stdcall TimeManagerInstall();
+void __stdcall StartTimeManager();
+void __stdcall TimeManagerUpdate();
+void __stdcall TimeManagerUninstall();
+void __stdcall StartPauseTime();
+void __stdcall EndPauseTime();
 
 extern DWORD WatchDogFrame;
 extern DWORD CurrentFrameNumber;


  ================================================
diff --git a/source/gameos/include/videoplayback.hpp b/source/gameos/include/videoplayback.hpp
index c3f9ca2..15507fa 100755
--- a/source/gameos/include/videoplayback.hpp
+++ b/source/gameos/include/videoplayback.hpp
@@ -1,4 +1,3 @@
-#pragma once
 //===========================================================================//
 // File:	 VideoPlayback.hpp												 //
 // Contents: Video Playback routines										 //
@@ -6,25 +5,26 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-typedef struct gos_Video
-{
+#pragma once
+
+typedef struct gos_Video {
 	public:
-		char *						m_lpPath;
+	PSTR						m_lpPath;
 		
 		static HGOSHEAP m_videoHeap;
-		IMultiMediaStream*			m_pMMStream;
-		IMediaStream*				m_pPrimaryVidStream;   
+	PIMULTIMEDIASTREAM			m_pMMStream;
+	PIMEDIASTREAM				m_pPrimaryVidStream;   
 		IBasicAudio*			   	m_pBasicAudio;
-		IDirectDrawMediaStream*   	m_pDDStream;
-		IDirectDrawSurface*			m_pSurface;
+	PIDIRECTDRAWMEDIASTREAM   	m_pDDStream;
+	LPDIRECTDRAWSURFACE			m_pSurface;
 		IDirectDrawStreamSample*  	m_pSample;
-		IDirectDrawSurface*			m_hDestSurf;
-		IDirectDrawSurface*			m_hSrcSurf;
+	LPDIRECTDRAWSURFACE			m_hDestSurf;
+	LPDIRECTDRAWSURFACE			m_hSrcSurf;
 //
 // Surface that is used to decompress the video to (DirectX 1 surface) and it's description
 //
-		IDirectDrawSurface*			m_pMMStreamSurface;
-		IDirectDrawSurface7*		m_pMMStreamSurface7;
+	LPDIRECTDRAWSURFACE			m_pMMStreamSurface;
+	LPDIRECTDRAWSURFACE7		m_pMMStreamSurface7;
 		DDSURFACEDESC2				m_pMMStreamSurfaceDesc;
 
 		gosVideo_PlayMode			m_videoStatus, m_videoPlayMode;
@@ -35,7 +35,7 @@ typedef struct gos_Video
 		float						m_scaleX, m_scaleY;
 		float						m_volume, m_panning;
 		
-		DWORD						m_texture;
+	ULONG						m_texture;
 
 		STREAM_TIME					m_duration;
 		STREAM_TIME					m_lastKnownTime;
@@ -43,42 +43,35 @@ typedef struct gos_Video
 
 	public:
 		gos_Video(char * path, bool texture);
-		~gos_Video();
+	~gos_Video(void);
 		bool
-			Update();
+		Update(void);
 		void
-			Pause();
+		Pause(void);
 		void
-			Continue();
+		Continue(void);
 		void 
-			Stop();
+		Stop(void);
 		void 
 			FF(double time);
 		void
-			Restore();
+		Restore(void);
 		void
-			Release();
+		Release(void);
 		void 
-			SetLocation(DWORD, DWORD);
+		SetLocation(ULONG, ULONG);
 		void
-			OpenMMStream(const char * pszFileName, IDirectDraw *pDD, IMultiMediaStream **ppMMStream);
+		OpenMMStream(PCSTR pszFileName, IDirectDraw* pDD, IMultiMediaStream** ppMMStream);
 }gos_Video;			
 
-void VideoManagerInstall();
-
-void VideoManagerPause();
-void VideoManagerContinue();
-
-void VideoManagerRelease();
-void VideoManagerRestore();
-
-void VideoManagerUninstall();
-
-void VideoManagerUpdate();
-
-void VideoManagerFF(double sec);
-
-void OpenMMStream( const char * pszFileName, IDirectDraw *pDD, IMultiMediaStream **ppMMStream, IBasicAudio ** ppBasicAudio );
-
+void __stdcall VideoManagerInstall(void);
+void __stdcall VideoManagerPause(void);
+void __stdcall VideoManagerContinue(void);
+void __stdcall VideoManagerRelease(void);
+void __stdcall VideoManagerRestore(void);
+void __stdcall VideoManagerUninstall(void);
+void __stdcall VideoManagerUpdate(void);
+void __stdcall VideoManagerFF(double sec);
+void __stdcall OpenMMStream( PCSTR  pszFileName, IDirectDraw* pDD, IMultiMediaStream** ppMMStream, IBasicAudio** ppBasicAudio );
 
 


  ================================================
diff --git a/source/gameos/include/windows.hpp b/source/gameos/include/windows.hpp
index 9787b07..bb6a7ca 100755
--- a/source/gameos/include/windows.hpp
+++ b/source/gameos/include/windows.hpp
@@ -8,12 +8,12 @@
 
 #include "Globals.hpp"
 
-char* GetWindowsMessage( DWORD uMsg,WPARAM wParam,LPARAM lParam );
-void InitializeWindows();
-void DestroyWindows();
-bool AlreadyRunning();
-void SystemCheck();
-void Update();
+PSTR __stdcall GetWindowsMessage( ULONG uMsg,WPARAM wParam,LPARAM lParam );
+void __stdcall InitializeWindows();
+void __stdcall DestroyWindows();
+bool __stdcall AlreadyRunning();
+void __stdcall SystemCheck();
+void __stdcall Update();
 
 enum Status { BeforeInit,Uninitialized, GameInit, Running, Paused, AfterExit };
 
@@ -21,7 +21,7 @@ extern HDC			DesktopDC;
 extern HWND			hWindow;
 extern HINSTANCE	hInstance;
 extern WNDCLASS		wndClass;
-extern char*		CommandLine;
+extern PSTR 		CommandLine;
 extern MSG			msg;
 extern Status		status;
 extern BOOL			fullScreen;
@@ -31,64 +31,59 @@ extern int			heightY;
 extern int			WindowStartX;
 extern int			WindowStartY;
 extern bool			WindowsNT;
-extern DWORD		HitScrollLock;
-extern DWORD		ForceReStart;
-extern DWORD		DesktopBpp;
-extern DWORD		DesktopRes;
+extern ULONG		HitScrollLock;
+extern ULONG		ForceReStart;
+extern ULONG		DesktopBpp;
+extern ULONG		DesktopRes;
 extern bool			PerfCounters;
 extern bool			WindowClosed;
-//
+
 // Libraries.cpp routines
-//
-void InitLibraries();		// Load all libraries GOS depends upon
-void DestroyLibraries();	// Unload any libraries GOS loaded
-char* GetDirectXVersion();	// Returns a string describing the current version of DirectX
+void __stdcall InitLibraries();		// Load all libraries GOS depends upon
+void __stdcall DestroyLibraries();	// Unload any libraries GOS loaded
+PSTR __stdcall GetDirectXVersion();	// Returns a string describing the current version of DirectX
 
 
-//
 // Functions only in Win98/2000
-//
-typedef BOOL (WINAPI* T_GetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation );
-typedef EXECUTION_STATE (WINAPI* T_SetThreadExecutionState)( EXECUTION_STATE esFlags );
-typedef BOOL (WINAPI* T_GetDiskFreeSpaceEx)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
+typedef BOOL (__stdcall* T_GetFileAttributesEx)( PCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, PVOID lpFileInformation );
+typedef EXECUTION_STATE (__stdcall* T_SetThreadExecutionState)( EXECUTION_STATE esFlags );
+typedef BOOL (__stdcall* T_GetDiskFreeSpaceEx)(PCSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
+
 extern T_SetThreadExecutionState _SetThreadExecutionState;
 extern T_GetFileAttributesEx _GetFileAttributesEx;
 extern T_GetDiskFreeSpaceEx _GetDiskFreeSpaceEx;
 
-extern BOOL (WINAPI* _EmptyWorkingSet)(HANDLE);
-extern BOOL (WINAPI* _InitializeProcessForWsWatch)(HANDLE);
-extern BOOL (WINAPI* _GetWsChanges)(HANDLE,PPSAPI_WS_WATCH_INFORMATION,DWORD);
-extern DWORD (WINAPI* _GetMappedFileName)(HANDLE,LPVOID,LPTSTR,DWORD);
-
-
+extern BOOL (__stdcall* _EmptyWorkingSet)(HANDLE);
+extern BOOL (__stdcall* _InitializeProcessForWsWatch)(HANDLE);
+extern BOOL (__stdcall* _GetWsChanges)(HANDLE,PPSAPI_WS_WATCH_INFORMATION,ULONG);
+extern ULONG (__stdcall* _GetMappedFileName)(HANDLE,PVOID,LPTSTR,ULONG);
 
-extern HRESULT (WINAPI* _DirectDrawCreateEx)( GUID* lpGUID, void** lplpDD, REFIID iid, IUnknown* pUnkOuter ); 
-extern HRESULT (WINAPI* _DirectDrawEnumerate)( LPDDENUMCALLBACK lpCallback, LPVOID lpContext );
-extern HRESULT (WINAPI* _DirectDrawEnumerateEx)( LPDDENUMCALLBACKEX lpCallback, LPVOID lpContext, DWORD Flags );
-extern HRESULT (WINAPI* _DirectInputCreate)( HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUT * lplpDirectInput, LPUNKNOWN punkOuter );
-extern HRESULT (WINAPI* _DirectSoundCreate)( LPGUID lpGuid, LPDIRECTSOUND * ppDS, LPUNKNOWN  pUnkOuter );
-extern HRESULT (WINAPI* _DirectInputCreateEx)( HINSTANCE hinst, DWORD dwVersion, REFIID refID, void ** lplpDirectInput, LPUNKNOWN punkOuter );
-extern HRESULT (WINAPI* _DirectSoundEnumerate)( LPDSENUMCALLBACK lpDSEnumCallback, LPVOID lpContext );
-extern HWND (WINAPI* _CallmyHelp)( HWND hWindow, HINSTANCE hInst, bool Window, DWORD HelpItem );
-extern void (WINAPI* _FreeHlpLib)();
-extern DWORD (WINAPI* _AMGetErrorText)( HRESULT hr, TCHAR *pBuffer, DWORD MaxLen );
+DirectDrawCreateEx
 
+extern HRESULT (__stdcall* _DirectDrawCreateEx)( GUID* lpGUID, void** lplpDD, const IID* iid, LPUNKNOWN pUnkOuter ); 
+extern HRESULT (__stdcall* _DirectDrawEnumerate)( LPDDENUMCALLBACK pCallback, PVOID lpContext );
+extern HRESULT (__stdcall* _DirectDrawEnumerateEx)( LPDDENUMCALLBACKEX lpCallback, PVOID lpContext, ULONG Flags );
+extern HRESULT (__stdcall* _DirectInputCreate)( HINSTANCE hinst, ULONG dwVersion, LPDIRECTINPUT * lplpDirectInput, LPUNKNOWN punkOuter );
+extern HRESULT (__stdcall* _DirectSoundCreate)( LPGUID lpGuid, LPDIRECTSOUND * ppDS, LPUNKNOWN  pUnkOuter );
+extern HRESULT (__stdcall* _DirectInputCreateEx)( HINSTANCE hinst, ULONG dwVersion, const IID* refID, void** lplpDirectInput, LPUNKNOWN punkOuter );
+extern HRESULT (__stdcall* _DirectSoundEnumerate)( LPDSENUMCALLBACK lpDSEnumCallback, PVOID lpContext );
+extern HWND (__stdcall* _CallmyHelp)( HWND hWindow, HINSTANCE hInst, bool Window, ULONG HelpItem );
+extern void (__stdcall* _FreeHlpLib)();
+extern ULONG (__stdcall* _AMGetErrorText)( HRESULT hr, TCHAR *pBuffer, ULONG MaxLen );
 
-//
 // WinMain.cpp
-//
 extern float frameRate;
 extern char AssetsDirectory1[MAX_PATH];
 extern char AssetsDirectory2[MAX_PATH];
 extern char ImageHelpPath[MAX_PATH];
 extern char ApplicationName[256];
-extern void DoGame();
 extern void RestartGameOS();
 extern char RegistryKey[256];
-extern void gos_UpdateDisplay( bool Everything );
-extern DWORD ThreadId;
-extern DWORD SkipRendering;
+extern ULONG ThreadId;
+extern ULONG SkipRendering;
 extern bool gNoBlade;
+extern void __stdcall DoGame(void);
+extern void __stdcall gos_UpdateDisplay( bool Everything );
 
 
 


  ================================================
diff --git a/source/gameos/lib/extract.cmd b/source/gameos/lib/extract.cmd
old mode 100644
new mode 100755
index ce0251f..f5aa4cb
--- a/source/gameos/lib/extract.cmd
+++ b/source/gameos/lib/extract.cmd
@@ -21,6 +21,10 @@
 ::         mfcplatform.lib
 ::         zlib.lib
 
+::
+:: Note: Object files with spaces in the name will not be found by the loop
+::
+
 @set CURDIR=%CD%
 @set VSINSTALLDIR=E:\Development\msdev\VS2013\
 @set VCINSTALLDIR=%VSINSTALLDIR%VC\
@@ -28,6 +32,8 @@
 @set CPUDIR=x86
 @set LIBDIR=debug
 call :extractlibs
+call :movepngzlib
+goto :end
 
 :: ========================================================================
 :extractlibs
@@ -43,9 +49,75 @@ call :extractlibs
 @for /F "eol=;" %%i in ( libs.txt ) do (
     @pushd %CPUDIR%\%%i
     @echo Exctracting from %LIBDIR%\%%i.lib...
-    @for /F %%y in ( ..\%%i.txt ) do  @if not exist %%y (@link.exe -lib -extract:%%y "..\..\%LIBDIR%\%%i.lib" > nul 2>&1)
+    @for /F %%y in ( ..\%%i.txt ) do  @if not exist %%y (@link.exe -lib -extract:"%%y" "..\..\%LIBDIR%\%%i.lib"  > nul 2>&1)
+    @popd
+)
+:: well the library names >.<
+@echo dealing with weird object file names...
+
+@pushd %CPUDIR%\gameos
+@set GAMEOSLIB=..\..\%LIBDIR%\gameos.lib
+@set FILE1=3d_tl.obj
+@set FILE2=texture_api.obj
+@set FILE3=texture_convert.obj
+@set FILE4=texture_create.obj
+@set FILE5=texture_format.obj
+@set FILE6=texture_manager.obj
+@set FILE7=texture_mipmap.obj
+@set FILE8=texture_original.obj
+@set FILE9=texture_sysmem.obj
+@set FILE10=texture_update.obj
+@set FILE11=texture_vidmem.obj
+@set FILE12=sound_api.obj
+@set FILE13=sound_ds3dchannel.obj
+@set FILE14=sound_ds3dmixer.obj
+@set FILE15=sound_renderer.obj
+@set FILE16=sound_resource.obj
+
+@if not exist %FILE1%  (@link.exe -lib -extract:".\Debug\3D T&L.obj"            %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE2%  (@link.exe -lib -extract:".\Debug\Texture API.obj"       %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE3%  (@link.exe -lib -extract:".\Debug\Texture Convert.obj"   %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE4%  (@link.exe -lib -extract:".\Debug\Texture Create.obj"    %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE5%  (@link.exe -lib -extract:".\Debug\Texture Format.obj"    %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE6%  (@link.exe -lib -extract:".\Debug\Texture Manager.obj"   %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE7%  (@link.exe -lib -extract:".\Debug\Texture MipMap.obj"    %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE8%  (@link.exe -lib -extract:".\Debug\Texture Original.obj"  %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE9%  (@link.exe -lib -extract:".\Debug\Texture SysMem.obj"    %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE10% (@link.exe -lib -extract:".\Debug\Texture Update.obj"    %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE11% (@link.exe -lib -extract:".\Debug\Texture VidMem.obj"    %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE12% (@link.exe -lib -extract:".\Debug\Sound API.obj"         %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE13% (@link.exe -lib -extract:".\Debug\Sound DS3DChannel.obj" %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE14% (@link.exe -lib -extract:".\Debug\Sound DS3DMixer.obj"   %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE15% (@link.exe -lib -extract:".\Debug\Sound Renderer.obj"    %GAMEOSLIB%  > nul 2>&1)
+@if not exist %FILE16% (@link.exe -lib -extract:".\Debug\Sound Resource.obj"    %GAMEOSLIB%  > nul 2>&1)
+
+@ren "3D T&L.obj"                   %FILE1%
+@ren "Texture API.obj"              %FILE2%
+@ren "Texture Convert.obj"          %FILE3%
+@ren "Texture Create.obj"           %FILE4%
+@ren "Texture Format.obj"           %FILE5%
+@ren "Texture Manager.obj"          %FILE6%
+@ren "Texture MipMap.obj"           %FILE7%
+@ren "Texture Original.obj"         %FILE8%
+@ren "Texture SysMem.obj"           %FILE9%
+@ren "Texture Update.obj"           %FILE10%
+@ren "Texture VidMem.obj"           %FILE11%
+@ren "Sound API.obj"                %FILE12%
+@ren "Sound DS3DChannel.obj"        %FILE13%
+@ren "Sound DS3DMixer.obj"          %FILE14%
+@ren "Sound Renderer.obj"           %FILE15%
+@ren "Sound Resource.obj"           %FILE16%
+
     @popd
+goto :eof
+
+:movepngzlib
+@echo moving %CPUDIR% objects...
+@if not exist "%CPUDIR%\gameos\pngzlib" (@md %CPUDIR%\gameos\pngzlib)
+@for /F "eol=;" %%i in ( pngzlib.txt )  do (
+    @if exist "%CPUDIR%\gameos\%%i"   (@move %CPUDIR%\gameos\%%i %CPUDIR%\gameos\pngzlib\%%i  > nul 2>&1)
 )
+goto :eof
 
 :: ========================================================================
 


  ================================================
diff --git a/source/gameos/lib/libs.txt b/source/gameos/lib/libs.txt
old mode 100644
new mode 100755


  ================================================
diff --git a/source/gameos/lib/x86/dllplatform.txt b/source/gameos/lib/x86/dllplatform.txt
old mode 100644
new mode 100755


  ================================================
diff --git a/source/gameos/lib/x86/gameos.txt b/source/gameos/lib/x86/gameos.txt
old mode 100644
new mode 100755


  ================================================
diff --git a/source/gameos/lib/x86/gameplatform.txt b/source/gameos/lib/x86/gameplatform.txt
old mode 100644
new mode 100755


  ================================================
diff --git a/source/gameos/lib/x86/mfcplatform.txt b/source/gameos/lib/x86/mfcplatform.txt
old mode 100644
new mode 100755


  ================================================
diff --git a/source/gui/aanim.cpp b/source/gui/aanim.cpp
index c12d7c2..e474b61 100755
--- a/source/gui/aanim.cpp
+++ b/source/gui/aanim.cpp
@@ -1,10 +1,11 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include "aanim.h"
-#include "mclib.h"
-#include "Estring.h"
+#include <mclib.h>
+#include "estring.h"
 
 extern float frameRate;
 


  ================================================
diff --git a/source/gui/aanimobject.cpp b/source/gui/aanimobject.cpp
index 79115b5..5557f95 100755
--- a/source/gui/aanimobject.cpp
+++ b/source/gui/aanimobject.cpp
@@ -1,12 +1,14 @@
-#define AANIMOBJECT_CPP
 /*************************************************************************************************\
 aAnimObject.cpp			: Implementation of the aAnimObject component.
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#define AANIMOBJECT_CPP
+
+#include "stdafx.h"
 
-#include "aAnimObject.h"
+#include "aanimobject.h"
 #include "mclib.h"
 
 aAnimObject::aAnimObject(  )


  ================================================
diff --git a/source/gui/aanimobject.h b/source/gui/aanimobject.h
index 7633e4a..b51098e 100755
--- a/source/gui/aanimobject.h
+++ b/source/gui/aanimobject.h
@@ -1,18 +1,18 @@
-#ifndef AANIMOBJECT_H
-#define AANIMOBJECT_H
 /*************************************************************************************************\
 aAnimObject.h			: Interface for the aAnimObject component of the GUI library.
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#ifndef AANIMOBJECT_H
+#define AANIMOBJECT_H
 
 #ifndef ASYSTEM_H
-#include "aSystem.h"
+#include "asystem.h"
 #endif
 
 #ifndef AANIM_H
-#include "aAnim.h"
+#include "aanim.h"
 #endif
 
 //*************************************************************************************************


  ================================================
diff --git a/source/gui/abutton.cpp b/source/gui/abutton.cpp
index 587b1aa..59221d1 100755
--- a/source/gui/abutton.cpp
+++ b/source/gui/abutton.cpp
@@ -1,12 +1,13 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
-#include "aButton.h"
-#include "aFont.h"
+#include "abutton.h"
+#include "afont.h"
 #include "mclib.h"
 #include <windows.h>
-#include "soundSys.h"
+#include "soundsys.h"
 
 extern SoundSystem *sndSystem;
 


  ================================================
diff --git a/source/gui/aedit.cpp b/source/gui/aedit.cpp
index 2329f02..e499cb8 100755
--- a/source/gui/aedit.cpp
+++ b/source/gui/aedit.cpp
@@ -5,6 +5,7 @@ aEdit.cpp			: Implementation of the aEdit component of the GUI library.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "aEdit.h"
 #include "userInput.h"


  ================================================
diff --git a/source/gui/afont.cpp b/source/gui/afont.cpp
index ba7629c..032daff 100755
--- a/source/gui/afont.cpp
+++ b/source/gui/afont.cpp
@@ -1,6 +1,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include "afont.h"
 #include "mclib.h"


  ================================================
diff --git a/source/gui/alistbox.cpp b/source/gui/alistbox.cpp
index e469c53..94a145a 100755
--- a/source/gui/alistbox.cpp
+++ b/source/gui/alistbox.cpp
@@ -1,20 +1,21 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef ASYSTEM_H
-#include "aSystem.h"
+#include "asystem.h"
 #endif
 
 #ifndef AFONT_H
-#include "aFont.h"
+#include "afont.h"
 #endif
 
 #ifndef ALISTBOX_H
-#include "aListBox.h"
+#include "alistbox.h"
 #endif
 
-#include "soundSys.h"
+#include "soundsys.h"
 
 extern SoundSystem *sndSystem;
 
@@ -139,7 +140,8 @@ void aListBox::update()
 			::helpTextID = helpID;
 		}
 
-		for ( int i = 0; i < itemCount; i++ )
+		int i;
+		for ( i = 0; i < itemCount; i++ )
 		{
 			if ( bInside &&
 				items[i]->pointInside(mouseX, mouseY) && items[i]->isShowing()
@@ -202,10 +204,6 @@ void aListBox::update()
 			items[prevCheck]->setCheck( 0 );
 		}
 	}
-
-	
-
-
 }
 
 	


  ================================================
diff --git a/source/gui/ascroll.cpp b/source/gui/ascroll.cpp
index 0839e09..521b400 100755
--- a/source/gui/ascroll.cpp
+++ b/source/gui/ascroll.cpp
@@ -1,6 +1,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include "mclib.h"
 


  ================================================
diff --git a/source/gui/asystem.cpp b/source/gui/asystem.cpp
index 1ebb6c4..c7edc77 100755
--- a/source/gui/asystem.cpp
+++ b/source/gui/asystem.cpp
@@ -1,13 +1,14 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
-#include "McLib.h"
-#include "aSystem.h"
+#include "mclib.h"
+#include "asystem.h"
 #include "packet.h"
 #include "afont.h"
 #include "paths.h"
-#include "userInput.h"
+#include "userinput.h"
 
 
 long helpTextID = 0;
@@ -384,7 +385,8 @@ void aObject::moveToNoRecurse(long xPos, long yPos )
 
 void aObject::move( float offsetX, float offsetY )
 {
-	for ( int i = 0; i < 4; i++ )
+	int i;
+	for ( i = 0; i < 4; i++ )
 	{
 		location[i].x += offsetX;
 		location[i].y += offsetY;


  ================================================
diff --git a/source/gui/asystem.h b/source/gui/asystem.h
index ede5a2c..36ae7e7 100755
--- a/source/gui/asystem.h
+++ b/source/gui/asystem.h
@@ -13,8 +13,8 @@ class InterfaceObject;
 
 #include <gameos.hpp>
 
-#include "EString.h"
-#include "aFont.h"
+#include "estring.h"
+#include "afont.h"
 
 #define MAX_CHILDREN 64
 
@@ -41,8 +41,7 @@ class InterfaceObject;
 #define aMSG_BUTTONCLICKED			111
 #define aMSG_SELCHANGED		112
 
-typedef enum
-{
+typedef enum WINDOW_ID {
 	UNDEFINEDWINDOW = -1,
 	GENERIC = 1,
 	STATIC,


  ================================================
diff --git a/source/gui/logisticsscreen.cpp b/source/gui/logisticsscreen.cpp
index 25dcb91..004ec8c 100755
--- a/source/gui/logisticsscreen.cpp
+++ b/source/gui/logisticsscreen.cpp
@@ -5,14 +5,15 @@ LogisticsScreen.cpp			: Implementation of the LogisticsScreen component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================// 
 \*************************************************************************************************/
+#include "stdafx.h"
 
-#include "LogisticsScreen.h"
-#include "IniFile.h"
-#include "aSystem.h"
-#include "aButton.h"
-#include "aEdit.h"
+#include "logisticsscreen.h"
+#include "inifile.h"
+#include "asystem.h"
+#include "abutton.h"
+#include "aedit.h"
 #include "err.h"
-#include "aAnimObject.h"
+#include "aanimobject.h"
 
 extern long helpTextID;
 extern long helpTextHeaderID;
@@ -258,7 +259,8 @@ aRect* LogisticsScreen::getRect( long who )
 //-------------------------------------------------------------------------------------------------
 void LogisticsScreen::update()
 {
-	for ( int i = 0; i < staticCount; i++ )
+	int i;
+	for ( i = 0; i < staticCount; i++ )
 	{
 		statics[i].update();
 	}
@@ -335,7 +337,8 @@ void LogisticsScreen::render()
 {
 	if ( !isShowing() )
 		return;
-	for (int i = 0; i < rectCount; i++ )
+	int i;
+	for ( i = 0; i < rectCount; i++ )
 	{
 		if ( !rects[i].bOutline && 
 			( (rects[i].getColor() & 0xff000000) == 0xff000000 ) )
@@ -355,7 +358,7 @@ void LogisticsScreen::render()
 	// transparencies after statics
 	for ( i = 0; i < rectCount; i++ )
 	{
-		if ( rects[i].getColor() & 0xff000000 != 0xff000000 )
+		if ( (rects[i].getColor() & 0xff000000) != 0xff000000 )
 			rects[i].render();
 	}
 
@@ -413,8 +416,8 @@ void LogisticsScreen::render( int xOffset, int yOffset )
 {
 	if ( !isShowing() )
 		return;
-	
-	for (int i = 0; i < rectCount; i++ )
+	int i;
+	for ( i = 0; i < rectCount; i++ )
 	{
 		if ( !rects[i].bOutline&& 
 			( (rects[i].getColor() & 0xff000000) == 0xff000000 ) )
@@ -590,7 +593,8 @@ void  LogisticsScreen::moveTo( long xPos, long yPos )
 
 void  LogisticsScreen::move( long xOffset, long yOffset )
 {
-	for (int i = 0; i < rectCount; i++ )
+	int i;
+	for ( i = 0; i < rectCount; i++ )
 	{
 		rects[i].move( xOffset, yOffset );
 	}
@@ -622,7 +626,8 @@ void  LogisticsScreen::move( long xOffset, long yOffset )
 
 bool	LogisticsScreen::inside( long x, long y)
 {
-	for ( int i = 0; i < staticCount; i++ )
+	int i;
+	for ( i = 0; i < staticCount; i++ )
 	{
 		if ( statics[i].pointInside( x, y ) )
 			return true;
@@ -653,8 +658,6 @@ bool	LogisticsScreen::inside( long x, long y)
 	}
 
 		return false;
-
-	return false;
 }
 
 void LogisticsScreen::begin()


  ================================================
diff --git a/source/initial_preparations.txt b/source/initial_preparations.txt
old mode 100644
new mode 100755


  ================================================
diff --git a/source/mc2res/mc2res.cpp b/source/mc2res/mc2res.cpp
index 18daf90..3716014 100755
--- a/source/mc2res/mc2res.cpp
+++ b/source/mc2res/mc2res.cpp
@@ -6,9 +6,9 @@
 //
 #include <windows.h>
 
-BOOL APIENTRY DllMain( HANDLE hModule, 
-                       DWORD  ul_reason_for_call, 
-                       LPVOID lpReserved
+BOOL APIENTRY DllMain( HANDLE /*hModule*/, 
+                       DWORD  /*ul_reason_for_call*/, 
+                       LPVOID /*lpReserved*/
 					 )
 {
     return TRUE;


  ================================================
diff --git a/source/mc2res/resource.h b/source/mc2res/resource.h
index 4712443..8e3c90d 100755
--- a/source/mc2res/resource.h
+++ b/source/mc2res/resource.h
@@ -1,9 +1,5 @@
-//===========================================================================//
-// Copyright (C) Microsoft Corporation. All rights reserved.                 //
-//===========================================================================//
-
 //{{NO_DEPENDENCIES}}
-// Microsoft Developer Studio generated include file.
+// Microsoft Visual C++ generated include file.
 // Used by mc2res.rc
 //
 #define IDNEXT                          3


  ================================================
diff --git a/source/mclib/abldbug.cpp b/source/mclib/abldbug.cpp
index 9a95241..ae92d5f 100755
--- a/source/mclib/abldbug.cpp
+++ b/source/mclib/abldbug.cpp
@@ -6,9 +6,10 @@
 //								ABLDBUG.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdlib.h>
-#include <string.h>
+//#include <stdlib.h>
+//#include <string.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"


  ================================================
diff --git a/source/mclib/abldecl.cpp b/source/mclib/abldecl.cpp
index 5c0e90b..89166f2 100755
--- a/source/mclib/abldecl.cpp
+++ b/source/mclib/abldecl.cpp
@@ -6,10 +6,11 @@
 //								ABLDECL.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
+//#include <string.h>
+//#include <stdio.h>
+//#include <stdlib.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"


  ================================================
diff --git a/source/mclib/ablenv.cpp b/source/mclib/ablenv.cpp
index ff0109a..b41c820 100755
--- a/source/mclib/ablenv.cpp
+++ b/source/mclib/ablenv.cpp
@@ -6,10 +6,11 @@
 //								ABLENV.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <string.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"
@@ -287,7 +288,8 @@ void UserFile::write (char* s) {
 UserFile* UserFile::getNewFile (void) {
 
 	long fileHandle = -1;
-	for (long i = 0; i < MAX_USER_FILES; i++)
+	long i;
+	for (i = 0; i < MAX_USER_FILES; i++)
 		if (!files[i]->inUse) {
 			fileHandle = i;
 			break;
@@ -600,7 +602,7 @@ void ABLModule::read (ABLFile* moduleFile) {
 	else {
 		char tempName[1024];
 		moduleFile->readString((unsigned char*)tempName);
-		long ignore = moduleFile->readLong();
+		//long ignore = moduleFile->readLong();
 	}
 
 	char stateName[256];
@@ -1320,12 +1322,13 @@ void buildRoutineList (SymTableNodePtr curSymbol, ModuleInfo* moduleInfo) {
 
 void ABLModule::getInfo (ModuleInfo* moduleInfo) {
 
+	long i;
 	strcpy(moduleInfo->name, name);
 	strcpy(moduleInfo->fileName, ModuleRegistry[handle].fileName);
 
 	moduleInfo->numRoutines = 0;
 	buildRoutineList(ModuleRegistry[handle].moduleIdPtr->defn.info.routine.localSymTable, moduleInfo);
-	for (long i = 0; i < moduleInfo->numRoutines; i++)
+	for (i = 0; i < moduleInfo->numRoutines; i++)
 		moduleInfo->totalCodeSegmentSize += moduleInfo->routineInfo[i].codeSegmentSize;
 
 	moduleInfo->numStaticVars = ModuleRegistry[handle].numStaticVars;
@@ -1346,10 +1349,11 @@ void ABLModule::getInfo (ModuleInfo* moduleInfo) {
 
 void ABLModule::destroy (void) {
 
+	long i;
 	if ((id > -1) && ModuleInstanceRegistry) {
 		//-----------------------------------------------
 		// It's on the active registry, so pull it off...
-		for (long i = 0; i < NumModuleInstances; i++)
+		for (i = 0; i < NumModuleInstances; i++)
 			if (ModuleInstanceRegistry[i] == this) {
 				ModuleInstanceRegistry[i] = ModuleInstanceRegistry[NumModuleInstances - 1];
 				ModuleInstanceRegistry[NumModuleInstances - 1] = NULL;
@@ -1381,10 +1385,11 @@ void ABLModule::destroy (void) {
 
 void ABLi_saveEnvironment (ABLFile* ablFile) {
 
+	long i;
 	ablFile->writeLong(numLibrariesLoaded);
 	ablFile->writeLong(NumModulesRegistered);
 	ablFile->writeLong(NumModules);
-	for (long i = 0; i < NumModulesRegistered; i++) {
+	for (i = 0; i < NumModulesRegistered; i++) {
 		ablFile->writeString(ModuleRegistry[i].fileName);
 		ablFile->writeByte(NULL);
 	}
@@ -1410,8 +1415,9 @@ void ABLi_loadEnvironment (ABLFile* ablFile, bool malloc) {
 	long numLibs = ablFile->readLong();
 	long numModsRegistered = ablFile->readLong();
 	long numMods = ablFile->readLong();
+	long i;
 
-	for (long i = 0; i < numLibs; i++) {
+	for (i = 0; i < numLibs; i++) {
 		unsigned char fileName[1024];
 		long result = ablFile->readString(fileName);
 		if (!result) {
@@ -1448,7 +1454,7 @@ void ABLi_loadEnvironment (ABLFile* ablFile, bool malloc) {
 			}
 		}
 	}
-	long mark = ablFile->readLong();
+	//long mark = ablFile->readLong();
 	for (i = 0; i < eternalOffset; i++) {
 		StackItemPtr dataPtr = (StackItemPtr)stack + i;
 		if (EternalVariablesSizes[i] > 0)


  ================================================
diff --git a/source/mclib/ablerr.cpp b/source/mclib/ablerr.cpp
index 90d53b1..d666db0 100755
--- a/source/mclib/ablerr.cpp
+++ b/source/mclib/ablerr.cpp
@@ -6,9 +6,10 @@
 //								ABLERR.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdio.h>
-#include <stdlib.h>
+//#include <stdio.h>
+//#include <stdlib.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"
@@ -152,6 +153,7 @@ void ABL_Fatal (long errCode, char* s) {
 
 void ABL_Assert (bool test, long errCode, char* s) {
 
+	test; errCode; s;
 #ifdef _DEBUG
 	if (!test)
 		ABLFatalCallback(errCode, s);


  ================================================
diff --git a/source/mclib/ablerr.h b/source/mclib/ablerr.h
index b7f860e..29e706d 100755
--- a/source/mclib/ablerr.h
+++ b/source/mclib/ablerr.h
@@ -15,7 +15,7 @@
 #define	MAX_SYNTAX_ERRORS		1 //20
 #define	MAXLEN_ERROR_MESSAGE	256
 
-#pragma warning( disable : 4514 )  
+//#pragma warning( disable : 4514 )  
 
 typedef enum {
 	ABL_ERR_SYNTAX_NONE,									// 0


  ================================================
diff --git a/source/mclib/ablexec.cpp b/source/mclib/ablexec.cpp
index 6c3cba7..08a8c5e 100755
--- a/source/mclib/ablexec.cpp
+++ b/source/mclib/ablexec.cpp
@@ -6,10 +6,11 @@
 //								ABLEXEC.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <string.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"
@@ -115,7 +116,7 @@ void crunchToken (void) {
 	if (codeBufferPtr >= (codeBuffer + MaxCodeBufferSize - 100))
 		syntaxError(ABL_ERR_SYNTAX_CODE_SEGMENT_OVERFLOW);
 	else {
-		*codeBufferPtr = curToken;
+		*codeBufferPtr = (char)curToken;
 		codeBufferPtr++;
 	}
 }
@@ -560,7 +561,8 @@ void routineExit (SymTableNodePtr routineIdPtr) {
 	//-----------------------------------------
 	// De-alloc parameters & local variables...
 
-	for (SymTableNodePtr idPtr = (SymTableNodePtr)(routineIdPtr->defn.info.routine.params);
+	SymTableNodePtr idPtr;
+	for (idPtr = (SymTableNodePtr)(routineIdPtr->defn.info.routine.params);
 		 idPtr != NULL;
 		 idPtr = idPtr->next)
 		freeLocal(idPtr);


  ================================================
diff --git a/source/mclib/ablexpr.cpp b/source/mclib/ablexpr.cpp
index c036719..8f768a7 100755
--- a/source/mclib/ablexpr.cpp
+++ b/source/mclib/ablexpr.cpp
@@ -6,10 +6,11 @@
 //								ABLEXPR.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
+//#include <string.h>
+//#include <stdio.h>
+//#include <stdlib.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"


  ================================================
diff --git a/source/mclib/ablrtn.cpp b/source/mclib/ablrtn.cpp
index 77e3d69..2860dbf 100755
--- a/source/mclib/ablrtn.cpp
+++ b/source/mclib/ablrtn.cpp
@@ -6,10 +6,11 @@
 //								ABLRTN.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <string.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"
@@ -280,19 +281,19 @@ void ABL_AddToProfileLog (char* profileString);
 // ABL library interface routines
 //***************************************************************************
 
-long DefaultRandom (long range) {
+long DefaultRandom (long /* range */) {
 
 	return(0);
 }
 
 //---------------------------------------------------------------------------
 
-void DefaultSeedRandom (unsigned long seed) {
+void DefaultSeedRandom (unsigned long /* seed */) {
 }
 
 //---------------------------------------------------------------------------
 
-void DefaultDebugPrintCallback (char* s) {
+void DefaultDebugPrintCallback (char* /* s */) {
 }
 
 //---------------------------------------------------------------------------
@@ -372,8 +373,9 @@ profile = true;
 	//-------------------------------------------------------------------
 	// Let's make sure we have not created too many built-in ABL routines
 	// for the lovely user...
-	if (NUM_ABL_ROUTINES > 254)
-		ABL_Fatal(0, " MAJOR ABL ERROR: Too Many ABL Routines ");
+#if (NUM_ABL_ROUTINES > 254)
+#error MAJOR ABL ERROR: Too Many ABL Routines
+#endif
 
 	ABLSystemMallocCallback = systemMallocCallback;
 	ABLStackMallocCallback = stackMallocCallback;
@@ -476,7 +478,8 @@ profile = true;
 	
 	//----------------------------------
 	// Initialize the character table...
-	for (long curCh = 0; curCh < 256; curCh++)
+	long curCh;
+	for (curCh = 0; curCh < 256; curCh++)
 		charTable[curCh] = CHR_SPECIAL;
 	for (curCh = '0'; curCh <= '9'; curCh++)
 		charTable[curCh] = CHR_DIGIT;
@@ -575,7 +578,8 @@ long ABLi_preProcess (char* sourceFileName, long* numErrors, long* numLinesProce
 
 	//--------------------------------------------------------------------------------
 	// First, check if this module has already been registered into the environment...
-	for (long i = 0; i < NumModulesRegistered; i++)
+	long i;
+	for (i = 0; i < NumModulesRegistered; i++)
 		if (strcmp(strlwr(sourceFileName), ModuleRegistry[i].fileName) == 0)
 			return(i);
 
@@ -769,7 +773,9 @@ long ABLi_preProcess (char* sourceFileName, long* numErrors, long* numLinesProce
 
 //***************************************************************************
 
-long ABLi_execute (SymTableNodePtr moduleIdPtr, SymTableNodePtr functionIdPtr, ABLParamPtr paramList, StackItemPtr returnVal) {
+long ABLi_execute (SymTableNodePtr  moduleIdPtr , SymTableNodePtr /* functionIdPtr */, 
+				   ABLParamPtr paramList, StackItemPtr returnVal) 
+{
 
 	//insertSymTable(&SymTableDisplay[0], moduleIdPtr);
 
@@ -903,7 +909,7 @@ long ABLi_execute (SymTableNodePtr moduleIdPtr, SymTableNodePtr functionIdPtr, A
 
 //***************************************************************************
 
-long ABLi_deleteModule (SymTableNodePtr moduleIdPtr) {
+long ABLi_deleteModule (SymTableNodePtr /* moduleIdPtr */) {
 
 	return(ABL_NO_ERR);
 }
@@ -1090,7 +1096,7 @@ long ABLi_registerInteger (char* name, long* address, long numElements) {
 
 //***************************************************************************
 
-long ABLi_registerReal (char* name, float* address, long numElements) {
+long ABLi_registerReal (char* name, float* address, long /* numElements */) {
 
 	if (strlen(name) >= MAXLEN_TOKENSTRING)
 		ABL_Fatal(0, " ABLi_registerInteger: variable name too long ");


  ================================================
diff --git a/source/mclib/ablscan.cpp b/source/mclib/ablscan.cpp
index 8918566..2cf5c35 100755
--- a/source/mclib/ablscan.cpp
+++ b/source/mclib/ablscan.cpp
@@ -6,12 +6,13 @@
 //								ABLSCAN.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-#include <time.h>
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <math.h>
+//#include <string.h>
+//#include <time.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"
@@ -34,7 +35,7 @@
 #endif
 
 //***************************************************************************
-#pragma warning(disable:4244)
+//#pragma warning(disable:4244)
 
 //---------------------
 // RESERVED WORD tables
@@ -501,9 +502,10 @@ void getChar();
 
 void initScanner (char* fileName) {
 
+	long curCh;
 	//----------------------------------
 	// Initialize the character table...
-	for (long curCh = 0; curCh < 256; curCh++)
+	for (curCh = 0; curCh < 256; curCh++)
 		charTable[curCh] = CHR_SPECIAL;
 	for (curCh = '0'; curCh <= '9'; curCh++)
 		charTable[curCh] = CHR_DIGIT;


  ================================================
diff --git a/source/mclib/ablstd.cpp b/source/mclib/ablstd.cpp
index 752db72..0df5088 100755
--- a/source/mclib/ablstd.cpp
+++ b/source/mclib/ablstd.cpp
@@ -6,8 +6,9 @@
 //								ABLSTD.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdio.h>
+//#include <stdio.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"


  ================================================
diff --git a/source/mclib/ablstmt.cpp b/source/mclib/ablstmt.cpp
index 43ad40d..20982b9 100755
--- a/source/mclib/ablstmt.cpp
+++ b/source/mclib/ablstmt.cpp
@@ -6,8 +6,9 @@
 //								ABLSTMT.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdio.h>
+//#include <stdio.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"
@@ -515,8 +516,8 @@ void statement (void) {
 				if (IdPtr->defn.info.routine.flags & ROUTINE_FLAG_ORDER) {
 					if (NumOrderCalls == MAX_ORDERS)
 						syntaxError(ABL_ERR_SYNTAX_TOO_MANY_ORDERS);
-					crunchByte(NumOrderCalls / 32);
-					crunchByte(NumOrderCalls % 32);
+					crunchByte((unsigned char)(NumOrderCalls / 32));
+					crunchByte((unsigned char)(NumOrderCalls % 32));
 					NumOrderCalls++;
 				}
 				getToken();


  ================================================
diff --git a/source/mclib/ablsymt.cpp b/source/mclib/ablsymt.cpp
index bde8fdc..e4ade20 100755
--- a/source/mclib/ablsymt.cpp
+++ b/source/mclib/ablsymt.cpp
@@ -7,9 +7,11 @@
 //
 //***************************************************************************
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+#include "stdafx.h"
+
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <string.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"


  ================================================
diff --git a/source/mclib/ablxexpr.cpp b/source/mclib/ablxexpr.cpp
index 08727d6..179bb93 100755
--- a/source/mclib/ablxexpr.cpp
+++ b/source/mclib/ablxexpr.cpp
@@ -6,8 +6,9 @@
 //								ABLXEXPR.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <string.h>
+//#include <string.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"


  ================================================
diff --git a/source/mclib/ablxstd.cpp b/source/mclib/ablxstd.cpp
index 74edc6c..bb169da 100755
--- a/source/mclib/ablxstd.cpp
+++ b/source/mclib/ablxstd.cpp
@@ -7,11 +7,13 @@
 //
 //***************************************************************************
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <time.h>
+#include "stdafx.h"
+
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <string.h>
+//#include <math.h>
+//#include <time.h>
 
 #ifndef ABL_H
 #include "abl.h"


  ================================================
diff --git a/source/mclib/ablxstmt.cpp b/source/mclib/ablxstmt.cpp
index 8c839b2..1920689 100755
--- a/source/mclib/ablxstmt.cpp
+++ b/source/mclib/ablxstmt.cpp
@@ -6,9 +6,10 @@
 //								ABLEXEC.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
-#include <stdio.h>
-#include <string.h>
+//#include <stdio.h>
+//#include <string.h>
 
 #ifndef ABLGEN_H
 #include "ablgen.h"
@@ -346,11 +347,11 @@ TypePtr execDeclaredRoutineCall (SymTableNodePtr routineIdPtr, bool skipOrder) {
 
 		if (functionExecTime > ProfileLogFunctionTimeLimit) {
 			char s[512];
-			sprintf(s, "[%08d] ", NumExecutions);
+			sprintf_s(s, _countof(s), "[%08d] ", NumExecutions);
 			for (long i = 0; i < CallStackLevel; i++)
 				strcat(s, " ");
 			char s1[512];
-			sprintf(s1, "%s (%d)\n", routineIdPtr->name, functionExecTime);
+			sprintf_s(s1, _countof(s1), "%s (%d)\n", routineIdPtr->name, functionExecTime);
 			strcat(s, s1);
 			ABL_AddToProfileLog(s);
 		}


  ================================================
diff --git a/source/mclib/alphapalette.cpp b/source/mclib/alphapalette.cpp
index 5dfd7dd..ba66fbc 100755
--- a/source/mclib/alphapalette.cpp
+++ b/source/mclib/alphapalette.cpp
@@ -2,15 +2,15 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include <stdio.h>
+#include "stdafx.h"
+// #include <stdio.h>
+// #include <string.h>
 
 #ifndef FILE_H
 #include "file.h"
 #endif
 
 #include "vfx.h"
-
-#include <string.h>
 #include <gameos.hpp>
 
 unsigned char FindClosest( VFX_RGB* Palette, int r, int g, int b );
@@ -72,14 +72,14 @@ void InitAlphaLookup( VFX_RGB* Palette)
 	
 		if (Line[0]!='#' && Line[0]!=';' && Line[0]!=0xa && Line[0]!=0)
 		{
-			if( EOF == sscanf( Line, "%d", &i ))
+			if( EOF == sscanf_s( Line, "%d", &i ))
 				break;
 
 			gosASSERT(i>=0 && i<NUM_ALPHACOLORS);
 
 			SpecialColor[i]=1;
 
-			gosASSERT(EOF != sscanf( Line, "%f %f %f %f %f",
+			gosASSERT(EOF != sscanf_s( Line, "%f %f %f %f %f",
 													&AlphaIni[i][R],
 													&AlphaIni[i][G],
 													&AlphaIni[i][B],


  ================================================
diff --git a/source/mclib/appear.h b/source/mclib/appear.h
index 3bf8342..b26ea63 100755
--- a/source/mclib/appear.h
+++ b/source/mclib/appear.h
@@ -6,6 +6,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
+
 #ifndef APPEAR_H
 #define APPEAR_H
 //---------------------------------------------------------------------------
@@ -73,7 +75,7 @@ class Appearance
 		Stuff::Vector4D				lowerRight;		//used to draw select boxes.
 		
 		float						barStatus;		//Status Bar Length.
-		DWORD						barColor;		//Status Bar Color.
+		ULONG						barColor;		//Status Bar Color.
 	
 	//Member Functions
 	//-----------------
@@ -104,6 +106,7 @@ class Appearance
 			barColor = 0x0;
 
 			visible = seen = false;
+			(void)tree;(void)obj;
 		}
 		
 		virtual void initFX (void)
@@ -123,12 +126,14 @@ class Appearance
 		virtual long update (bool animate = true)
 		{
 			//Perform any frame by frame tasks.  Animations, etc.
+			(void)animate;
 			return NO_ERR;
 		}
 		
 		virtual long render (long depthFixup = 0)
 		{
 			//Decide whether or not I can be seen and add me to render list.
+			(void)depthFixup;
 			return NO_ERR;
 		}
 
@@ -159,12 +164,13 @@ class Appearance
 
 		virtual bool isMouseOver (float px, float py)
 		{
+			(void)px; (void)py;
 			return FALSE;		//Never over a base appearance
 		}
 				
-		virtual void drawSelectBox (DWORD color);
+		virtual void drawSelectBox (ULONG color);
 
-		virtual void drawSelectBrackets (DWORD color);
+		virtual void drawSelectBrackets (ULONG color);
 
 		virtual void drawBars (void);
 
@@ -182,16 +188,16 @@ class Appearance
 			return inView;
 		}
 
-		virtual void setGesture (unsigned long gestureId)
+		virtual void setGesture (unsigned long /*gestureId*/)
 		{
 		}
 
-		virtual long setGestureGoal (long gestureId)
+		virtual long setGestureGoal (long /*gestureId*/)
 		{
 			return 0;
 		}
 		
-		virtual void setVelocityPercentage (float percent)
+		virtual void setVelocityPercentage (float /*percent*/)
 		{
 		}
 		
@@ -212,7 +218,7 @@ class Appearance
 				barStatus = 1.0f;
 		}
 
-		virtual void setBarColor (DWORD clr)
+		virtual void setBarColor (ULONG clr)
 		{
 			barColor = clr;
 		}
@@ -222,7 +228,7 @@ class Appearance
 			return false;
 		}
 
-		virtual long getNumFramesInGesture (long gestureId)
+		virtual long getNumFramesInGesture (long /*gestureId*/)
 		{
 			return 0;
 		}
@@ -262,16 +268,16 @@ class Appearance
 			return false;
 		}
 
-		virtual void setObjectNameId (long objId)
+		virtual void setObjectNameId (long /*objId*/)
 		{
 		}
 
-		virtual bool setJumpParameters (Stuff::Vector3D &jumpGoal)
+		virtual bool setJumpParameters (Stuff::Vector3D& /*jumpGoal*/)
 		{
 			return false;
 		}
 
-		virtual void setWeaponNodeUsed (long nodeId)
+		virtual void setWeaponNodeUsed (long /*nodeId*/)
 		{
 		}
 
@@ -280,12 +286,12 @@ class Appearance
 			return 0;
 		}
 		
-		virtual long getWeaponNode (long weapontype)
+		virtual long getWeaponNode (long /*weapontype*/)
 		{
 			return 0;
 		}
 		
-		virtual float getWeaponNodeRecycle (long node)
+		virtual float getWeaponNodeRecycle (long /*node*/)
 		{
 			return 0.0f;
 		}
@@ -294,11 +300,11 @@ class Appearance
 		{
 		}
 
-		virtual void setWeaponNodeRecycle(long nodeId, float time)
+		virtual void setWeaponNodeRecycle(long /*nodeId*/, float /*time*/)
 		{
 		}
 		
-		virtual Stuff::Vector3D getSmokeNodePosition (long nodeId)
+		virtual Stuff::Vector3D getSmokeNodePosition (long /*nodeId*/)
 		{
 			Stuff::Vector3D position;
 			position.x = position.y = position.z = 0.0f;
@@ -306,7 +312,7 @@ class Appearance
 			return position;
 		}
 		
-		virtual Stuff::Vector3D getDustNodePosition (long nodeId)
+		virtual Stuff::Vector3D getDustNodePosition (long /*nodeId*/)
 		{
 			Stuff::Vector3D position;
 			position.x = position.y = position.z = 0.0f;
@@ -314,7 +320,7 @@ class Appearance
 			return position;
 		}
 		
- 		virtual Stuff::Vector3D getWeaponNodePosition (long node)
+ 		virtual Stuff::Vector3D getWeaponNodePosition (long /*node*/)
 		{
 			Stuff::Vector3D position;
 			position.x = position.y = position.z = 0.0f;
@@ -322,7 +328,7 @@ class Appearance
 			return position;
 		}
 
-		virtual Stuff::Vector3D getNodePosition (long nodeId)
+		virtual Stuff::Vector3D getNodePosition (long /*nodeId*/)
 		{
 			Stuff::Vector3D position;
 			position.x = position.y = position.z = 0.0f;
@@ -330,7 +336,7 @@ class Appearance
 			return position;
 		}
 		
-		virtual Stuff::Vector3D getNodeNamePosition (char *nodeName)
+		virtual Stuff::Vector3D getNodeNamePosition (PSTR /*nodeName*/)
 		{
 			Stuff::Vector3D position;
 			position.x = position.y = position.z = 0.0f;
@@ -338,7 +344,7 @@ class Appearance
 			return position;
 		}
 		
-		virtual Stuff::Vector3D getNodeIdPosition (long nodeId)
+		virtual Stuff::Vector3D getNodeIdPosition (long /*nodeId*/)
 		{
 			Stuff::Vector3D position;
 			position.x = position.y = position.z = 0.0f;
@@ -346,7 +352,7 @@ class Appearance
 			return position;
 		}
 
-		virtual void setCombatMode (bool combatMode)
+		virtual void setCombatMode (bool /*combatMode*/)
 		{
 		}
 
@@ -355,22 +361,23 @@ class Appearance
 			return 0.0f;
 		}
 
-		virtual float getVelocityOfGesture (long gestureId)
+		virtual float getVelocityOfGesture (long /*gestureId*/)
 		{
 			return 0.0f;
 		}
 
 
-		virtual void setBrake (bool brake)
+		virtual void setBrake (bool /*brake*/)
 		{
 		}
 
-		virtual void setObjectParameters (Stuff::Vector3D &pos, float rot, long selected, long team, long homeRelations)
+		virtual void setObjectParameters (Stuff::Vector3D& /*pos*/, float /*rot*/, long /*selected*/, long /*team*/, long /*homeRelations*/)
 		{
 		}
 
-		virtual void setMoverParameters (float turretRot, float lArmRot = 0.0f, float rArmRot = 0.0f, bool isAirborne = false)
+		virtual void setMoverParameters (float /*turretRot*/, float lArmRot = 0.0f, float rArmRot = 0.0f, bool isAirborne = false)
 		{
+			lArmRot; rArmRot; isAirborne;
 		}
 
 		virtual void updateFootprints (void)
@@ -381,15 +388,15 @@ class Appearance
 		{
 		}
 
-		virtual void setPaintScheme (DWORD red, DWORD green, DWORD blue)
+		virtual void setPaintScheme (ULONG /*red*/, ULONG /*green*/, ULONG /*blue*/)
 		{
 		}
 
-		virtual void getPaintScheme (DWORD &red, DWORD &green, DWORD &blue)
+		virtual void getPaintScheme (ULONG& /*red*/, ULONG& /*green*/, ULONG& /*blue*/)
 		{
 		}
 
-		virtual void resetPaintScheme (DWORD red, DWORD green, DWORD blue)
+		virtual void resetPaintScheme (ULONG /*red*/, ULONG /*green*/, ULONG /*blue*/)
 		{
 		}
 		
@@ -415,7 +422,7 @@ class Appearance
 			seen = sen;
 		}
 
-		virtual void setSensorLevel (long lvl)
+		virtual void setSensorLevel (long /*lvl*/)
 		{
 		}
 		
@@ -435,30 +442,33 @@ class Appearance
 		{
 		}
 		
-		virtual void setObjStatus (long oStatus)
+		virtual void setObjStatus (long /*oStatus*/)
 		{
 		}
 		
-		virtual long calcCellsCovered (Stuff::Vector3D& pos, short* cellList) {
+		virtual long calcCellsCovered (Stuff::Vector3D& /*pos*/, short* /*cellList*/)
+		{
 			return(0);
 		}
 
-		virtual void markTerrain (_ScenarioMapCellInfo* pInfo, int type, int counter)
+		virtual void markTerrain (_ScenarioMapCellInfo* /*pInfo*/, int /*type*/, int /*counter*/)
 		{
 		}
 		
-		virtual long markMoveMap (bool passable, long* lineOfSightRect, bool useheight = false, short* cellList = NULL)
+		virtual long markMoveMap (bool /*passable*/, long* /*lineOfSightRect*/, bool useheight = false, short* cellList = NULL)
 		{
+			useheight;cellList;
 			return(0);
 		}
 
 		virtual void markLOS (bool clearIt = false)
 		{
-		
+			clearIt;
 		}
 		
 		virtual void scale (float scaleFactor)
 		{
+			scaleFactor;
 		}
 		
 		virtual bool playDestruction (void)
@@ -471,11 +481,11 @@ class Appearance
 			return 0.0f;
 		}
 		
-		virtual void flashBuilding (float duration, float flashDuration, DWORD color)
+		virtual void flashBuilding (float /*duration*/, float /*flashDuration*/, ULONG /*color*/)
 		{
 		}
 		
-		virtual void setHighlightColor( long argb )
+		virtual void setHighlightColor( long /*argb*/ )
 		{
 		}
 	
@@ -492,7 +502,7 @@ class Appearance
 		{
 		}
 
-		virtual void setFilterState (bool state)
+		virtual void setFilterState (bool /*state*/)
 		{
 		}
 		
@@ -503,7 +513,7 @@ class Appearance
 			return result;
 		}
 
-		virtual bool isSelectable()
+		virtual bool isSelectable(void)
 		{
 			return true;
 		}
@@ -512,7 +522,7 @@ class Appearance
 		{
 		}
 
-		virtual long getObjectNameId ()
+		virtual long getObjectNameId (void)
 		{
 			return -1;
 		}
@@ -522,12 +532,12 @@ class Appearance
 			return false;
 		}
 		
-		virtual void setLightsOut (bool lightFlag)
+		virtual void setLightsOut (bool /*lightFlag*/)
 		{
 		
 		}
 
-		virtual bool PerPolySelect (long mouseX, long mouseY)
+		virtual bool PerPolySelect (long /*mouseX*/, long /*mouseY*/)
 		{
 			return true;
 		}
@@ -544,7 +554,7 @@ class Appearance
 			return result;
 		}
 		
-		virtual void setAlphaValue (BYTE aVal)
+		virtual void setAlphaValue (BYTE /*aVal*/)
 		{
 		}
 
@@ -552,13 +562,13 @@ class Appearance
 						  unsigned long bmpHeight, unsigned long color, 
 						  unsigned long where = 0 );
 						  
-		virtual void setSkyNumber (long skyNum)
+		virtual void setSkyNumber (long /*skyNum*/)
 		{
 		}
 
-		virtual void setMechName( const char* pName ){}
+		virtual void setMechName( const char* /*pName*/ ){}
 		
-		virtual void startSmoking (long smokeLvl)
+		virtual void startSmoking (long /*smokeLvl*/)
 		{
 		}
 		
@@ -574,7 +584,7 @@ class Appearance
 		{
 		}
 		
-		virtual void startActivity (long effectId, bool loop)
+		virtual void startActivity (long /*effectId*/, bool /*loop*/)
 		{
 		}
 		
@@ -613,7 +623,7 @@ class Appearance
 			return false;
 		}
 
-		virtual bool hasAnimationData (long gestureId)
+		virtual bool hasAnimationData (long /*gestureId*/)
 		{
 			return false;
 		}


  ================================================
diff --git a/source/mclib/apprtype.cpp b/source/mclib/apprtype.cpp
index acace6b..6244f35 100755
--- a/source/mclib/apprtype.cpp
+++ b/source/mclib/apprtype.cpp
@@ -227,7 +227,7 @@ AppearanceTypePtr AppearanceTypeList::getAppearance (unsigned long apprNum, char
 	//-----------------------------------------------------------
 	// Scan the list of appearances and see if we have this one.
 	appearanceType = head;
-	while (appearanceType && stricmp(appearanceType->name,appearFile) != 0)
+	while (appearanceType && _stricmp(appearanceType->name,appearFile) != 0)
 	{
 		appearanceType = appearanceType->next;
 	}


  ================================================
diff --git a/source/mclib/bdactor.cpp b/source/mclib/bdactor.cpp
index 669654e..4e131df 100755
--- a/source/mclib/bdactor.cpp
+++ b/source/mclib/bdactor.cpp
@@ -151,10 +151,11 @@ void BldgAppearanceType::init (char * fileName)
 	
 	char aseFileName[512];
 	result = iniFile.readIdString("FileName",aseFileName,511);
+	long i;
 	if (result != NO_ERR)
 	{
 		//Check for LOD filenames instead
-		for (long i=0;i<MAX_LODS;i++)
+		for (i=0;i<MAX_LODS;i++)
 		{
 			char baseName[256];
 			char baseLODDist[256];
@@ -388,7 +389,8 @@ void BldgAppearanceType::destroy (void)
 {
 	AppearanceType::destroy();
 
-	for (long i=0;i<MAX_LODS;i++)
+	long i;
+	for (i=0;i<MAX_LODS;i++)
 	{
 		if (bldgShape[i])
 		{
@@ -474,7 +476,7 @@ Stuff::Vector3D BldgAppearance::getWeaponNodePosition (long nodeId)
    	torsoRot = Stuff::EulerAngles(0.0f,(turretYaw * DEGREES_TO_RADS),0.0f);
 	if (rotationalNodeId == -1)
 	{
-		if (stricmp(appearType->rotationalNodeId,"NONE") != 0)
+		if (_stricmp(appearType->rotationalNodeId,"NONE") != 0)
 			rotationalNodeId = bldgShape->GetNodeNameId(appearType->rotationalNodeId);
 		else
 			rotationalNodeId = -2;
@@ -595,10 +597,11 @@ void BldgAppearance::init (AppearanceTypePtr tree, GameObjectPtr obj)
 	if (appearType)
 	{
 		bldgShape = appearType->bldgShape[0]->CreateFrom();
+		long i;
 
 		//-------------------------------------------------
 		// Load the texture and store its handle.
-		for (long i=0;i<bldgShape->GetNumTextures();i++)
+		for (i=0;i<bldgShape->GetNumTextures();i++)
 		{
 			char txmName[1024];
 			bldgShape->GetTextureName(i,txmName,256);
@@ -989,7 +992,7 @@ void BldgAppearance::setGesture (unsigned long gestureId)
 	if ((status == OBJECT_STATUS_DESTROYED) || (status == OBJECT_STATUS_DISABLED))
 		return;
 		
-	if (gestureId == bdAnimationState)
+	if (gestureId == (unsigned long)bdAnimationState)
 		return;
 
 	//----------------------------------------------------------------------
@@ -1324,7 +1327,7 @@ bool BldgAppearance::recalcBounds (void)
 						}
 						
 						// we are at this LOD level.
-						if (selectLOD != currentLOD)
+						if (selectLOD != (DWORD)currentLOD)
 						{
 							currentLOD = selectLOD;
 
@@ -1630,7 +1633,7 @@ long BldgAppearance::render (long depthFixup)
 
 			if (rotationalNodeId == -1)
 			{
-				if (stricmp(appearType->rotationalNodeId,"NONE") != 0)
+				if (_stricmp(appearType->rotationalNodeId,"NONE") != 0)
 	   				rotationalNodeId = bldgShape->GetNodeNameId(appearType->rotationalNodeId);
 				else
 					rotationalNodeId = -2;
@@ -1666,7 +1669,7 @@ long BldgAppearance::render (long depthFixup)
 	
 				if (rotationalNodeId == -1)
 				{
-					if (stricmp(appearType->rotationalNodeId,"NONE") != 0)
+					if (_stricmp(appearType->rotationalNodeId,"NONE") != 0)
 		   				rotationalNodeId = bldgShape->GetNodeNameId(appearType->rotationalNodeId);
 					else
 						rotationalNodeId = -2;
@@ -2164,7 +2167,7 @@ long BldgAppearance::update (bool animate)
 
 			if (rotationalNodeId == -1)
 			{
-				if (stricmp(appearType->rotationalNodeId,"NONE") != 0)
+				if (_stricmp(appearType->rotationalNodeId,"NONE") != 0)
 	   				rotationalNodeId = bldgShape->GetNodeNameId(appearType->rotationalNodeId);
 				else
 					rotationalNodeId = -2;
@@ -2201,7 +2204,7 @@ long BldgAppearance::update (bool animate)
 	
 				if (rotationalNodeId == -1)
 				{
-					if (stricmp(appearType->rotationalNodeId,"NONE") != 0)
+					if (_stricmp(appearType->rotationalNodeId,"NONE") != 0)
 		   				rotationalNodeId = bldgShape->GetNodeNameId(appearType->rotationalNodeId);
 					else
 						rotationalNodeId = -2;
@@ -2285,7 +2288,7 @@ void BldgAppearance::startActivity (long effectId, bool loop)
 
    		if (rotationalNodeId == -1)
    		{
-   			if (stricmp(appearType->rotationalNodeId,"NONE") != 0)
+   			if (_stricmp(appearType->rotationalNodeId,"NONE") != 0)
       				rotationalNodeId = bldgShape->GetNodeNameId(appearType->rotationalNodeId);
    			else
    				rotationalNodeId = -2;
@@ -2321,7 +2324,7 @@ void BldgAppearance::startActivity (long effectId, bool loop)
 
 			if (rotationalNodeId == -1)
 			{
-				if (stricmp(appearType->rotationalNodeId,"NONE") != 0)
+				if (_stricmp(appearType->rotationalNodeId,"NONE") != 0)
 	   				rotationalNodeId = bldgShape->GetNodeNameId(appearType->rotationalNodeId);
 				else
 					rotationalNodeId = -2;
@@ -2582,14 +2585,15 @@ void BldgAppearance::markTerrain (_ScenarioMapCellInfo* pInfo, int type, int cou
 			}
 		}
 
+		long i, j;
 		//-------------------------------------------------------------
 		// New way.  For each vertex in each shape, translate to world
-		for (long i=0;i<bldgShape->GetNumShapes();i++)
+		for (i=0;i<bldgShape->GetNumShapes();i++)
 		{
 			//Check if the artists meant for this piece to NOT block passability!!
 			if (strnicmp(bldgShape->GetNodeId(i),"_PAB",4) != 0)
 			{
-				for (long j=0;j<bldgShape->GetNumVerticesInShape(i);j++)
+				for (j=0;j<bldgShape->GetNumVerticesInShape(i);j++)
 				{
 					Stuff::Vector3D vertexPos, worldPos;
 					vertexPos = bldgShape->GetShapeVertexInEditor(i,j,-rotation);
@@ -3211,10 +3215,11 @@ void TreeAppearance::init (AppearanceTypePtr tree, GameObjectPtr obj)
 	if (appearType)
 	{
 		treeShape = appearType->treeShape[0]->CreateFrom();
+		long i;
 
 		//-------------------------------------------------
 		// Load the texture and store its handle.
-		for (long i=0;i<treeShape->GetNumTextures();i++)
+		for (i=0;i<treeShape->GetNumTextures();i++)
 		{
 			char txmName[1024];
 			treeShape->GetTextureName(i,txmName,256);
@@ -3748,7 +3753,7 @@ bool TreeAppearance::recalcBounds (void)
 					}
 					
 					// we are at this LOD level.
-					if (selectLOD != currentLOD)
+					if (selectLOD != (DWORD)currentLOD)
 					{
 						currentLOD = selectLOD;
 


  ================================================
diff --git a/source/mclib/bitflag.cpp b/source/mclib/bitflag.cpp
index 1056074..2e54060 100755
--- a/source/mclib/bitflag.cpp
+++ b/source/mclib/bitflag.cpp
@@ -7,6 +7,8 @@
 
 //----------------------------------------------------------------------------------
 // Include Files
+#include "stdafx.h"
+
 #ifndef BITFLAG_H
 #include "bitflag.h"
 #endif
@@ -280,6 +282,8 @@ void ByteFlag::initTGA (char *tgaFileName)
 	gosASSERT(result == NO_ERR);
 
 	MemoryPtr tgaBuffer = (MemoryPtr)malloc(tgaFile.fileSize());
+	if(tgaBuffer == NULL)
+		return;
 
 	tgaFile.read(tgaBuffer,tgaFile.fileSize());
 


  ================================================
diff --git a/source/mclib/camera.cpp b/source/mclib/camera.cpp
index 0554489..d49e46c 100755
--- a/source/mclib/camera.cpp
+++ b/source/mclib/camera.cpp
@@ -51,7 +51,7 @@ extern void AG_shape_draw (PANE *pane, void *shape_table,LONG shape_number, LONG
 extern void AG_shape_translate_draw (PANE *pane, void *shape_table,LONG shape_number, LONG hotX, LONG hotY);
 extern void AG_shape_lookaside(MemoryPtr palette);
 
-#pragma warning(disable:4305/*double to float truncation*/)
+//#pragma warning(disable:4305/*double to float truncation*/)
 
 inline float agsqrt( float _a, float _b )
 {


  ================================================
diff --git a/source/mclib/cident.cpp b/source/mclib/cident.cpp
index e1beae5..2ab39f0 100755
--- a/source/mclib/cident.cpp
+++ b/source/mclib/cident.cpp
@@ -8,15 +8,15 @@
 
 //---------------------------------------------------------------------------
 // Include files
+#include "stdafx.h"
+// #include <ctype.h>
+// #include "windows.h"
 
 #ifndef CIDENT_H
 #include "cident.h"
 #endif
 
 #include "heap.h"
-#include <ctype.h>
-
-#include "windows.h"
 
 #ifndef _MBCS
 #include <gameos.hpp>
@@ -51,7 +51,7 @@ void FullPathFileName::init (char * dir_path, const char * name, char * ext)
 {
 	destroy();
 
-	long total_length = strlen(dir_path);
+	size_t total_length = strlen(dir_path);
 	total_length += strlen(name);
 	total_length += strlen(ext);
 	total_length++;
@@ -59,17 +59,22 @@ void FullPathFileName::init (char * dir_path, const char * name, char * ext)
 
 	fullName = (char *)systemHeap->Malloc(total_length);
 	gosASSERT(fullName != NULL);
+	if (fullName == NULL)
+		return;
 	fullName[0] = 0;
 
 	if ( strstr( name, dir_path ) != name )
-		strcpy(fullName,dir_path);
-	strcat(fullName,name);
+		strcpy_s(fullName, total_length, dir_path);
+
+	if (name)
+		strcat_s(fullName, total_length, name);
 
 	// don't append if its already there
-	if (ext && stricmp( fullName + strlen( fullName ) - strlen( ext ), ext ) != 0)
-		strcat(fullName,ext);
+	if (ext && _stricmp( fullName + strlen( fullName ) - strlen( ext ), ext ) != 0)
+		strcat_s(fullName, total_length, ext);
 
-	CharLower(fullName);
+	// CharLowerA(fullName);
+	_strlwr_s(fullName, total_length);
 }
 
 void FullPathFileName::changeExt (char *from, char *to)


  ================================================
diff --git a/source/mclib/cident.h b/source/mclib/cident.h
index 9ddae6c..397a411 100755
--- a/source/mclib/cident.h
+++ b/source/mclib/cident.h
@@ -45,13 +45,13 @@ class IDString
 
 		void init (char *new_id)
 		{
-			strncpy(id,new_id,ID_SIZE-1);   // pads unused ID with 0s!
+			strncpy_s(id, ID_SIZE, new_id, ID_SIZE-1);   // pads unused ID with 0s!
 			id[ID_SIZE-1] = 0;
 		}
 
 		void init (IDString & new_ids)
 		{
-			strncpy(id,new_ids.id,ID_SIZE-1);
+			strncpy_s(id, ID_SIZE, new_ids.id, ID_SIZE-1);
 			id[ID_SIZE-1] = 0;
 		}
 
@@ -184,7 +184,7 @@ class IDString
 
 		void standardize (void)
 		{
-			strupr(id);
+			_strupr_s(id, ID_SIZE);
 		}
 };
 


  ================================================
diff --git a/source/mclib/clouds.cpp b/source/mclib/clouds.cpp
index 5c93915..e59e2d9 100755
--- a/source/mclib/clouds.cpp
+++ b/source/mclib/clouds.cpp
@@ -115,8 +115,8 @@ void Clouds::update (void)
 		// Create the grid.
 		long cloudInc = float2long(MAX_CLOUDS_SIZE * 2.0f / gridSize);
 		float uvInc = MAX_UV_REPEAT / float(gridSize);
-		
-		for (long y=0;y<gridSize;y++)
+		long y;
+		for (y=0;y<gridSize;y++)
 		{
 			for (long x=0;x<gridSize;x++)
 			{


  ================================================
diff --git a/source/mclib/cmponent.cpp b/source/mclib/cmponent.cpp
index d1484e7..326ea9c 100755
--- a/source/mclib/cmponent.cpp
+++ b/source/mclib/cmponent.cpp
@@ -8,6 +8,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+
 //******************************************************************************************
 #ifndef CMPONENT_H
 #include "cmponent.h"
@@ -87,7 +89,9 @@ long MasterComponent::initEXCEL (char* dataLine, float baseSensorRange) {
 	//----------------------------------------------------------
 	// Component data was read in, so parse it. First, parse the
 	// fields common to all components...
-	char* field = strtok(dataLine, ",");
+
+	char* next_token = NULL;
+	char* field = strtok_s(dataLine, ",", &next_token);
 
 	int ammoAmount = 1;
 
@@ -98,7 +102,7 @@ long MasterComponent::initEXCEL (char* dataLine, float baseSensorRange) {
 	cLoadString(COMPONENT_NAME_START+masterID,name,MAXLEN_COMPONENT_NAME);
 	cLoadString(COMPONENT_ABBR_START+masterID,abbreviation,MAXLEN_COMPONENT_ABBREV);
 	
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	long formIndex;
 	for (formIndex = 0; ComponentFormString[formIndex] != NULL; formIndex++)
 		if (strcmp(field, ComponentFormString[formIndex]) == 0)
@@ -113,31 +117,34 @@ long MasterComponent::initEXCEL (char* dataLine, float baseSensorRange) {
 
 	form = (ComponentFormType)formIndex;
 	
-	field = strtok(NULL, ","); // name, ignore
+	field = strtok_s(NULL, ",", &next_token); // name, ignore
 
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	size = atof(field);
 
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	float recycleTime = atof(field);
 	
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	float heat = (unsigned long)atof(field);
 
-	field = strtok(NULL, ","); 
+	field = strtok_s(NULL, ",", &next_token); 
 	tonnage = atof( field );
 
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	float damage = atof(field);
 
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	CV = atof(field);
 	
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	resourcePoints = atoi(field);
 	
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	unsigned char rangeType = 255;
+
+_Check_return_wat_ _CRTIMP errno_t __cdecl _strlwr_s(_Inout_updates_z_(_Size) char * _Str, _In_ size_t _Size);
+
 	_strlwr(field);
 	if (strcmp(field, "0") != 0) {
 		if (strcmp(field, WeaponRangeString[WEAPON_RANGE_SHORT]) == 0)
@@ -150,7 +157,7 @@ long MasterComponent::initEXCEL (char* dataLine, float baseSensorRange) {
 			Fatal(0, " MasterComponent.initEXCEL: bad weapon range type in compbase ");
 	}
 
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	for (long location = 0; location < NUM_BODY_LOCATIONS; location++) 
 	{
 		if ( field )
@@ -162,7 +169,7 @@ long MasterComponent::initEXCEL (char* dataLine, float baseSensorRange) {
 			else
 				criticalSpacesReq[location] = atoi(field);
 		}
-			field = strtok(NULL, ",");
+			field = strtok_s(NULL, ",", &next_token);
 
 	}
 
@@ -184,12 +191,12 @@ long MasterComponent::initEXCEL (char* dataLine, float baseSensorRange) {
 	if ( field )
 		flags = atoi(field);
 	
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	int specialEffect = 0;
 	if ( field )
 		specialEffect = (char)atoi(field);
 	
-	field = strtok(NULL, ",");
+	field = strtok_s(NULL, ",", &next_token);
 	int ammoMasterId = 0;
 	if ( field )
 		ammoMasterId = (char)atoi(field);
@@ -206,7 +213,7 @@ long MasterComponent::initEXCEL (char* dataLine, float baseSensorRange) {
 			break;
 		case COMPONENT_FORM_ECM:
 			stats.ecm.effect = damage;
-			field = strtok(NULL, ",");
+			field = strtok_s(NULL, ",", &next_token);
 			stats.ecm.range = recycleTime;
 			break;
 		case COMPONENT_FORM_JAMMER:
@@ -272,14 +279,14 @@ long MasterComponent::saveEXCEL (FilePtr componentFile, unsigned char masterId,
 	{
 		//---------------------------------------
 		// Blank undefined line in compbas here.
-		sprintf(dataLine,"0,undefined,undefined,0,0,0,0,0,0,0,0,0,0,0,0,No,No,0,No,0,0,0,0,na,na,na,na,na,na,na,na,na,,,,,");
+		sprintf_s(dataLine, _countof(dataline), "0,undefined,undefined,0,0,0,0,0,0,0,0,0,0,0,0,No,No,0,No,0,0,0,0,na,na,na,na,na,na,na,na,na,,,,,");
 		componentFile->writeLine(dataLine);
 		return(0);
 	}
 
 	//----------------------------------------------------------
 	// Build the dataline piece by piece
-	sprintf(piece,"%d",masterId);
+	sprintf_s(piece,_countof(piece),"%d",masterId);
 	strcpy(dataLine,piece);
 	strcat(dataLine,comma);
 
@@ -294,28 +301,28 @@ long MasterComponent::saveEXCEL (FilePtr componentFile, unsigned char masterId,
 	strcat(dataLine,ComponentFormString[form]);
 	strcat(dataLine,comma);
 
-	sprintf(piece,"%d",size);
+	sprintf_s(piece,_countof(piece),"%d",size);
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
-	sprintf(piece,"1");
+	sprintf_s(piece,_countof(piece),"1");
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
-	sprintf(piece,"%3.1f",tonnage);
+	sprintf_s(piece,_countof(piece),"%3.1f",tonnage);
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
-	sprintf(piece,"%d",resourcePoints);
+	sprintf_s(piece,_countof(piece),"%d",resourcePoints);
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
 	for (long location = 0; location < NUM_BODY_LOCATIONS; location++) 
 	{
 		if (criticalSpacesReq[location] == -1)
-			sprintf(piece,"No");
+			sprintf_s(piece,_countof(piece),"No");
 		else if (criticalSpacesReq[location] == 0)
-			sprintf(piece,"Yes");
+			sprintf_s(piece,_countof(piece),"Yes");
 		else
 			Fatal(criticalSpacesReq[location],"Bad Data");
 
@@ -324,58 +331,58 @@ long MasterComponent::saveEXCEL (FilePtr componentFile, unsigned char masterId,
 	}
 
 	if (getCanVehicleUse())
-		sprintf(piece,"Yes");
+		sprintf_s(piece,_countof(piece),"Yes");
 	else
-		sprintf(piece,"No");
+		sprintf_s(piece,_countof(piece),"No");
 
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
 	if (getCanMechUse())
-		sprintf(piece,"Yes");
+		sprintf_s(piece,_countof(piece),"Yes");
 	else
-		sprintf(piece,"No");
+		sprintf_s(piece,_countof(piece),"No");
 
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
 	if (getClanTechBase() && getISTechBase())
 	{
-		sprintf(piece,"Both");
+		sprintf_s(piece,_countof(piece),"Both");
 	}
 	else if (getClanTechBase())
 	{
-		sprintf(piece,"Clan");
+		sprintf_s(piece,_countof(piece),"Clan");
 	}
 	else if (getISTechBase())
 	{
-		sprintf(piece,"IS");
+		sprintf_s(piece,_countof(piece),"IS");
 	}
 	else
 	{
-		sprintf(piece,"0");
+		sprintf_s(piece,_countof(piece),"0");
 	}
 
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
 	if (getCanISUse())
-		sprintf(piece,"Yes");
+		sprintf_s(piece,_countof(piece),"Yes");
 	else
-		sprintf(piece,"No");
+		sprintf_s(piece,_countof(piece),"No");
 
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
-	sprintf(piece,"0");
+	sprintf_s(piece,_countof(piece),"0");
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
-	sprintf(piece,"1");
+	sprintf_s(piece,_countof(piece),"1");
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
-	sprintf(piece,"%8.1f",CV);
+	sprintf_s(piece,_countof(piece),"%8.1f",CV);
 	strcat(dataLine,piece);
 	strcat(dataLine,comma);
 
@@ -392,205 +399,205 @@ long MasterComponent::saveEXCEL (FilePtr componentFile, unsigned char masterId,
 		default:
 			//----------------------
 			// No additional data...
-			sprintf(piece,"na,na,na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_SENSOR:
-			sprintf(piece,"%4.1f",float(stats.sensor.range / baseSensorRange));
+			sprintf_s(piece,_countof(piece),"%4.1f",float(stats.sensor.range / baseSensorRange));
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"na,na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_ECM:
-			sprintf(piece,"%4.1f",stats.ecm.effect);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.ecm.effect);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
-			sprintf(piece,"%4.1f",stats.ecm.range);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.ecm.range);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
-			sprintf(piece,"na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_JAMMER:
-			sprintf(piece,"%4.1f",stats.jammer.effect);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.jammer.effect);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
-			sprintf(piece,"na,na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_PROBE:
-			sprintf(piece,"%4.1f",stats.probe.effect);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.probe.effect);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
-			sprintf(piece,"na,na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_ENGINE:
-			sprintf(piece,"%d",0);
+			sprintf_s(piece,_countof(piece),"%d",0);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
-			sprintf(piece,"na,na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_HEATSINK:
-			sprintf(piece,"%4.1f",stats.heatsink.dissipation);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.heatsink.dissipation);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
-			sprintf(piece,"na,na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_WEAPON_ENERGY:
-			sprintf(piece,"%4.1f",stats.weapon.damage);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.weapon.damage);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%4.2f",stats.weapon.recycleTime);
+			sprintf_s(piece,_countof(piece),"%4.2f",stats.weapon.recycleTime);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%4.1f",stats.weapon.heat);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.weapon.heat);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",0);
+			sprintf_s(piece,_countof(piece),"%d",0);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",WEAPON_AMMO_NONE);
+			sprintf_s(piece,_countof(piece),"%d",WEAPON_AMMO_NONE);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%s",WeaponRangeString[stats.weapon.range]);
+			sprintf_s(piece,_countof(piece),"%s",WeaponRangeString[stats.weapon.range]);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			
-			//sprintf(piece,"%d",stats.weapon.type);
+			//sprintf_s(piece,_countof(piece),"%d",stats.weapon.type);
 			//strcat(dataLine,piece);
 			//strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.specialEffect);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.specialEffect);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",0);
+			sprintf_s(piece,_countof(piece),"%d",0);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.flags);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.flags);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_WEAPON_BALLISTIC:
-			sprintf(piece,"%4.1f",stats.weapon.damage);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.weapon.damage);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%4.2f",stats.weapon.recycleTime);
+			sprintf_s(piece,_countof(piece),"%4.2f",stats.weapon.recycleTime);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%4.1f",stats.weapon.heat);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.weapon.heat);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.ammoAmount);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.ammoAmount);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.ammoType);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.ammoType);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%s",WeaponRangeString[stats.weapon.range]);
+			sprintf_s(piece,_countof(piece),"%s",WeaponRangeString[stats.weapon.range]);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			
-//			sprintf(piece,"%d",stats.weapon.type);
+//			sprintf_s(piece,_countof(piece),"%d",stats.weapon.type);
 //			strcat(dataLine,piece);
 //			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.specialEffect);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.specialEffect);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.flags);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.flags);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_WEAPON_MISSILE:
-			sprintf(piece,"%4.1f",stats.weapon.damage);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.weapon.damage);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%4.2f",stats.weapon.recycleTime);
+			sprintf_s(piece,_countof(piece),"%4.2f",stats.weapon.recycleTime);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%4.1f",stats.weapon.heat);
+			sprintf_s(piece,_countof(piece),"%4.1f",stats.weapon.heat);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.ammoAmount);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.ammoAmount);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.ammoType);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.ammoType);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%s",WeaponRangeString[stats.weapon.range]);
+			sprintf_s(piece,_countof(piece),"%s",WeaponRangeString[stats.weapon.range]);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			
-//			sprintf(piece,"%d",stats.weapon.type);
+//			sprintf_s(piece,_countof(piece),"%d",stats.weapon.type);
 //			strcat(dataLine,piece);
 //			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.specialEffect);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.specialEffect);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%d",stats.weapon.flags);
+			sprintf_s(piece,_countof(piece),"%d",stats.weapon.flags);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_AMMO:
-			sprintf(piece,"%d",stats.ammo.ammoPerTon);
+			sprintf_s(piece,_countof(piece),"%d",stats.ammo.ammoPerTon);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 
-			sprintf(piece,"%6.1f",stats.ammo.explosiveDamage);
+			sprintf_s(piece,_countof(piece),"%6.1f",stats.ammo.explosiveDamage);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
-			sprintf(piece,"na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;
 
 		case COMPONENT_FORM_JUMPJET:
-			sprintf(piece,"%6.2f",stats.jumpjet.rangeMod);
+			sprintf_s(piece,_countof(piece),"%6.2f",stats.jumpjet.rangeMod);
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
-			sprintf(piece,"na,na,na,na,na,na,na,na,,,,,");
+			sprintf_s(piece,_countof(piece),"na,na,na,na,na,na,na,na,,,,,");
 			strcat(dataLine,piece);
 			strcat(dataLine,comma);
 			break;


  ================================================
diff --git a/source/mclib/color.cpp b/source/mclib/color.cpp
index 1fae5ca..c3435e0 100755
--- a/source/mclib/color.cpp
+++ b/source/mclib/color.cpp
@@ -7,6 +7,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+
 #ifndef COLOR_H
 #include "color.h"
 #endif


  ================================================
diff --git a/source/mclib/debugging.cpp b/source/mclib/debugging.cpp
index a131a2a..1734cec 100755
--- a/source/mclib/debugging.cpp
+++ b/source/mclib/debugging.cpp
@@ -7,6 +7,8 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
+// #include <string.h>
 
 #ifndef DEBUGGING_H
 #include "debugging.h"
@@ -16,7 +18,6 @@
 #include "heap.h"
 #endif
 
-#include <string.h>
 
 extern UserHeapPtr systemHeap;
 
@@ -78,10 +79,11 @@ void GameDebugWindow::render (void) {
 	if (!display)
 		return;
 
+	long i;
 	gos_TextSetAttributes(font, 0xffffffff, 1.0, true, true, false, false);
 	gos_TextSetRegion( 0, 0, Environment.screenWidth, Environment.screenHeight );
 	long curY = pos[1] + 5;
-	for (long i = linePos; i < MAX_DEBUG_WINDOW_LINES; i++) {
+	for (i = linePos; i < MAX_DEBUG_WINDOW_LINES; i++) {
 		gos_TextSetPosition(pos[0] + 5, curY);
 		curY += fontHeight;
 		gos_TextDraw(textBuffer[i]);


  ================================================
diff --git a/source/mclib/dstd.h b/source/mclib/dstd.h
index 5c91665..4572b89 100755
--- a/source/mclib/dstd.h
+++ b/source/mclib/dstd.h
@@ -15,8 +15,8 @@
 //---------------------------------------------------------------------------
 // Type Definitions
 typedef unsigned char* MemoryPtr;
-typedef unsigned char byte;
-typedef unsigned size_t;
+//typedef unsigned char byte;
+//typedef unsigned size_t;
 
 #ifndef NULL
 #define NULL	0
@@ -45,10 +45,10 @@ typedef void *PVOID;
 
 //--------------------------------------------------------------------------
 // Pragmas
-#pragma warning(disable:4244)
-#pragma warning(disable:4514)		// Unused Inline Functions
-#pragma warning(disable:4800)
-#pragma warning(disable:4244)
+//#pragma warning(disable:4244)
+//#pragma warning(disable:4514)		// Unused Inline Functions
+//#pragma warning(disable:4800)
+//#pragma warning(disable:4244)
 
 //---------------------------------------------------------------------------
 #endif


  ================================================
diff --git a/source/mclib/echarstring.cpp b/source/mclib/echarstring.cpp
index e72c1cb..e418102 100755
--- a/source/mclib/echarstring.cpp
+++ b/source/mclib/echarstring.cpp
@@ -38,10 +38,9 @@
 #include <tchar.h>
 #endif
 
-#pragma warning( disable:4505 )
-
-#pragma warning( push )
-#pragma warning( disable:4100 )
+//#pragma warning( disable:4505 )
+//#pragma warning( push )
+//#pragma warning( disable:4100 )
 
 #define INT_SIZE_LENGTH 20
 extern int __ismbcodepage;
@@ -254,7 +253,7 @@ inline	unsigned short*	ECharString::ToUnicode( unsigned short* p_Buffer,
 
 	p_Buffer[0] = 0;
 
-	MultiByteToWideChar( CP_ACP, 0, (const char*)p_Str, -1, p_Buffer, Num_Chars );
+	MultiByteToWideChar(CP_ACP, 0, (const char*)p_Str, -1, (PWSTR)p_Buffer, Num_Chars);
 
 	return p_Buffer;	
 }
@@ -716,7 +715,7 @@ void ECharString::Format( const ECSChar* p_Str, ... )
 			   Item_Len = 6;  // "(null)"
 			else
 			{
-			   Item_Len = wcslen(p_Next_Arg);
+			   Item_Len = wcslen((PWCHAR)p_Next_Arg);
 			   Item_Len = max(1, Item_Len);
 			}
 #else
@@ -907,7 +906,7 @@ ECharString operator+( const ECharString& Begin_String,  ECSChar Char )
 	Tmp[0] = Char;
 	Tmp[1] = 0;
 
-	return Begin_String + Char;
+	return (Begin_String + Char);
 }
 
 /////////////////////////////////////////////////////////////////
@@ -1596,5 +1595,5 @@ const ECharString& ECharString::operator=( char Char )
 
 //****************************************************************
 
-#pragma warning( pop )
+//#pragma warning( pop )
 


  ================================================
diff --git a/source/mclib/elist.h b/source/mclib/elist.h
index 5d1c973..7729cf6 100755
--- a/source/mclib/elist.h
+++ b/source/mclib/elist.h
@@ -1,7 +1,7 @@
 #ifndef ELIST_H
 #define ELIST_H
 
-#pragma warning( disable : 4211 )
+//#pragma warning( disable : 4211 )
 
 #include <memory.h>
 #include "heap.h"


  ================================================
diff --git a/source/mclib/err.cpp b/source/mclib/err.cpp
index ddfab12..9ae5a37 100755
--- a/source/mclib/err.cpp
+++ b/source/mclib/err.cpp
@@ -7,10 +7,11 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //--------------
 // Include Files
-#include <stdio.h>
+//#include <stdio.h>
 #include <gameos.hpp>
 
 //***************************************************************************


  ================================================
diff --git a/source/mclib/estring.cpp b/source/mclib/estring.cpp
index cd346de..7cf7059 100755
--- a/source/mclib/estring.cpp
+++ b/source/mclib/estring.cpp
@@ -16,10 +16,9 @@
 #include <tchar.h>
 #endif
 
-#pragma warning( disable:4505 )
-
-#pragma warning( push )
-#pragma warning( disable:4100 )
+//#pragma warning( disable:4505 )
+//#pragma warning( push )
+//#pragma warning( disable:4100 )
 
 
 #define INT_SIZE_LENGTH 20
@@ -233,7 +232,7 @@ inline	unsigned short*	EString::ToUnicode( unsigned short* p_Buffer,
 
 	p_Buffer[0] = 0;
 
-	MultiByteToWideChar( CP_ACP, 0, (const char*)p_Str, -1, p_Buffer, Num_Chars );
+	MultiByteToWideChar( CP_ACP, 0, (const char*)p_Str, -1, (PWCHAR)p_Buffer, Num_Chars );
 
 	return p_Buffer;	
 }
@@ -704,7 +703,7 @@ void EString::Format( const EChar* p_Str, ... )
 			   Item_Len = 6;  // "(null)"
 			else
 			{
-			   Item_Len = wcslen(p_Next_Arg);
+			   Item_Len = wcslen((PWCHAR)p_Next_Arg);
 			   Item_Len = max(1, Item_Len);
 			}
 #else
@@ -1572,4 +1571,4 @@ const EString& EString::operator=( char Char )
 
 //****************************************************************
 
-#pragma warning( pop )
\ No newline at end of file
+//#pragma warning( pop )
\ No newline at end of file


  ================================================
diff --git a/source/mclib/ewcharstring.cpp b/source/mclib/ewcharstring.cpp
index ad6c53d..16e232a 100755
--- a/source/mclib/ewcharstring.cpp
+++ b/source/mclib/ewcharstring.cpp
@@ -40,10 +40,9 @@
 #include <tchar.h>
 #endif
 
-#pragma warning( disable:4505 )
-
-#pragma warning( push )
-#pragma warning( disable:4100 )
+//#pragma warning( disable:4505 )
+//#pragma warning( push )
+//#pragma warning( disable:4100 )
 
 #define INT_SIZE_LENGTH 20
 extern int __ismbcodepage;
@@ -241,7 +240,7 @@ EWCharString::EBuffer*   EWCharString::EBuffer::s_p_Empty_Buffer = &EWCharString
 // inlines
 #define A2W(p_String) (\
 	((const char*)p_String == NULL) ? NULL : (\
-	EWCharString::ToUnicode( (LPWSTR)_alloca((lstrlenA(p_String)+1)*2),\
+	EWCharString::ToUnicode( (unsigned short*)_alloca((lstrlenA(p_String)+1)*2),\
 	(const unsigned char*)p_String, (lstrlenA(p_String)+1)*2)))
 
 // if this doesn't want to link properly, this will have to become
@@ -256,7 +255,7 @@ inline	unsigned short*	EWCharString::ToUnicode( unsigned short* p_Buffer,
 
 	p_Buffer[0] = 0;
 
-	MultiByteToWideChar( CP_ACP, 0, (const char*)p_Str, -1, p_Buffer, Num_Chars );
+	MultiByteToWideChar(CP_ACP, 0, (const char*)p_Str, -1, (PWSTR)p_Buffer, Num_Chars );
 
 	return p_Buffer;	
 }
@@ -266,7 +265,7 @@ inline int EWCharString::StrSize( const EWCSChar* p_Str )
 {
 	return ( p_Str == NULL  ? 0 : 
 #ifdef UNICODE 
-	wcslen( p_Str )
+	wcslen( (PWCHAR)p_Str )
 #else 
 	lstrlen( (const char*)p_Str )
 #endif 
@@ -550,14 +549,14 @@ void EWCharString::Swap( EWCharString& Src )
 void EWCharString::MakeUpper()
 {
 	ChecEBufferDoRealloc();
-	KToUpper( m_pBuffer->Data() );
+	KToUpper( (PWSTR)m_pBuffer->Data() );
 }
 
 ///////////////////////////////////////////////////////////////
 void EWCharString::MakeLower()
 {
 	ChecEBufferDoRealloc();
-	KToLower( m_pBuffer->Data() );
+	KToLower( (PWSTR)m_pBuffer->Data() );
 }
 
 ///////////////////////////////////////////////////////////////
@@ -565,7 +564,7 @@ void EWCharString::Reverse()
 {
 	ChecEBufferDoRealloc();
 	
-	KReverse( m_pBuffer->Data() );
+	KReverse( (PWSTR)m_pBuffer->Data() );
 }
 
 // works like sprintf
@@ -610,11 +609,11 @@ void EWCharString::Format( const EWCSChar* p_Str, ... )
 		if ( Width == 0)
 		{
 			// width indicated by
-			Width = KToI(p_Tmp);
+			Width = KToI((PWCHAR)p_Tmp);
 			unsigned short buffer;
 			for (; *p_Tmp != '\0'; )
 			{
-				GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, p_Tmp, 1, &buffer);
+				GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, (PWSTR)p_Tmp, 1, &buffer);
 				if (buffer == C1_DIGIT || buffer == C1_XDIGIT)
 					p_Tmp = KSInc(p_Tmp);
 				else
@@ -638,11 +637,11 @@ void EWCharString::Format( const EWCSChar* p_Str, ... )
 			}
 			else
 			{
-				Precision = KToI(p_Tmp);
+				Precision = KToI((PWCHAR)p_Tmp);
 				for (; *p_Tmp != '\0'; )
 				{
 					unsigned short buffer;
-					GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, p_Tmp, 1, &buffer);
+					GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, (PWSTR)p_Tmp, 1, &buffer);
 					//if (buffer == C1_DIGIT || buffer == C1_XDIGIT)
 					if (buffer & C1_DIGIT)	//mh
 						p_Tmp = KSInc(p_Tmp);
@@ -838,7 +837,7 @@ void EWCharString::Format( const EWCSChar* p_Str, ... )
 	}
 
 #ifdef UNICODE
-	vswprintf(m_pBuffer->Data(), p_Str, Arg_List_Save);
+	vswprintf((PWCHAR)m_pBuffer->Data(), (PWCHAR)p_Str, Arg_List_Save);
 #else
 	vsprintf(m_pBuffer->Data(), p_Str, Arg_List_Save);
 #endif
@@ -955,7 +954,7 @@ int EWCharString::Compare( const EWCSChar* p_String, bool Case_Sensitive ) const
 	{
 		return ( memcmp( m_pBuffer->Data(), p_String, Length ) );
 	}	
-	return (KStrCmp( m_pBuffer->Data(), p_String ) );
+	return (KStrCmp( (PWCHAR)m_pBuffer->Data(), (PWCHAR)p_String ) );
 	
 }
  	
@@ -971,7 +970,7 @@ int EWCharString::Length() const	// number of characters
 {
 
 #ifdef UNICODE
-	return wcslen( m_pBuffer->Data() );
+	return wcslen( (PWCHAR)m_pBuffer->Data() );
 #else
 	return lstrlen( (char*)m_pBuffer->Data() );
 #endif
@@ -1013,8 +1012,8 @@ int EWCharString::Find( const EWCharString& Str_To_Find, int Start_Index ) const
 		Start_Index = 0;
 	}
 	
-	EWCSChar* p_Tmp = KStrStr( m_pBuffer->Data() + Start_Index, 
-							Str_To_Find.m_pBuffer->Data() );
+	EWCSChar* p_Tmp = (EWCSChar*)KStrStr( (PWCHAR)(m_pBuffer->Data() + Start_Index), 
+							(PWCHAR)(Str_To_Find.m_pBuffer->Data()) );
 
 	return ( p_Tmp ? p_Tmp - m_pBuffer->Data() : INVALID_INDEX );
 }
@@ -1028,8 +1027,8 @@ int EWCharString::Find( const EWCSChar* p_Str_To_Find, int Start_Index ) const
 	}
 
 	
-	EWCSChar* p_Tmp = KStrStr( m_pBuffer->Data() + Start_Index, 
-							p_Str_To_Find );
+	EWCSChar* p_Tmp = (EWCSChar*)KStrStr((PWCHAR)(m_pBuffer->Data() + Start_Index), 
+							(PWCHAR)p_Str_To_Find );
 
 	return ( p_Tmp ? p_Tmp - m_pBuffer->Data() : INVALID_INDEX );
 
@@ -1121,7 +1120,7 @@ char* 	EWCharString::CreateMBCS() const
 	char* p_Ret_String = new char[m_pBuffer->m_Data_Length + 1];
 
 #ifdef K_UNICODE
-	wcstombs( p_Ret_String, m_pBuffer->Data(), m_pBuffer->m_Data_Length + 1  );
+	wcstombs( p_Ret_String, (PWCHAR)(m_pBuffer->Data()), m_pBuffer->m_Data_Length + 1  );
 
 #else
 	 memcpy( p_Ret_String, m_pBuffer->Data(), m_pBuffer->m_Data_Length + 1 );
@@ -1146,7 +1145,7 @@ EWCharString::EWCharString(const  char* p_String )
 {
 	if ( p_String )
 	{
-		Assign( A2W( p_String ) );
+		Assign( (EWCSChar*)A2W( p_String ) );
 	}
 }
 		
@@ -1551,7 +1550,7 @@ int EWCharString::Find( char Char, int Start_Index ) const
 {
 	EWCSChar Tmp; 
 
-	mbtowc( &Tmp, &Char, 1 );
+	mbtowc( (PWCHAR)&Tmp, &Char, 1 );
 	
 	return Find( Tmp, Start_Index );
 }
@@ -1561,7 +1560,7 @@ const EWCharString& EWCharString::operator=( char Char )
 {
 	EWCSChar Tmp; 
 
-	mbtowc( &Tmp, &Char, 1 );
+	mbtowc( (PWCHAR)&Tmp, &Char, 1 );
 
 	return operator=( Tmp );
 }
@@ -1598,4 +1597,4 @@ const EWCharString& EWCharString::operator=( char Char )
 
 //****************************************************************
 
-#pragma warning( pop )
\ No newline at end of file
+//#pragma warning( pop )
\ No newline at end of file


  ================================================
diff --git a/source/mclib/fastfile.cpp b/source/mclib/fastfile.cpp
index 600385d..9dac95e 100755
--- a/source/mclib/fastfile.cpp
+++ b/source/mclib/fastfile.cpp
@@ -93,7 +93,7 @@ DWORD elfHash (char *name)
     while ( *name )
     {
         h = ( h << 4 ) + *name++;
-        if ( g = h & 0xF0000000 )
+        if ((g = h & 0xF0000000) != 0)
             h ^= g >> 24;
         h &= ~g;
     }


  ================================================
diff --git a/source/mclib/ffile.cpp b/source/mclib/ffile.cpp
index f37dc7b..f992a3e 100755
--- a/source/mclib/ffile.cpp
+++ b/source/mclib/ffile.cpp
@@ -227,7 +227,7 @@ long FastFile::openFast (DWORD hash, char *fName)
 	//-- In order to use this, the file name must be part of the index.
 	for (long i=0;i<numFiles;i++)
 	{
-		if ((hash == files[i].pfe->hash) && (stricmp(files[i].pfe->name,fName) == 0))
+		if ((hash == files[i].pfe->hash) && (_stricmp(files[i].pfe->name,fName) == 0))
 		{
 			files[i].inuse = TRUE;
 			files[i].pos = 0;


  ================================================
diff --git a/source/mclib/file.cpp b/source/mclib/file.cpp
index eeb1274..f6c55bb 100755
--- a/source/mclib/file.cpp
+++ b/source/mclib/file.cpp
@@ -1564,7 +1564,7 @@ char* File::getFilename (void)
 //---------------------------------------------------------------------------
 time_t File::getFileMTime (void)
 {
-	time_t mTime;
+	time_t mTime = 0;
 
 	if (isOpen())
 	{


  ================================================
diff --git a/source/mclib/floathelp.cpp b/source/mclib/floathelp.cpp
index f4525b8..d183e5e 100755
--- a/source/mclib/floathelp.cpp
+++ b/source/mclib/floathelp.cpp
@@ -6,6 +6,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //--------------------------
 // Include Files


  ================================================
diff --git a/source/mclib/gamelog.cpp b/source/mclib/gamelog.cpp
index 39194e6..ee4fbbc 100755
--- a/source/mclib/gamelog.cpp
+++ b/source/mclib/gamelog.cpp
@@ -121,7 +121,8 @@ GameLog* GameLog::getNewFile (void) {
 		setup();
 
 	long fileHandle = -1;
-	for (long i = 0; i < MAX_GAMELOGS; i++)
+	long i;
+	for (i = 0; i < MAX_GAMELOGS; i++)
 		if (!files[i]->inUse) {
 			fileHandle = i;
 			break;


  ================================================
diff --git a/source/mclib/genactor.cpp b/source/mclib/genactor.cpp
index ced3d14..45b7412 100755
--- a/source/mclib/genactor.cpp
+++ b/source/mclib/genactor.cpp
@@ -276,10 +276,11 @@ void GenericAppearance::init (AppearanceTypePtr tree, GameObjectPtr obj)
 	if (appearType)
 	{
 		genShape = appearType->genShape->CreateFrom();
+		long i;
 
 		//-------------------------------------------------
 		// Load the texture and store its handle.
-		for (long i=0;i<genShape->GetNumTextures();i++)
+		for (i=0;i<genShape->GetNumTextures();i++)
 		{
 			char txmName[1024];
 			if ((i == 0) && (appearType->textureName[0]))


  ================================================
diff --git a/source/mclib/gosfx/card.cpp b/source/mclib/gosfx/card.cpp
index 4e1f5f1..3e29f1d 100755
--- a/source/mclib/gosfx/card.cpp
+++ b/source/mclib/gosfx/card.cpp
@@ -2,8 +2,9 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "gosFXHeaders.hpp"
-#include <MLR\MLRCardCloud.hpp>
+#include "stdafx.h"
+#include "gosfxheaders.hpp"
+#include <mlr\mlrcardcloud.hpp>
 
 //############################################################################
 //########################  gosFX::Card__Specification  #############################


  ================================================
diff --git a/source/mclib/gosfx/cardcloud.cpp b/source/mclib/gosfx/cardcloud.cpp
index ae1ec5d..74223d1 100755
--- a/source/mclib/gosfx/cardcloud.cpp
+++ b/source/mclib/gosfx/cardcloud.cpp
@@ -2,8 +2,9 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "gosFXHeaders.hpp"
-#include <MLR\MLRCardCloud.hpp>
+#include "stdafx.h"
+#include "gosfxheaders.hpp"
+#include <mlr\mlrcardcloud.hpp>
 
 //------------------------------------------------------------------------------
 //


  ================================================
diff --git a/source/mclib/gosfx/debriscloud.cpp b/source/mclib/gosfx/debriscloud.cpp
index 1562ffc..069fc63 100755
--- a/source/mclib/gosfx/debriscloud.cpp
+++ b/source/mclib/gosfx/debriscloud.cpp
@@ -1,5 +1,3 @@
-#include "gosFXHeaders.hpp"
-
 //==========================================================================//
 // File:	 gosFX_DebrisCloud.cpp											//
 // Contents: Base gosFX::DebrisCloud Component								//
@@ -11,6 +9,9 @@
 //########################  gosFX::DebrisCloud__Specification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosfxheaders.hpp"
+
 //------------------------------------------------------------------------------
 //
 gosFX::DebrisCloud__Specification::DebrisCloud__Specification(


  ================================================
diff --git a/source/mclib/gosfx/effect.cpp b/source/mclib/gosfx/effect.cpp
index 4be9ac6..1c77cef 100755
--- a/source/mclib/gosfx/effect.cpp
+++ b/source/mclib/gosfx/effect.cpp
@@ -1,4 +1,3 @@
-#include "gosFXHeaders.hpp"
 
 //==========================================================================//
 // File:	 gosFX_Effect.cpp												//
@@ -11,6 +10,9 @@
 //########################  EffectSpecification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+
 //------------------------------------------------------------------------------
 //
 gosFX::Event::Event(const Event& event):


  ================================================
diff --git a/source/mclib/gosfx/effectcloud.cpp b/source/mclib/gosfx/effectcloud.cpp
index 19ae1b3..c74527c 100755
--- a/source/mclib/gosfx/effectcloud.cpp
+++ b/source/mclib/gosfx/effectcloud.cpp
@@ -1,11 +1,12 @@
-#include "gosFXHeaders.hpp"
-
 //==========================================================================//
 // File:	 gosFX_EffectCloud.cpp											//
 // Contents: Base gosFX::EffectCloud Component								//
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
+
+#include "gosFXHeaders.hpp"
 
 //------------------------------------------------------------------------------
 //


  ================================================
diff --git a/source/mclib/gosfx/effectlibrary.cpp b/source/mclib/gosfx/effectlibrary.cpp
index bfffd75..b440dc8 100755
--- a/source/mclib/gosfx/effectlibrary.cpp
+++ b/source/mclib/gosfx/effectlibrary.cpp
@@ -1,5 +1,3 @@
-#include "gosFXHeaders.hpp"
-
 //==========================================================================//
 // File:	 gosFX_Effect.cpp												//
 // Contents: Base gosFX::Effect Component									//
@@ -7,6 +5,9 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+
 gosFX::EffectLibrary*
 	gosFX::EffectLibrary::Instance = NULL;
 


  ================================================
diff --git a/source/mclib/gosfx/effectlibrary.hpp b/source/mclib/gosfx/effectlibrary.hpp
index 7c848c1..d37fcd8 100755
--- a/source/mclib/gosfx/effectlibrary.hpp
+++ b/source/mclib/gosfx/effectlibrary.hpp
@@ -54,7 +54,7 @@ namespace gosFX
 			Instance;
 
 	protected:
-		EffectLibrary(EffectLibrary &source)
+		EffectLibrary(EffectLibrary& /*source*/)
 			{STOP(("Shouldn't be called"));}
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  ================================================
diff --git a/source/mclib/gosfx/fcurve.cpp b/source/mclib/gosfx/fcurve.cpp
index 5f8921b..f02a99a 100755
--- a/source/mclib/gosfx/fcurve.cpp
+++ b/source/mclib/gosfx/fcurve.cpp
@@ -4,6 +4,7 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
 #include "gosFXHeaders.hpp"
 
 //##########################################################################
@@ -722,8 +723,8 @@ gosFX::Curve::TranslateTo(Stuff::Scalar pos,int curvenum)
 			Stuff::Scalar delta,x1,x2,y1,y2,slp;
 			
 			delta=pos-SCurve->ComputeValue(0.0f,0.0f);
-			
-			for(int key=0;key<SCurve->GetKeyCount()-1;key++)
+			int key;
+			for(key=0;key<SCurve->GetKeyCount()-1;key++)
 			{
 				x1=(*SCurve)[key].m_time;
 				x2=(*SCurve)[key+1].m_time;
@@ -874,8 +875,8 @@ gosFX::Curve::TranslateBy(Stuff::Scalar delta,int curvenum)
 			ComplexCurve *SCurve=(ComplexCurve *)this;
 			Stuff::Scalar x1,x2,y1,y2;
 			
-			
-			for(int key=0;key<SCurve->GetKeyCount()-1;key++)
+			int key;
+			for(key=0;key<SCurve->GetKeyCount()-1;key++)
 			{
 				x1=(*SCurve)[key].m_time;
 				x2=(*SCurve)[key+1].m_time;
@@ -1035,8 +1036,8 @@ gosFX::Curve::AxisScale(Stuff::Scalar sfactor,Stuff::Scalar axis,int curvenum)
 			ComplexCurve *SCurve=(ComplexCurve *)this;
 			Stuff::Scalar x1,x2,y1,y2;
 			
-			
-			for(int key=0;key<SCurve->GetKeyCount()-1;key++)
+			int key;
+			for(key=0;key<SCurve->GetKeyCount()-1;key++)
 			{
 				x1=(*SCurve)[key].m_time;
 				x2=(*SCurve)[key+1].m_time;


  ================================================
diff --git a/source/mclib/gosfx/fcurve.hpp b/source/mclib/gosfx/fcurve.hpp
index 68e1836..8858dd8 100755
--- a/source/mclib/gosfx/fcurve.hpp
+++ b/source/mclib/gosfx/fcurve.hpp
@@ -13,8 +13,7 @@ namespace gosFX {
 	class Curve
 	{
 	public:
-		enum CurveType
-		{
+		typedef enum CurveType {
 			e_ConstantType,
 			e_LinearType,
 			e_SplineType,
@@ -27,7 +26,7 @@ namespace gosFX {
 			e_ConstantSplineType,
 			e_SplineLinearType,
 			e_SplineSplineType
-		};
+		} CurveType;
 
 		const CurveType
 			m_type;
@@ -140,7 +139,7 @@ namespace gosFX {
 			)
 				{
 					Check_Object(this); Check_Pointer(low); Check_Pointer(hi);
-					*hi = *low = m_value;
+					if(hi && low) *hi = *low = m_value;
 				}
 	};
 
@@ -340,7 +339,7 @@ namespace gosFX {
 		CurveKey&
 			operator[](int index)
 				{Check_Object(this); return m_keys[index];}
-		int
+		size_t
 			GetKeyCount()
 				{Check_Object(this); return m_keys.GetLength();}
 		int
@@ -348,7 +347,7 @@ namespace gosFX {
 				{
 					Check_Object(this);
 					int i;
-					for (i=0; i<m_keys.GetLength(); ++i)
+					for (i=0; i<(int)m_keys.GetLength(); ++i)
 						if (m_keys[i].m_time > time)
 							break;
 					return --i;


  ================================================
diff --git a/source/mclib/gosfx/gosfx.cpp b/source/mclib/gosfx/gosfx.cpp
index 30e33f2..2637aab 100755
--- a/source/mclib/gosfx/gosfx.cpp
+++ b/source/mclib/gosfx/gosfx.cpp
@@ -2,10 +2,10 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "gosFXHeaders.hpp"
+#include "stdafx.h"
+#include "gosfxheaders.hpp"
 
-HGOSHEAP
-	gosFX::Heap = NULL;
+HGOSHEAP gosFX::Heap = NULL;
 
 DEFINE_TIMER(gosFX, Animation_Time);
 DEFINE_TIMER(gosFX, Draw_Time);


  ================================================
diff --git a/source/mclib/gosfx/gosfx.hpp b/source/mclib/gosfx/gosfx.hpp
index 6469634..8b3c965 100755
--- a/source/mclib/gosfx/gosfx.hpp
+++ b/source/mclib/gosfx/gosfx.hpp
@@ -6,7 +6,7 @@
 
 #pragma once
 
-#include <Stuff\Stuff.hpp>
+#include <stuff\stuff.hpp>
 
 namespace gosFX
 {
@@ -16,7 +16,7 @@ namespace gosFX
 	// gosFX classes
 	//--------------
 	//
-	enum {
+	typedef enum __gosFX_const {
 		EffectClassID = Stuff::FirstgosFXClassID,
 			ParticleCloudClassID,
 				PointCloudClassID,


  ================================================
diff --git a/source/mclib/gosfx/gosfxheaders.hpp b/source/mclib/gosfx/gosfxheaders.hpp
index 5f3167d..e386cd1 100755
--- a/source/mclib/gosfx/gosfxheaders.hpp
+++ b/source/mclib/gosfx/gosfxheaders.hpp
@@ -4,18 +4,18 @@
 
 #pragma once
 
-#include "gosFX.hpp"
-#include "Effect.hpp"
-#include "ParticleCloud.hpp"
-#include "PointCloud.hpp"
-#include "ShardCloud.hpp"
-#include "PertCloud.hpp"
-#include "ShapeCloud.hpp"
-#include "CardCloud.hpp"
-#include "EffectCloud.hpp"
-#include "EffectLibrary.hpp"
-#include "Card.hpp"
-#include "Shape.hpp"
-#include "Tube.hpp"
-#include "DebrisCloud.hpp"
-#include "PointLight.hpp"
+#include "gosfx.hpp"
+#include "effect.hpp"
+#include "particlecloud.hpp"
+#include "pointcloud.hpp"
+#include "shardcloud.hpp"
+#include "pertcloud.hpp"
+#include "shapecloud.hpp"
+#include "cardcloud.hpp"
+#include "effectcloud.hpp"
+#include "effectlibrary.hpp"
+#include "card.hpp"
+#include "shape.hpp"
+#include "tube.hpp"
+#include "debriscloud.hpp"
+#include "pointlight.hpp"


  ================================================
diff --git a/source/mclib/gosfx/particlecloud.cpp b/source/mclib/gosfx/particlecloud.cpp
index 5d6449e..7328d00 100755
--- a/source/mclib/gosfx/particlecloud.cpp
+++ b/source/mclib/gosfx/particlecloud.cpp
@@ -1,5 +1,3 @@
-#include "gosFXHeaders.hpp"
-
 //==========================================================================//
 // File:	 gosFX_ParticleCloud.cpp										//
 // Contents: Base gosFX::ParticleCloud Component							//
@@ -11,6 +9,9 @@
 //########################  gosFX::ParticleCloud__Specification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+
 //------------------------------------------------------------------------------
 //
 gosFX::ParticleCloud__Specification::ParticleCloud__Specification(


  ================================================
diff --git a/source/mclib/gosfx/pertcloud.cpp b/source/mclib/gosfx/pertcloud.cpp
index 25a1271..027e1cc 100755
--- a/source/mclib/gosfx/pertcloud.cpp
+++ b/source/mclib/gosfx/pertcloud.cpp
@@ -1,6 +1,3 @@
-#include "gosFXHeaders.hpp"
-#include <MLR\MLRNGonCloud.hpp>
-
 //==========================================================================//
 // File:	 gosFX_gosFX::PertCloud.cpp										//
 // Contents: Base gosFX::PertCloud Component								//
@@ -8,6 +5,10 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+#include <MLR\MLRNGonCloud.hpp>
+
 //------------------------------------------------------------------------------
 //
 gosFX::PertCloud__Specification::PertCloud__Specification(
@@ -359,7 +360,8 @@ void
 	int even = 1;
 	particle->m_vertices[0] = Stuff::Point3D::Identity;
 	Stuff::Scalar bound = 0.0f;
-	for (int j=1; j<spec->m_vertices-1; j++)
+	int j;
+	for (j=1; j<spec->m_vertices-1; j++)
 	{
 		Stuff::Scalar perturbance =
 			even * spec->m_perturbation.ComputeValue(m_age, particle->m_seed);


  ================================================
diff --git a/source/mclib/gosfx/pointcloud.cpp b/source/mclib/gosfx/pointcloud.cpp
index 29a9732..413817d 100755
--- a/source/mclib/gosfx/pointcloud.cpp
+++ b/source/mclib/gosfx/pointcloud.cpp
@@ -1,6 +1,3 @@
-#include "gosFXHeaders.hpp"
-#include <MLR\MLRPointCloud.hpp>
-
 //==========================================================================//
 // File:	 gosFX_PointCloud.cpp											//
 // Contents: Base gosFX::PointCloud Component								//
@@ -12,6 +9,11 @@
 //########################  gosFX::PointCloud__Specification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+#include <MLR\MLRPointCloud.hpp>
+
+
 //------------------------------------------------------------------------------
 //
 gosFX::PointCloud__Specification::PointCloud__Specification(


  ================================================
diff --git a/source/mclib/gosfx/pointlight.cpp b/source/mclib/gosfx/pointlight.cpp
index 5cd8171..bf25b81 100755
--- a/source/mclib/gosfx/pointlight.cpp
+++ b/source/mclib/gosfx/pointlight.cpp
@@ -2,6 +2,7 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
 #include "gosFXHeaders.hpp"
 #include <MLR\MLRPointLight.hpp>
 


  ================================================
diff --git a/source/mclib/gosfx/shape.cpp b/source/mclib/gosfx/shape.cpp
index 160ffb7..a256cdb 100755
--- a/source/mclib/gosfx/shape.cpp
+++ b/source/mclib/gosfx/shape.cpp
@@ -1,5 +1,3 @@
-#include "gosFXHeaders.hpp"
-
 //==========================================================================//
 // File:	 gosFX_Shape.cpp											    //
 // Contents: Base gosFX::Shape Component									//
@@ -11,6 +9,9 @@
 //########################  gosFX::Shape__Specification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+
 //------------------------------------------------------------------------------
 //
 gosFX::Shape__Specification::Shape__Specification(


  ================================================
diff --git a/source/mclib/gosfx/shapecloud.cpp b/source/mclib/gosfx/shapecloud.cpp
index 301ca3a..6955426 100755
--- a/source/mclib/gosfx/shapecloud.cpp
+++ b/source/mclib/gosfx/shapecloud.cpp
@@ -1,5 +1,3 @@
-#include "gosFXHeaders.hpp"
-
 //==========================================================================//
 // File:	 gosFX_ShapeCloud.cpp											//
 // Contents: Base gosFX::ShapeCloud Component								//
@@ -11,6 +9,9 @@
 //########################  gosFX::ShapeCloud__Specification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+
 //------------------------------------------------------------------------------
 //
 gosFX::ShapeCloud__Specification::ShapeCloud__Specification(


  ================================================
diff --git a/source/mclib/gosfx/shardcloud.cpp b/source/mclib/gosfx/shardcloud.cpp
index cdd191f..fccdb72 100755
--- a/source/mclib/gosfx/shardcloud.cpp
+++ b/source/mclib/gosfx/shardcloud.cpp
@@ -1,6 +1,3 @@
-#include "gosFXHeaders.hpp"
-#include <MLR\MLRTriangleCloud.hpp>
-
 //==========================================================================//
 // File:	 gosFX_ShardCloud.cpp											//
 // Contents: Base gosFX::ShardCloud Component								//
@@ -8,6 +5,10 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+#include <MLR\MLRTriangleCloud.hpp>
+
 //------------------------------------------------------------------------------
 //
 gosFX::ShardCloud__Specification::ShardCloud__Specification(


  ================================================
diff --git a/source/mclib/gosfx/singleton.cpp b/source/mclib/gosfx/singleton.cpp
index c3234f4..60148c1 100755
--- a/source/mclib/gosfx/singleton.cpp
+++ b/source/mclib/gosfx/singleton.cpp
@@ -1,5 +1,3 @@
-#include "gosFXHeaders.hpp"
-
 //==========================================================================//
 // File:	 gosFX_Singleton.cpp										    //
 // Contents: Base gosFX::Singleton Component								//
@@ -11,6 +9,9 @@
 //########################  gosFX::Singleton__Specification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosFXHeaders.hpp"
+
 //------------------------------------------------------------------------------
 //
 gosFX::Singleton__Specification::Singleton__Specification(


  ================================================
diff --git a/source/mclib/gosfx/spinningcloud.cpp b/source/mclib/gosfx/spinningcloud.cpp
index 6fc097a..3a7b8d2 100755
--- a/source/mclib/gosfx/spinningcloud.cpp
+++ b/source/mclib/gosfx/spinningcloud.cpp
@@ -1,5 +1,3 @@
-#include "gosFXHeaders.hpp"
-
 //==========================================================================//
 // File:	 gosFX_SpinningCloud.cpp										//
 // Contents: Base gosFX::SpinningCloud Component							//
@@ -11,6 +9,9 @@
 //########################  gosFX::SpinningCloud__Specification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosfxheaders.hpp"
+
 //------------------------------------------------------------------------------
 //
 gosFX::SpinningCloud__Specification::SpinningCloud__Specification(


  ================================================
diff --git a/source/mclib/gosfx/tube.cpp b/source/mclib/gosfx/tube.cpp
index 017e0d3..01b5921 100755
--- a/source/mclib/gosfx/tube.cpp
+++ b/source/mclib/gosfx/tube.cpp
@@ -1,6 +1,3 @@
-#include "gosFXHeaders.hpp"
-#include <MLR\MLRIndexedTriangleCloud.hpp>
-
 //==========================================================================//
 // File:	 gosFX_Tube.cpp										            //
 // Contents: Base gosFX::Tube Component									    //
@@ -12,6 +9,10 @@
 //########################  gosFX::Tube__Specification  #############################
 //############################################################################
 
+#include "stdafx.h"
+#include "gosfxheaders.hpp"
+#include <mlr\mlrindexedtrianglecloud.hpp>
+
 //------------------------------------------------------------------------------
 //
 gosFX::Tube__Specification::Tube__Specification(


  ================================================
diff --git a/source/mclib/gvactor.cpp b/source/mclib/gvactor.cpp
index d09e8af..264be01 100755
--- a/source/mclib/gvactor.cpp
+++ b/source/mclib/gvactor.cpp
@@ -119,10 +119,11 @@ void GVAppearanceType::init (char * fileName)
 
 	char aseFileName[512];
 	result = iniFile.readIdString("FileName",aseFileName,511);
+	long i;
 	if (result != NO_ERR)
 	{
 		//Check for LOD filenames instead
-		for (long i=0;i<MAX_LODS;i++)
+		for (i=0;i<MAX_LODS;i++)
 		{
 			char baseName[256];
 			char baseLODDist[256];
@@ -220,7 +221,7 @@ void GVAppearanceType::init (char * fileName)
 	//--------------------------------------------------------------------
 	// Load Animation Information.
 	// We can load up to 10 Animation States.
-	for (long i=0;i<MAX_GV_ANIMATIONS;i++)
+	for (i=0;i<MAX_GV_ANIMATIONS;i++)
 	{
 		char blockId[512];
 		sprintf(blockId,"Animation:%d",i);
@@ -362,8 +363,9 @@ void GVAppearanceType::init (char * fileName)
 void GVAppearanceType::destroy (void)
 {
 	AppearanceType::destroy();
+	long i;
 
-	for (long i=0;i<MAX_LODS;i++)
+	for (i=0;i<MAX_LODS;i++)
 	{
 		if (gvShape[i])
 		{
@@ -740,10 +742,11 @@ void GVAppearance::init (AppearanceTypePtr tree, GameObjectPtr obj)
 	if (appearType)
 	{
 		gvShape = appearType->gvShape[0]->CreateFrom();
+		long i;
 	
 		//-------------------------------------------------
 		// Load the texture and store its handle.
-		for (long i=0;i<gvShape->GetNumTextures();i++)
+		for (i=0;i<gvShape->GetNumTextures();i++)
 		{
 			char txmName[1024];
 			gvShape->GetTextureName(i,txmName,256);
@@ -1754,7 +1757,7 @@ bool GVAppearance::recalcBounds (void)
 						}
 						
 						// we are at this LOD level.
-						if (selectLOD != currentLOD)
+						if (selectLOD != (DWORD)currentLOD)
 						{
 							currentLOD = selectLOD;
 


  ================================================
diff --git a/source/mclib/heap.cpp b/source/mclib/heap.cpp
index f072f4b..a487ab5 100755
--- a/source/mclib/heap.cpp
+++ b/source/mclib/heap.cpp
@@ -8,6 +8,12 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
+//#include <windows.h>
+//#include <imagehlp.h>
+//#include <tchar.h>
+//#include <stdio.h>             // For sprintf
+//#include <string.h>            // For strchr
 
 //---------------------------------------------------------------------------
 // Include Files
@@ -19,15 +25,8 @@
 #include "file.h"
 #endif
 
-#include <windows.h>
-#include <imagehlp.h>
-
 #include <gameos.hpp>
 
-#include <tchar.h>
-#include <stdio.h>             // For sprintf
-#include <string.h>            // For strchr
-
 //---------------------------------------------------------------------------
 // Static Globals
 static char CorruptMsg[] = "Heap check failed.\n";
@@ -83,7 +82,7 @@ char* DecodeAddress( DWORD Address , bool brief);
 #define CHECK_HEAP
 #endif
 
-#ifdef LAB_ONLY
+#if defined(LAB_ONLY)
 #define CHECK_HEAP
 #endif
 


  ================================================
diff --git a/source/mclib/inifile.h b/source/mclib/inifile.h
index bcc4eb5..9f04268 100755
--- a/source/mclib/inifile.h
+++ b/source/mclib/inifile.h
@@ -8,6 +8,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
+
 #ifndef INIFILE_H
 #define INIFILE_H
 //---------------------------------------------------------------------------


  ================================================
diff --git a/source/mclib/lzcomp.cpp b/source/mclib/lzcomp.cpp
index ff27052..ecbaa14 100755
--- a/source/mclib/lzcomp.cpp
+++ b/source/mclib/lzcomp.cpp
@@ -4,6 +4,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef _MBCS
 #include <gameos.hpp>


  ================================================
diff --git a/source/mclib/lzdecomp.cpp b/source/mclib/lzdecomp.cpp
index 3ea6571..4bc8dd3 100755
--- a/source/mclib/lzdecomp.cpp
+++ b/source/mclib/lzdecomp.cpp
@@ -4,6 +4,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Static Globals


  ================================================
diff --git a/source/mclib/mapdata.cpp b/source/mclib/mapdata.cpp
index 6a937c9..e70373d 100755
--- a/source/mclib/mapdata.cpp
+++ b/source/mclib/mapdata.cpp
@@ -763,7 +763,8 @@ void MapData::makeLists (VertexPtr vertexList, long &numVerts, TerrainQuadPtr qu
 	VertexPtr currentVertex = vertexList;
 	numVerts = 0;
 
-	for (int y=0;y<Terrain::visibleVerticesPerSide;y++)
+	int y;
+	for (y=0;y<Terrain::visibleVerticesPerSide;y++)
 	{
 		for (int x=0;x<Terrain::visibleVerticesPerSide;x++)
 		{


  ================================================
diff --git a/source/mclib/mathfunc.cpp b/source/mclib/mathfunc.cpp
index fb401e4..533ccc4 100755
--- a/source/mclib/mathfunc.cpp
+++ b/source/mclib/mathfunc.cpp
@@ -2,6 +2,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+
 #ifndef STUFF_STUFF_HPP
 #include <stuff/stuff.hpp>
 #endif


  ================================================
diff --git a/source/mclib/mathfunc.h b/source/mclib/mathfunc.h
index 255eec9..c4f9599 100755
--- a/source/mclib/mathfunc.h
+++ b/source/mclib/mathfunc.h
@@ -112,7 +112,7 @@ long SignedRandomNumber (long range);
 
 bool RollDice (long percent);
 
-_inline long float2long (float val)
+inline long float2long (float val)
 {
 	//_ftol TRUNCS not rounds.  Processor wants to round.  Surely there is some flag to not have this happen?
 	// There is but BOY is it slow.  We will try Andy's Magical formula instead.
@@ -156,7 +156,7 @@ _inline long float2long (float val)
 }
 
 //---------------------------------------------------------------------------
-_inline float mc2_atan2 (float f1, float f2)
+inline float mc2_atan2 (float f1, float f2)
 {
 	//Return atan of f1/f2;
 	float result = 1.570796f;
@@ -177,7 +177,8 @@ _inline float mc2_atan2 (float f1, float f2)
 }
 
 //---------------------------------------------------------------------------
-_inline float fmax (float f1, float f2)
+#if _CONSIDERED_OBSOLETE
+inline float fmax (float f1, float f2)
 {
 	if (f1 > f2)
 		return f1;
@@ -186,16 +187,17 @@ _inline float fmax (float f1, float f2)
 }
 
 //---------------------------------------------------------------------------
-_inline float fmin (float f1, float f2)
+inline float fmin (float f1, float f2)
 {
 	if (f1 < f2)
 		return f1;
 	else
 		return f2;
 }
+#endif
 
 //---------------------------------------------------------------------------
-_inline float sign (float f1)
+inline float sign (float f1)
 {
 	if (f1 < 0.0f)
 		return -1.0f;


  ================================================
diff --git a/source/mclib/mclib.h b/source/mclib/mclib.h
index 4a92878..27592bd 100755
--- a/source/mclib/mclib.h
+++ b/source/mclib/mclib.h
@@ -6,6 +6,7 @@
 // Precompiled header for the mechcommander libraries.
 //
 //-----------------------------------------------------------------------
+#pragma once
 
 #ifndef MCLIB_H
 #define MCLIB_H


  ================================================
diff --git a/source/mclib/mech3d.cpp b/source/mclib/mech3d.cpp
index 99d2abd..4a9d53f 100755
--- a/source/mclib/mech3d.cpp
+++ b/source/mclib/mech3d.cpp
@@ -243,11 +243,12 @@ void Mech3DAppearanceType::init (char * fileName)
 
 	char aseFileName[512];
 	result = mechFile.readIdString("FileName",aseFileName,511);
+	long i;
 	if (result != NO_ERR)
 	{
 		//Check for LOD filenames
 		char aseFileName[512];
-		for (long i=0;i<MAX_LODS;i++)
+		for (i=0;i<MAX_LODS;i++)
 		{
 			char baseName[256];
 			char baseLODDist[256];
@@ -1088,7 +1089,8 @@ void Mech3DAppearance::init (AppearanceTypePtr tree, GameObjectPtr obj)
 		
 		//-------------------------------------------------
 		// Load the texture and store its handle.
-		for (long i=0;i<sensorTriangleShape->GetNumTextures();i++)
+		long i;
+		for (i=0;i<sensorTriangleShape->GetNumTextures();i++)
 		{
 			char txmName[1024];
 			sensorTriangleShape->GetTextureName(i,txmName,256);
@@ -2262,7 +2264,7 @@ bool Mech3DAppearance::recalcBounds (void)
 						}
 
 						// we are at this LOD level.
-						if (selectLOD != currentLOD)
+						if (selectLOD != (DWORD)currentLOD)
 						{
 							currentLOD = selectLOD;
 


  ================================================
diff --git a/source/mclib/mech3d.h b/source/mclib/mech3d.h
index 03b9530..444e8ec 100755
--- a/source/mclib/mech3d.h
+++ b/source/mclib/mech3d.h
@@ -10,6 +10,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
+
 #ifndef MECH3D_H
 #define MECH3D_H
 //-------------------------------------------------------------------------------
@@ -132,11 +134,11 @@ class Mech3DAppearanceType: public AppearanceType
 		static TG_TypeMultiShapePtr	SensorSquareShape;
 
 		static bool animationLoadingEnabled;
-		static disableAnimationLoading(void)
+		static void disableAnimationLoading(void)
 		{
 			animationLoadingEnabled = false;
 		}
-		static enableAnimationLoading(void)
+		static void enableAnimationLoading(void)
 		{
 			animationLoadingEnabled = true;
 		}


  ================================================
diff --git a/source/mclib/mlr/gospoint.hpp b/source/mclib/mlr/gospoint.hpp
index 26a7b3f..7180398 100755
--- a/source/mclib/mlr/gospoint.hpp
+++ b/source/mclib/mlr/gospoint.hpp
@@ -89,7 +89,7 @@ namespace MidLevelRenderer {
 
 	typedef Stuff::Vector2DOf<Stuff::Scalar> Vector2DScalar;
 	
-	#pragma warning (disable : 4725)
+	//#pragma warning (disable : 4725)
 
 //	copies 3 vertex data into rasterizer format
 	inline bool


  ================================================
diff --git a/source/mclib/mlr/gosvertex.hpp b/source/mclib/mlr/gosvertex.hpp
index d6e94aa..1340f9f 100755
--- a/source/mclib/mlr/gosvertex.hpp
+++ b/source/mclib/mlr/gosvertex.hpp
@@ -5,9 +5,9 @@
 #pragma once
 #define MLR_GOSVERTEX_HPP
 
-#include <MLR\MLR.hpp>
-#include <Stuff\Scalar.hpp>
-#include <GameOS.hpp>
+#include <mlr\mlr.hpp>
+#include <stuff\scalar.hpp>
+#include <gameos.hpp>
 
 namespace MidLevelRenderer {
 
@@ -95,7 +95,7 @@ namespace MidLevelRenderer {
 				}
 
 		inline GOSVertex&
-			operator=(const DWORD c)
+			operator=(const ULONG c)
 				{
 					Check_Pointer(this);
 
@@ -148,7 +148,7 @@ namespace MidLevelRenderer {
 	const float float_cheat = 12582912.0f/256.0f;
 	const float One_Over_256 = 1.0f/256.0f;
 
-	#pragma warning (disable : 4725)
+	//#pragma warning (disable : 4725)
 
 void
 	GOSVertex::GOSTransformNoClip(
@@ -159,6 +159,7 @@ void
 				, int foggy
 #endif
 	)
+
 {
 	Check_Pointer(this);
 	Check_Object(&_v);
@@ -168,7 +169,6 @@ void
 	Stuff::Scalar *f = &x;
 	_asm {
 		mov         edx, m
-		
 		mov         eax, _v
 
 		fld			dword ptr [eax]			//	v.x
@@ -267,10 +267,10 @@ void
 
 	}
 #else
-	x = v.x*m(0,0) + v.y*m(1,0) + v.z*m(2,0) + m(3,0);
-	y = v.x*m(0,1) + v.y*m(1,1) + v.z*m(2,1) + m(3,1);
-	z = v.x*m(0,2) + v.y*m(1,2) + v.z*m(2,2) + m(3,2);
-	rhw = v.x*m(0,3) + v.y*m(1,3) + v.z*m(2,3) + m(3,3);
+	x = _v.x*m(0,0) + _v.y*m(1,0) + _v.z*m(2,0) + m(3,0);
+	y = _v.x*m(0,1) + _v.y*m(1,1) + _v.z*m(2,1) + m(3,1);
+	z = _v.x*m(0,2) + _v.y*m(1,2) + _v.z*m(2,2) + m(3,2);
+	rhw = _v.x*m(0,3) + _v.y*m(1,3) + _v.z*m(2,3) + m(3,3);
 #endif
 	
 #if 0	//USE_ASSEMBLER_CODE
@@ -342,12 +342,13 @@ void
 }
 
 //	create a dword color out of 4 rgba floats
-	inline DWORD
+	inline ULONG
 		GOSCopyColor( const Stuff::RGBAColor *color )
 	{
 		Stuff::Scalar f;
+		ULONG argb;
+
 #if USE_ASSEMBLER_CODE
-		DWORD argb;
 
 		_asm {
 			fld		float_cheat
@@ -497,10 +498,10 @@ void
 		return argb;
 	}
 
-	inline DWORD
+	inline ULONG
 		Color_DWORD_Lerp (
-			DWORD _from,
-			DWORD _to,
+			ULONG _from,
+			ULONG _to,
 			Stuff::Scalar _lerp
 		)
 	{
@@ -546,40 +547,40 @@ void
 	//	the lines below will produce following functions:
 	//
 	//	bool GOSCopyData(GOSVertex*, const Stuff::Vector4D*, int);
-	//	bool GOSCopyData(GOSVertex*, const Stuff::Vector4D*, const DWORD*, int);
+	//	bool GOSCopyData(GOSVertex*, const Stuff::Vector4D*, const ULONG*, int);
 	//	bool GOSCopyData(GOSVertex*, const Stuff::Vector4D*, const RGBAColor*, int);
 	//	bool GOSCopyData(GOSVertex*, const Stuff::Vector4D*, const Vector2DScalar*, int);
-	//	bool GOSCopyData(GOSVertex*, const Stuff::Vector4D*, const DWORD*, const Vector2DScalar*, int);
+	//	bool GOSCopyData(GOSVertex*, const Stuff::Vector4D*, const ULONG*, const Vector2DScalar*, int);
 	//	bool GOSCopyData(GOSVertex*, const Stuff::Vector4D*, const RGBAColor*, const Vector2DScalar*, int);
 	//
 	//	bool GOSCopyTriangleData(GOSVertex*, const Stuff::Vector4D*, int, int, int);
-	//	bool GOSCopyTriangleData(GOSVertex*, const Stuff::Vector4D*, const DWORD*, int, int, int);
+	//	bool GOSCopyTriangleData(GOSVertex*, const Stuff::Vector4D*, const ULONG*, int, int, int);
 	//	bool GOSCopyTriangleData(GOSVertex*, const Stuff::Vector4D*, const RGBAColor*, int, int, int);
 	//	bool GOSCopyTriangleData(GOSVertex*, const Stuff::Vector4D*, const Vector2DScalar*, int, int, int);
-	//	bool GOSCopyTriangleData(GOSVertex*, const Stuff::Vector4D*, const DWORD*, const Vector2DScalar*, int, int, int);
+	//	bool GOSCopyTriangleData(GOSVertex*, const Stuff::Vector4D*, const ULONG*, const Vector2DScalar*, int, int, int);
 	//	bool GOSCopyTriangleData(GOSVertex*, const Stuff::Vector4D*, const RGBAColor*, const Vector2DScalar*, int, int, int);
 	//#######################################################################################################################
 
 	#define I_SAY_YES_TO_COLOR
 	#define I_SAY_YES_TO_TEXTURE
 	#define I_SAY_YES_TO_DWORD_COLOR
-	#include <MLR\GOSVertexManipulation.hpp>
+	#include <mlr\gosvertexmanipulation.hpp>
 
 	#undef I_SAY_YES_TO_DWORD_COLOR
-	#include <MLR\GOSVertexManipulation.hpp>
+	#include <mlr\gosvertexmanipulation.hpp>
 
 	#undef I_SAY_YES_TO_COLOR
-	#include <MLR\GOSVertexManipulation.hpp>
+	#include <mlr\gosvertexmanipulation.hpp>
 
 	#define I_SAY_YES_TO_COLOR
 	#undef I_SAY_YES_TO_TEXTURE
-	#include <MLR\GOSVertexManipulation.hpp>
+	#include <mlr\gosvertexmanipulation.hpp>
 
 	#define I_SAY_YES_TO_DWORD_COLOR
-	#include <MLR\GOSVertexManipulation.hpp>
+	#include <mlr\gosvertexmanipulation.hpp>
 
 	#undef I_SAY_YES_TO_COLOR
-	#include <MLR\GOSVertexManipulation.hpp>
+	#include <mlr\gosvertexmanipulation.hpp>
 
 	#define MLR_GOSVERTEXMANIPULATION_HPP
 


  ================================================
diff --git a/source/mclib/mlr/gosvertex2uv.hpp b/source/mclib/mlr/gosvertex2uv.hpp
index 6d1cb13..b01ab22 100755
--- a/source/mclib/mlr/gosvertex2uv.hpp
+++ b/source/mclib/mlr/gosvertex2uv.hpp
@@ -116,7 +116,7 @@ namespace MidLevelRenderer {
 	protected:
 	};
 
-	#pragma warning (disable : 4725)
+	//#pragma warning (disable : 4725)
 
 void
 	GOSVertex2UV::GOSTransformNoClip(


  ================================================
diff --git a/source/mclib/mlr/gosvertexmanipulation.hpp b/source/mclib/mlr/gosvertexmanipulation.hpp
index c09ca86..938ddfb 100755
--- a/source/mclib/mlr/gosvertexmanipulation.hpp
+++ b/source/mclib/mlr/gosvertexmanipulation.hpp
@@ -105,6 +105,9 @@ inline bool GOSCopyData (
 			gos_vertices[0].v = 0.0f;
 	#endif	//	I_SAY_YES_TO_MULTI_TEXTURE
 #endif	//	I_SAY_YES_TO_TEXTURE
+#if FOG_HACK
+	(void)foggy;
+#endif
 
 	return true;
 }
@@ -272,6 +275,10 @@ inline bool GOSCopyTriangleData (
 	#endif	//	I_SAY_YES_TO_MULTI_TEXTURE
 #endif	//	I_SAY_YES_TO_TEXTURE
 
+#if FOG_HACK
+	(void)foggy;
+#endif
+
 	return true;
 }
 


  ================================================
diff --git a/source/mclib/mlr/mlr.cpp b/source/mclib/mlr/mlr.cpp
index a2d8cc7..c27e863 100755
--- a/source/mclib/mlr/mlr.cpp
+++ b/source/mclib/mlr/mlr.cpp
@@ -2,7 +2,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "MLRHeaders.hpp"
+
+#include "mlrheaders.hpp"
 
 DWORD	gShowClippedPolys=0;
 DWORD	gShowBirdView=0;


  ================================================
diff --git a/source/mclib/mlr/mlrcardcloud.hpp b/source/mclib/mlr/mlrcardcloud.hpp
index 22ec35b..0e38e5d 100755
--- a/source/mclib/mlr/mlrcardcloud.hpp
+++ b/source/mclib/mlr/mlrcardcloud.hpp
@@ -6,11 +6,11 @@
 #define MLR_MLRCardCloud_HPP
 
 #if !defined(MLR_MLR_HPP)
-	#include <MLR\MLR.hpp>
+	#include <mlr\mlr.hpp>
 #endif
 
 #if !defined(MLR_MLREFFECT_HPP)
-	#include <MLR\MLREffect.hpp>
+	#include <mlr\mlreffect.hpp>
 #endif
 
 namespace MidLevelRenderer {


  ================================================
diff --git a/source/mclib/mlr/mlrheaders.cpp b/source/mclib/mlr/mlrheaders.cpp
index cf9c1ac..a0f7d72 100755
--- a/source/mclib/mlr/mlrheaders.cpp
+++ b/source/mclib/mlr/mlrheaders.cpp
@@ -2,6 +2,6 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "MLRHeaders.hpp"
+#include "mlrheaders.hpp"
 
 // This file does nothing but make the pch file
\ No newline at end of file


  ================================================
diff --git a/source/mclib/mlr/mlrheaders.hpp b/source/mclib/mlr/mlrheaders.hpp
index 7f07011..7004928 100755
--- a/source/mclib/mlr/mlrheaders.hpp
+++ b/source/mclib/mlr/mlrheaders.hpp
@@ -6,53 +6,53 @@
 #define MLR_MLRHEADERS_HPP
 
 #if !defined(MLR_MLR_HPP)
-	#include <MLR\MLR.hpp>
+	#include <mlr\mlr.hpp>
 #endif
 
 using namespace MidLevelRenderer;
 using namespace Stuff;
 
-#include <MLR\MLRPointCloud.hpp>
-#include <MLR\MLRTriangleCloud.hpp>
-#include <MLR\MLRAmbientLight.hpp>
-#include <MLR\MLRInfiniteLight.hpp>
-#include <MLR\MLRInfiniteLightWithFalloff.hpp>
-#include <MLR\MLRLightMap.hpp>
-#include <MLR\MLRPointLight.hpp>
-#include <MLR\MLRSpotLight.hpp>
-
-#include <MLR\MLRPrimitiveBase.hpp>
-#include <MLR\MLRIndexedPrimitiveBase.hpp>
-#include <MLR\MLR_I_PMesh.hpp>
-#include <MLR\MLR_I_C_PMesh.hpp>
-#include <MLR\MLR_I_L_PMesh.hpp>
-#include <MLR\MLR_I_DT_PMesh.hpp>
-#include <MLR\MLR_I_C_DT_PMesh.hpp>
-#include <MLR\MLR_I_L_DT_PMesh.hpp>
-#include <MLR\MLRNGonCloud.hpp>
-#include <MLR\MLRCardCloud.hpp>
-
-#include <MLR\MLR_I_MT_PMesh.hpp>
-
-#include <MLR\MLR_I_DeT_PMesh.hpp>
-#include <MLR\MLR_I_C_DeT_PMesh.hpp>
-#include <MLR\MLR_I_L_DeT_PMesh.hpp>
-
-#include <MLR\MLR_I_TMesh.hpp>
-#include <MLR\MLR_I_DeT_TMesh.hpp>
-#include <MLR\MLR_I_C_TMesh.hpp>
-#include <MLR\MLR_I_L_TMesh.hpp>
-
-#include <MLR\MLR_Terrain.hpp>
-#include <MLR\MLR_Terrain2.hpp>
-
-#include <MLR\MLRLineCloud.hpp>
-#include <MLR\MLRIndexedTriangleCloud.hpp>
-
-#include <MLR\MLR_I_DT_TMesh.hpp>
-#include <MLR\MLR_I_C_DT_TMesh.hpp>
-#include <MLR\MLR_I_L_DT_TMesh.hpp>
-#include <MLR\MLR_I_C_DeT_TMesh.hpp>
-#include <MLR\MLR_I_L_DeT_TMesh.hpp>
-
-#include <MLR\MLRLookUpLight.hpp>
\ No newline at end of file
+#include <mlr\mlrpointcloud.hpp>
+#include <mlr\mlrtrianglecloud.hpp>
+#include <mlr\mlrambientlight.hpp>
+#include <mlr\mlrinfinitelight.hpp>
+#include <mlr\mlrinfinitelightwithfalloff.hpp>
+#include <mlr\mlrlightmap.hpp>
+#include <mlr\mlrpointlight.hpp>
+#include <mlr\mlrspotlight.hpp>
+
+#include <mlr\mlrprimitivebase.hpp>
+#include <mlr\mlrindexedprimitivebase.hpp>
+#include <mlr\mlr_i_pmesh.hpp>
+#include <mlr\mlr_i_c_pmesh.hpp>
+#include <mlr\mlr_i_l_pmesh.hpp>
+#include <mlr\mlr_i_dt_pmesh.hpp>
+#include <mlr\mlr_i_c_dt_pmesh.hpp>
+#include <mlr\mlr_i_l_dt_pmesh.hpp>
+#include <mlr\mlrngoncloud.hpp>
+#include <mlr\mlrcardcloud.hpp>
+
+#include <mlr\mlr_i_mt_pmesh.hpp>
+
+#include <mlr\mlr_i_det_pmesh.hpp>
+#include <mlr\mlr_i_c_det_pmesh.hpp>
+#include <mlr\mlr_i_l_det_pmesh.hpp>
+
+#include <mlr\mlr_i_tmesh.hpp>
+#include <mlr\mlr_i_det_tmesh.hpp>
+#include <mlr\mlr_i_c_tmesh.hpp>
+#include <mlr\mlr_i_l_tmesh.hpp>
+
+#include <mlr\mlr_terrain.hpp>
+#include <mlr\mlr_terrain2.hpp>
+
+#include <mlr\mlrlinecloud.hpp>
+#include <mlr\mlrindexedtrianglecloud.hpp>
+
+#include <mlr\mlr_i_dt_tmesh.hpp>
+#include <mlr\mlr_i_c_dt_tmesh.hpp>
+#include <mlr\mlr_i_l_dt_tmesh.hpp>
+#include <mlr\mlr_i_c_det_tmesh.hpp>
+#include <mlr\mlr_i_l_det_tmesh.hpp>
+
+#include <mlr\mlrlookuplight.hpp>
\ No newline at end of file


  ================================================
diff --git a/source/mclib/mlr/mlrindexedprimitivebase.cpp b/source/mclib/mlr/mlrindexedprimitivebase.cpp
index 3343d93..344bb17 100755
--- a/source/mclib/mlr/mlrindexedprimitivebase.cpp
+++ b/source/mclib/mlr/mlrindexedprimitivebase.cpp
@@ -161,7 +161,7 @@ void
 #endif
 	coords.AssignData(data, dataSize);
 
-	if(index.GetLength() > 0 && visibleIndexedVertices.GetLength() != dataSize)
+	if(index.GetLength() > size_t(0) && visibleIndexedVertices.GetLength() != (size_t)dataSize)
 	{
 		visibleIndexedVertices.SetLength(dataSize);
 	}


  ================================================
diff --git a/source/mclib/mlr/mlrloadobj.cpp b/source/mclib/mlr/mlrloadobj.cpp
index ab9877f..4013391 100755
--- a/source/mclib/mlr/mlrloadobj.cpp
+++ b/source/mclib/mlr/mlrloadobj.cpp
@@ -37,7 +37,7 @@ const int CHUNK = 4096;
 const int MAX_MTL_FILES = 512;
 
 // case insensitive string equality test 
-#define        SAME(_a, _b)        (stricmp(_a,_b) == 0)
+#define        SAME(_a, _b)        (_stricmp(_a,_b) == 0)
 
 // list of textures defined by Wavefront material files 
 typedef struct TEX


  ================================================
diff --git a/source/mclib/mlr/mlrprimitivebase.hpp b/source/mclib/mlr/mlrprimitivebase.hpp
index 6deec6f..26dcb53 100755
--- a/source/mclib/mlr/mlrprimitivebase.hpp
+++ b/source/mclib/mlr/mlrprimitivebase.hpp
@@ -202,14 +202,14 @@ namespace MidLevelRenderer {
 				{ Check_Object(this); return passes; }
 
 		virtual void
-			HurtMe(const Stuff::LinearMatrix4D&, Stuff::Scalar radius)
+			HurtMe(const Stuff::LinearMatrix4D&, Stuff::Scalar /*radius*/)
 				{ Check_Object(this); }
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// This functions using the static buffers
 	//
 		void
-			SetClipCoord(Stuff::Point3D &point, int index)
+			SetClipCoord(Stuff::Point3D &point, size_t index)
 				{
 					Check_Object(this); Verify(clipExtraCoords->GetLength() > index);
 					(*clipExtraCoords)[index].x = point.x;
@@ -217,11 +217,11 @@ namespace MidLevelRenderer {
 					(*clipExtraCoords)[index].z = point.z;
 				}
 		void
-			FlashClipCoords(int num)
+			FlashClipCoords(size_t num)
 				{
 					Check_Object(this); Verify(clipExtraCoords->GetLength() > num);
 					coords.SetLength(num);
-					for(int i=0;i<num;i++)
+					for(size_t i=0;i<num;i++)
 					{
 						coords[i].x = (*clipExtraCoords)[i].x;
 						coords[i].y = (*clipExtraCoords)[i].y;
@@ -229,7 +229,7 @@ namespace MidLevelRenderer {
 					}
 				}
 		void
-			SetClipTexCoord(Vector2DScalar &uvs, int index)
+			SetClipTexCoord(Vector2DScalar &uvs, size_t index)
 				{
 					Check_Object(this); Verify(clipExtraTexCoords->GetLength() > index);
 					Verify(	MLRState::GetHasMaxUVs() ? (uvs[0]>=-100.0 && uvs[0]<=100.0) : 1);
@@ -238,7 +238,7 @@ namespace MidLevelRenderer {
 					(*clipExtraTexCoords)[index] = uvs;
 				}
 		void
-			FlashClipTexCoords(int num)
+			FlashClipTexCoords(size_t num)
 				{
 					Check_Object(this); Verify(clipExtraTexCoords->GetLength() > num);
 					texCoords.SetLength(num);


  ================================================
diff --git a/source/mclib/mouse.cpp b/source/mclib/mouse.cpp
index 6eaf134..e815f1a 100755
--- a/source/mclib/mouse.cpp
+++ b/source/mclib/mouse.cpp
@@ -41,12 +41,14 @@
 //
 //
 //-----------------------------------------------------------------------
+#include "stdafx.h"
+
+//#include <windows.h>
+//#include <mmsystem.h>
+//#include <ddraw.h>
 
 #include "dstd.h"
 #include "userinput.h"
-#include <windows.h>
-#include <mmsystem.h>
-#include <ddraw.h>
 #include <gameos.hpp>
 
 extern volatile bool mc2IsInDisplayBackBuffer;
@@ -76,7 +78,7 @@ void (*AsynFunc)(RECT& WinRect,DDSURFACEDESC2& mouseSurfaceDesc ) = 0;
 
 
 //External GameOS stuff
-extern IDirectDrawSurface7*	FrontBufferSurface;
+extern LPDIRECTDRAWSURFACE7	FrontBufferSurface;
 extern HWND					hWindow;
 extern POINT				clientToScreen;
 extern DWORD 				MouseInWindow;
@@ -164,7 +166,7 @@ void CALLBACK MouseTimer(UINT wTimerID, UINT msg, DWORD dwUser, DWORD dw1, DWORD
 	HRESULT lockResult = -1;
 	HRESULT unlockResult = -1;
 	RECT WinRect;
-	DDSURFACEDESC2 mouseSurfaceDesc;
+	DDSURFACEDESC2 mouseSurfaceDesc = {0};
 	mouseSurfaceDesc.dwSize = sizeof(DDSURFACEDESC2);
 	long screenX = Environment.screenWidth;
 	long screenY = Environment.screenHeight;


  ================================================
diff --git a/source/mclib/move.cpp b/source/mclib/move.cpp
index d22ff7c..cde951e 100755
--- a/source/mclib/move.cpp
+++ b/source/mclib/move.cpp
@@ -803,7 +803,8 @@ void MissionMap::init (long h, long w) {
 	MapCellDiagonal = Terrain::worldUnitsPerCell * 1.4142 * metersPerWorldUnit;
 	HalfMapCell = Terrain::worldUnitsPerCell / 2.0;
 
-	for (long i = 0; i < MAX_MAP_CELL_WIDTH; i++)
+	long i;
+	for (i = 0; i < MAX_MAP_CELL_WIDTH; i++)
 		tileMulMAPCELL_DIM[i] = i * MAPCELL_DIM;
 
 	long tileWidth = width / MAPCELL_DIM;
@@ -1549,7 +1550,8 @@ long GlobalMap::init (PacketFilePtr packetFile, long whichPacket) {
 	doorInfos = (DoorInfoPtr)systemHeap->Malloc(sizeof(DoorInfo) * numDoorInfos);
 	gosASSERT(doorInfos != NULL);
 	long curDoorInfo = 0;
-	for (long i = 0; i < numAreas; i++)
+	long i;
+	for (i = 0; i < numAreas; i++)
 		if (areas[i].numDoors) {
 			result = packetFile->readPacket(whichPacket++, (unsigned char*)&doorInfos[curDoorInfo]);
 			if (result == 0)
@@ -1614,7 +1616,7 @@ long GlobalMap::init (PacketFilePtr packetFile, long whichPacket) {
 
 	if (logEnabled && !blank) {
 		char s[256];
-		for (long i = 0; i < numDoors; i++) {
+		for (i = 0; i < numDoors; i++) {
 			sprintf(s, "door %05d, %s(%d), areas %d & %d", i, doors[i].open ? "opened" : "CLOSED", doors[i].teamID, doors[i].area[0], doors[i].area[1]);
 			log->write(s);
 			for (long side = 0; side < 2; side++) {
@@ -1669,7 +1671,8 @@ long GlobalMap::write (PacketFilePtr packetFile, long whichPacket) {
 	// If mapFile NULL, return the number of packets we need...
 
 	long numDrInfos = 0;
-	for (long i = 0; i < numAreas; i++)
+	long i;
+	for (i = 0; i < numAreas; i++)
 		if (areas[i].numDoors)
 			numDrInfos++;
 #ifdef USE_PATH_COST_TABLE
@@ -3892,6 +3895,7 @@ void GlobalMap::destroy (void) {
 
 bool GlobalMap::toggleLog (void) {
 
+	long i;
 	if (!log) {
 		GameLog::setup();
 		log = GameLog::getNewFile();
@@ -3904,7 +3908,7 @@ bool GlobalMap::toggleLog (void) {
 		GlobalMapPtr map = GlobalMoveMap[0];
 		if (true) {
 			char s[256];
-			for (long i = 0; i < map->numDoors; i++) {
+			for (i = 0; i < map->numDoors; i++) {
 				sprintf(s, "door %05d, %s(%d), areas %d & %d", i, map->doors[i].open ? "opened" : "CLOSED", map->doors[i].teamID, map->doors[i].area[0], map->doors[i].area[1]);
 				log->write(s);
 				for (long side = 0; side < 2; side++) {
@@ -3990,7 +3994,8 @@ void MoveMap::init (long maxW, long maxH) {
 
 	mapRowStartTable = (long*)systemHeap->Malloc(maxHeight * sizeof(long));
 	gosASSERT(mapRowStartTable != NULL);
-	for (long r = 0; r < maxHeight; r++)
+	long r;
+	for (r = 0; r < maxHeight; r++)
 		mapRowStartTable[r] = r * maxWidth;
 
 	mapRowTable = (long*)systemHeap->Malloc(maxHeight * maxWidth * sizeof(long));
@@ -4208,12 +4213,13 @@ inline long MoveMap::markGoals (Stuff::Vector3D finalGoal) {
 					}
 		}
 
+		long c;
 		if (!nextToGoal) {
 			long adjCost = clearCost / 2;
 			long doorCenter = doorLength / 2;
 			long cellIndex = cellR * maxWidth + cellC;
 			long curCost = doorCenter * adjCost;
-			for (long c = 0; c < doorCenter; c++) {
+			for (c = 0; c < doorCenter; c++) {
 				if (doorCellState[c]) {
 					map[cellIndex].setFlag(MOVEFLAG_GOAL);
 					numGoalCells++;
@@ -4247,13 +4253,13 @@ inline long MoveMap::markGoals (Stuff::Vector3D finalGoal) {
 				numGoalCells++;
 				nextToGoal = true;
 			}
-			
+		long r;	
 		if (!nextToGoal) {
 			long adjCost = clearCost / 2;
 			long doorCenter = doorLength / 2;
 			long cellIndex = cellR * maxWidth + cellC;
 			long curCost = doorCenter * adjCost;
-			for (long r = 0; r < doorCenter; r++) {
+			for (r = 0; r < doorCenter; r++) {
 				if (doorCellState[r]) {
 					map[cellIndex].setFlag(MOVEFLAG_GOAL);
 					numGoalCells++;
@@ -4481,7 +4487,9 @@ long MoveMap::setUp (long mapULr,
 	else
 		map[goalR * maxWidth + goalC].setFlag(MOVEFLAG_GOAL);
 
+#ifdef LAB_ONLY
 	__int64 startTime = GetCycles();
+#endif
 
 	if (params & MOVEPARAM_STATIONARY_MOVERS)
 		if (placeStationaryMoversCallback)
@@ -4508,7 +4516,9 @@ long MoveMap::setUp (long level,
 					 long offsets,
 					 unsigned long params) {
 
+#ifdef LAB_ONLY
 	__int64 startTime = GetCycles();
+#endif
 
 	//-----------------------------------------------------------------------------
 	// If the map has not been allocated yet, then the tile height and width passed
@@ -4767,8 +4777,12 @@ inline bool MoveMap::adjacentCellOpenJUMP (long r, long c, long dir) {
 
 //---------------------------------------------------------------------------
 
-inline long MoveMap::calcHPrime (long r, long c) {
+inline long MoveMap::calcHPrime (long r, long c)
+{
+#ifdef LAB_ONLY
 	__int64 startTime = GetCycles();
+#endif
+
 	long sum = 0;
 	if (r > goalR)
 		sum += (r - goalR);
@@ -6344,7 +6358,8 @@ void MoveMap::writeDebug (File* debugFile) {
 	
 	debugFile->writeString("PARENT:\n");
 	debugFile->writeString("-------\n");
-	for (long r = 0; r < height; r++) {
+	long r;
+	for (r = 0; r < height; r++) {
 		outString[0] = NULL;
 		char numStr[10];
 		for (long c = 0; c < width; c++) {


  ================================================
diff --git a/source/mclib/msl.cpp b/source/mclib/msl.cpp
index 301771e..cebd663 100755
--- a/source/mclib/msl.cpp
+++ b/source/mclib/msl.cpp
@@ -13,6 +13,8 @@
 //
 //-------------------------------------------------------------------------------
 
+#include "stdafx.h"
+
 //-------------------------------------------------------------------------------
 // Include Files
 #ifndef MSL_H
@@ -61,7 +63,7 @@ extern long		ObjectTextureSize;
 
 #define CURRENT_SHAPE_VERSION		0xBAFDECAF
 #define CURRENT_ANIM_VERSION		0xBADDECAF
-#define MAX_PATH					256
+//#define MAX_PATH					256
 
 //-------------------------------------------------------------------------------
 void GetNextLine (char *rawData, char *result)
@@ -128,7 +130,8 @@ TG_MultiShapePtr TG_TypeMultiShape::CreateFrom (void)
 
 	memset(newShape->listOfShapes,0,sizeof(TG_ShapeRec) * numTG_TypeShapes);
 
-	for (long i=0;i<numTG_TypeShapes;i++)
+	long i, j;
+	for (i=0;i<numTG_TypeShapes;i++)
 	{
 		newShape->listOfShapes[i].node = listOfTypeShapes[i]->CreateFrom();
 	}
@@ -149,7 +152,7 @@ TG_MultiShapePtr TG_TypeMultiShape::CreateFrom (void)
 
 		//----------------------------------------------------------------------------------
 		// For each shape, look for another node whose NodeId matches this shape's parentId
-		for (long j=0;j<numTG_TypeShapes;j++)
+		for (j=0;j<numTG_TypeShapes;j++)
 		{
 			if (strcmp(newShape->listOfShapes[i].node->myType->getParentId(),newShape->listOfShapes[j].node->myType->getNodeId()) == 0)
 			{
@@ -206,7 +209,8 @@ long TG_TypeMultiShape::LoadBinaryCopy (char *fileName)
 	
 		memset(listOfTypeShapes,0,sizeof(TG_TypeNodePtr) * numTG_TypeShapes);
 	
-		for (long i=0;i<numTG_TypeShapes;i++)
+		long i, j;
+		for (i=0;i<numTG_TypeShapes;i++)
 		{
 			long nodeType = binFile.readLong();
 			
@@ -238,7 +242,7 @@ long TG_TypeMultiShape::LoadBinaryCopy (char *fileName)
 			{
 				//------------------------------------------------------------------
 				// Scan list of vertices and create minBox, maxBox and extentRadius
-				for (long j=0;j<listOfTypeShapes[i]->GetNumTypeVertices();j++)
+				for (j=0;j<listOfTypeShapes[i]->GetNumTypeVertices();j++)
 				{
 					Stuff::Vector3D relNodeCenter;
 					relNodeCenter = listOfTypeShapes[i]->GetRelativeNodeCenter();
@@ -381,6 +385,7 @@ long TG_TypeMultiShape::LoadTGMultiShapeFromASE (char *fileName, bool forceMakeB
 	// MUCH FASTER!
 	//
 	bool makeBinary = false;
+	long i, j;
 
 	char drive[MAX_PATH];
 	char dir[MAX_PATH];
@@ -555,7 +560,7 @@ long TG_TypeMultiShape::LoadTGMultiShapeFromASE (char *fileName, bool forceMakeB
 			memset(listOfTextures,0x0,sizeof(TG_Texture) * numTextures);
 
 			char *txmData = (char *)aseContents;
-			for (long i=0;i<(numTextures/2);i++)
+			for (i=0;i<(numTextures/2);i++)
 			{
 				//-------------------------------------------------------------------------------
 				// Get and store texture Name.  Will need multiple for Multi-Sub if implemented
@@ -806,12 +811,12 @@ long TG_TypeMultiShape::LoadTGMultiShapeFromASE (char *fileName, bool forceMakeB
 		// FOURTH PASS.  Setup Heirarchy ALWAYS or NO Shape BOUNDS!!!
 		{
 			aseScan = (char *)aseContents;
-			for (long i=0;i<numTG_TypeShapes;i++)
+			for (i=0;i<numTG_TypeShapes;i++)
 			{
 				//----------------------------------------------------------------------------------
 				// For each shape, look for another node whose NodeId matches this shape's parentId
 				TG_TypeNodePtr parentNode = NULL;
-				for (long j=0;j<numTG_TypeShapes;j++)
+				for (j=0;j<numTG_TypeShapes;j++)
 				{
 					if (strcmp(listOfTypeShapes[i]->getParentId(),listOfTypeShapes[j]->getNodeId()) == 0)
 					{
@@ -957,7 +962,7 @@ long TG_MultiShape::SetNodeRotation (char *nodeName, Stuff::UnitQuaternion *rot)
 {
 	for (long i=0;i<numTG_Shapes;i++)
 	{
-		if (stricmp(listOfShapes[i].node->myType->getNodeId(),nodeName) == 0)
+		if (_stricmp(listOfShapes[i].node->myType->getNodeId(),nodeName) == 0)
 		{
 			//-------------------------------
 			// Found it!
@@ -1082,7 +1087,7 @@ Stuff::Vector3D TG_MultiShape::GetTransformedNodePosition (Stuff::Point3D *pos,
 		// Scan through the list of shapes and dig out the number needed.
 		// DO NOT UPDATE THE HEIRARCHY!!!!
 		// This thing may not have updated itself this turn yet!!!
-		if (stricmp(listOfShapes[i].node->myType->getNodeId(),nodeId) == 0)
+		if (_stricmp(listOfShapes[i].node->myType->getNodeId(),nodeId) == 0)
 		{
 			result.x = -listOfShapes[i].shapeToWorld.entries[3];
 			result.z = listOfShapes[i].shapeToWorld.entries[7];
@@ -1162,7 +1167,7 @@ long TG_MultiShape::TransformMultiShape (Stuff::Point3D *pos, Stuff::UnitQuatern
 	shadowOrigin.BuildRotation(Stuff::EulerAngles(-angles.pitch,0.0f,0.0f));
 	shadowOrigin.BuildTranslation(*pos);
 	
-	long i=0;
+	long i, j;
 	Stuff::Point3D camPosition;
 	camPosition = *TG_Shape::cameraOrigin;
 
@@ -1175,7 +1180,7 @@ long TG_MultiShape::TransformMultiShape (Stuff::Point3D *pos, Stuff::UnitQuatern
 	{
 		//----------------------------------------------
 		// Must set each transform!  Animating Textures!
-		for (long j=0;j<myMultiType->numTextures;j++)
+		for (j=0;j<myMultiType->numTextures;j++)
 		{
 			listOfShapes[i].node->myType->SetTextureHandle(j,myMultiType->listOfTextures[j].mcTextureNodeIndex);
 			listOfShapes[i].node->myType->SetTextureAlpha(j,myMultiType->listOfTextures[j].textureAlpha); 
@@ -1597,7 +1602,7 @@ void TG_MultiShape::StopUsing (char *nodeName)
 		zero.x = zero.y = zero.z = 0.0f;
 		for (long j=curChild;j>=0;j--)
 		{
-			if (stricmp(childChain[j]->node->getNodeName(),nodeName) == 0)
+			if (_stricmp(childChain[j]->node->getNodeName(),nodeName) == 0)
 			{
 				detachables[curShape] = childChain[0];
 				curShape++;
@@ -1610,7 +1615,7 @@ void TG_MultiShape::StopUsing (char *nodeName)
 	for (i=0;i<curShape;i++)
 	{
 		//Keep the joint_xUARM so that the shoulder sparks work.
-		if (stricmp(detachables[i]->node->getNodeName(),nodeName) != 0)
+		if (_stricmp(detachables[i]->node->getNodeName(),nodeName) != 0)
 			detachables[i]->processMe = false;
 	}
 }
@@ -1645,7 +1650,7 @@ TG_MultiShapePtr TG_MultiShape::Detach (char *nodeName)
 		zero.x = zero.y = zero.z = 0.0f;
 		for (long j=curChild;j>=0;j--)
 		{
-			if (stricmp(childChain[j]->node->getNodeName(),nodeName) == 0)
+			if (_stricmp(childChain[j]->node->getNodeName(),nodeName) == 0)
 			{
 				detachables[curShape] = childChain[0];
 				curShape++;
@@ -1676,7 +1681,7 @@ TG_MultiShapePtr TG_MultiShape::Detach (char *nodeName)
 	{
 		resultShape->listOfShapes[i] = *detachables[i];
 		
-		if (stricmp(resultShape->listOfShapes[i].node->getNodeName(),nodeName) == 0)
+		if (_stricmp(resultShape->listOfShapes[i].node->getNodeName(),nodeName) == 0)
 			resultShape->listOfShapes[i].parentNode = NULL;		//Set new top O heirarchy.
 		
 		for (long j=0;j<numTG_Shapes;j++)
@@ -1780,7 +1785,7 @@ bool TG_MultiShape::isChildOf (char *nodeName, char* parentName)
 		zero.x = zero.y = zero.z = 0.0f;
 		for (long j=curChild;j>=0;j--)
 		{
-			if (stricmp(childChain[j]->node->getNodeName(),parentName) == 0)
+			if (_stricmp(childChain[j]->node->getNodeName(),parentName) == 0)
 			{
 				detachables[curShape] = childChain[0];
 				curShape++;
@@ -1794,7 +1799,7 @@ bool TG_MultiShape::isChildOf (char *nodeName, char* parentName)
 		
 	for (i=0;i<curShape;i++)
 	{
-		if (stricmp(detachables[i]->node->getNodeName(), nodeName) == 0)
+		if (_stricmp(detachables[i]->node->getNodeName(), nodeName) == 0)
 			return true;
 	}
 	
@@ -1818,7 +1823,7 @@ void *TG_AnimateShape::operator new (size_t mySize)
 //-------------------------------------------------------------------------------
 void _TG_Animation::SaveBinaryCopy (File *binFile)
 {
-	if (stricmp(nodeId,"NONE") != 0)
+	if (_stricmp(nodeId,"NONE") != 0)
 	{
 		binFile->write((MemoryPtr)nodeId,TG_NODE_ID);	
 		binFile->writeLong(-1);			//ShapeIds ALWAYS start with -1.  We will scan on frame 1 please!
@@ -1919,7 +1924,7 @@ void TG_AnimateShape::SaveBinaryCopy (char *fileName)
 	{
  		for (long i=0;i<count;i++)
 		{
-			if (stricmp(listOfAnimation[i].nodeId,"NONE") != 0)
+			if (_stricmp(listOfAnimation[i].nodeId,"NONE") != 0)
 				actualCount++;
 		}
 	}
@@ -2370,7 +2375,7 @@ void TG_AnimateShape::SetAnimationState (TG_MultiShapePtr shape)
 			bool foundNode = false;
 			for (i=0;i<shape->GetNumShapes();i++)
 			{
-				if (stricmp(listOfAnimation[j].nodeId,shape->GetNodeId(i)) == 0)
+				if (_stricmp(listOfAnimation[j].nodeId,shape->GetNodeId(i)) == 0)
 				{
 					shape->SetCurrentAnimation(i,&listOfAnimation[j]);
 					listOfAnimation[j].shapeId = i;


  ================================================
diff --git a/source/mclib/msl.h b/source/mclib/msl.h
index 3010fa1..b80756e 100755
--- a/source/mclib/msl.h
+++ b/source/mclib/msl.h
@@ -13,6 +13,8 @@
 //
 //-------------------------------------------------------------------------------
 
+#pragma once
+
 #ifndef MSL_H
 #define MSL_H
 //-------------------------------------------------------------------------------
@@ -66,8 +68,8 @@ class TG_TypeMultiShape
 	//-------------
 	//Data Members
 	protected:
-		long				numTG_TypeShapes;		//Number of TG_Shapes
-		long				numTextures;			//Total Textures for all shapes.
+		ULONG				numTG_TypeShapes;		//Number of TG_Shapes
+		ULONG				numTextures;			//Total Textures for all shapes.
 		TG_TypeNodePtr		*listOfTypeShapes;		//Memory holding all TG_TypeNodes and TypeShapes
 		TG_TexturePtr		listOfTextures;			//List of texture Structures for all shapes.
 		
@@ -126,24 +128,24 @@ class TG_TypeMultiShape
 		//Function runs through each piece of ASE file and creates a separate
 		//TG_Shape for each one.  First pass is count number of GEOMOBJECTS.
 		//Second pass is load each one.
-		long LoadTGMultiShapeFromASE (char *fileName, bool forceMakeBinary = false, Microsoft::Xna::Arm::IProviderEngine * armProvider = NULL);
+		long LoadTGMultiShapeFromASE (PSTR fileName, bool forceMakeBinary = false, Microsoft::Xna::Arm::IProviderEngine * armProvider = NULL);
 
 		//Function returns 0 if OK.  -1 if textureName is longer then nameLength-1.
 		//This function digs the texture name(s) out of the ASE file so that the
 		//User can load and manage them anyway they want to.
-		long GetTextureName (DWORD textureNum, char *textureName, long nameLength);
+		long GetTextureName (ULONG textureNum, PSTR textureName, long nameLength);
 
 		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
 		//This function takes the gosTextureHandle passed in and assigns it to the
 		//textureNum entry of the listOfTextures;
-		long SetTextureHandle (DWORD textureNum, DWORD gosTextureHandle);
+		long SetTextureHandle (ULONG textureNum, ULONG gosTextureHandle);
 
 		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
 		//This function takes the gosTextureHandle passed in and assigns it to the
 		//textureNum entry of the listOfTextures;
-		long SetTextureAlpha (DWORD textureNum, bool alphaFlag);
+		long SetTextureAlpha (ULONG textureNum, bool alphaFlag);
 
-		DWORD GetTextureHandle (DWORD textureNum)
+		ULONG GetTextureHandle (ULONG textureNum)
 		{
 			if (textureNum < numTextures)
 				return listOfTextures[textureNum].mcTextureNodeIndex;
@@ -151,17 +153,17 @@ class TG_TypeMultiShape
 			return 0xffffffff;
 		}
 
-		long GetNumShapes (void)
+		ULONG GetNumShapes (void)
 		{
 			return numTG_TypeShapes;
 		}
 
-		long GetNumTextures (void)
+		ULONG GetNumTextures (void)
 		{
 			return numTextures;
 		}
 
-		char *GetNodeId (long shapeNum)
+		PSTR GetNodeId (ULONG shapeNum)
 		{
 			if ((shapeNum >= 0) && (shapeNum < numTG_TypeShapes))
 				return (listOfTypeShapes[shapeNum]->getNodeId());
@@ -169,7 +171,7 @@ class TG_TypeMultiShape
 			return NULL;
 		}
 
-		Stuff::Point3D GetNodeCenter (long shapeNum)
+		Stuff::Point3D GetNodeCenter (ULONG shapeNum)
 		{
 			Stuff::Point3D result;
 			result.x = result.y = result.z = 0.0f;
@@ -180,14 +182,14 @@ class TG_TypeMultiShape
 			return result;
 		}
 
-		Stuff::Point3D GetNodeCenter (char * nodeId)
+		Stuff::Point3D GetNodeCenter (PSTR  nodeId)
 		{
 			Stuff::Point3D result;
 			result.x = result.y = result.z = 0.0f;
 
-			for (long i=0;i<numTG_TypeShapes;i++)
+			for (ULONG i=0;i<numTG_TypeShapes;i++)
 			{
-				if (stricmp(listOfTypeShapes[i]->getNodeId(),nodeId) == 0)
+				if (_stricmp(listOfTypeShapes[i]->getNodeId(),nodeId) == 0)
 					result = listOfTypeShapes[i]->GetNodeCenter();
 			}
 			
@@ -199,24 +201,24 @@ class TG_TypeMultiShape
 
 		void SetAlphaTest (bool flag)
 		{
-			for (long i=0;i<numTG_TypeShapes;i++)
+			for (ULONG i=0;i<numTG_TypeShapes;i++)
 				listOfTypeShapes[i]->SetAlphaTest(flag);
 		}
 
 		void SetFilter (bool flag)
 		{
-			for (long i=0;i<numTG_TypeShapes;i++)
+			for (ULONG i=0;i<numTG_TypeShapes;i++)
 				listOfTypeShapes[i]->SetFilter(flag);
 		}
 		
-		void SetLightRGBs (DWORD hPink, DWORD hGreen, DWORD hYellow)
+		void SetLightRGBs (ULONG hPink, ULONG hGreen, ULONG hYellow)
 		{
-			for (long i=0;i<numTG_TypeShapes;i++)
+			for (ULONG i=0;i<numTG_TypeShapes;i++)
 				listOfTypeShapes[i]->SetLightRGBs(hPink,hGreen,hYellow);
 		}
 
-		long LoadBinaryCopy (char *fileName);
-		void SaveBinaryCopy (char *fileName);
+		long LoadBinaryCopy (PSTR fileName);
+		void SaveBinaryCopy (PSTR fileName);
 };
 
 typedef TG_TypeMultiShape* TG_TypeMultiShapePtr;
@@ -291,10 +293,10 @@ class TG_MultiShape
 		//to light the shape.
 		//Function returns 0 if lightList entries are all OK.  -1 otherwise.
 		//
-		long SetLightList (TG_LightPtr *lightList, DWORD nLights);
+		long SetLightList (TG_LightPtr *lightList, ULONG nLights);
 
 		//This function sets the fog values for the shape.  Straight fog right now.
-		void SetFogRGB (DWORD fRGB);
+		void SetFogRGB (ULONG fRGB);
 		
 		//This function does the actual transform math, clip checks and lighting math.
 		//The matrices passed in are the translation/rotation matrix for the shape and
@@ -308,7 +310,7 @@ class TG_MultiShape
 		//This function rotates the heirarchy from this node down.  Used for torso twists, arms, etc.
 		// SHould only be called once this way.  This way is DAMNED SLOW!!!  STRICMP!  IT returns the node num
 		// Call that from then on!
-		long SetNodeRotation (char *nodeName, Stuff::UnitQuaternion *rot);
+		long SetNodeRotation (PSTR nodeName, Stuff::UnitQuaternion *rot);
 
 		void SetNodeRotation (long nodeNum, Stuff::UnitQuaternion *rot)
 		{
@@ -369,7 +371,7 @@ class TG_MultiShape
 		//Function returns 0 if OK.  -1 if textureName is longer then nameLength-1.
 		//This function digs the texture name(s) out of the ASE file so that the
 		//User can load and manage them anyway they want to.
-		long GetTextureName (DWORD textureNum, char *textureName, long nameLength)
+		long GetTextureName (ULONG textureNum, PSTR textureName, long nameLength)
 		{
 			return myMultiType->GetTextureName(textureNum,textureName,nameLength);
 		}
@@ -382,12 +384,12 @@ class TG_MultiShape
 		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
 		//This function takes the gosTextureHandle passed in and assigns it to the
 		//textureNum entry of the listOfTextures;
-		long SetTextureHandle (DWORD textureNum, DWORD gosTextureHandle)
+		long SetTextureHandle (ULONG textureNum, ULONG gosTextureHandle)
 		{
 			return myMultiType->SetTextureHandle(textureNum,gosTextureHandle);
 		}
 
-		DWORD GetTextureHandle (DWORD textureNum)
+		ULONG GetTextureHandle (ULONG textureNum)
 		{
 			return myMultiType->GetTextureHandle(textureNum);
 		}
@@ -410,7 +412,7 @@ class TG_MultiShape
 		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
 		//This function takes the gosTextureHandle passed in and assigns it to the
 		//textureNum entry of the listOfTextures;
-		long SetTextureAlpha (DWORD textureNum, bool alphaFlag)
+		long SetTextureAlpha (ULONG textureNum, bool alphaFlag)
 		{
 			return myMultiType->SetTextureAlpha(textureNum,alphaFlag);
 		}
@@ -459,7 +461,7 @@ class TG_MultiShape
 				listOfShapes[i].currentAnimation = NULL;
 		}
 
-		void SetARGBHighLight (DWORD argb)
+		void SetARGBHighLight (ULONG argb)
 		{
 			for (long i=0;i<numTG_Shapes;i++)
 				listOfShapes[i].node->SetARGBHighLight(argb);
@@ -471,7 +473,7 @@ class TG_MultiShape
 				listOfShapes[i].node->SetLightsOut(lightFlag);
 		}
 		
- 		Stuff::Vector3D GetTransformedNodePosition (Stuff::Point3D *pos, Stuff::UnitQuaternion *rot, char *nodeId);
+ 		Stuff::Vector3D GetTransformedNodePosition (Stuff::Point3D *pos, Stuff::UnitQuaternion *rot, PSTR nodeId);
  		Stuff::Vector3D GetTransformedNodePosition (Stuff::Point3D *pos, Stuff::UnitQuaternion *rot, long nodeId);
 
 		TG_TypeMultiShapePtr GetMultiType (void)
@@ -482,16 +484,16 @@ class TG_MultiShape
 		// This function takes the shape named nodeName and all of its children, detaches them
 		// from the current heirarchy and stuffs them into a new MultiShape which it passes back
 		// Uses are endless but for now limited to blowing the arms off of the mechs!
-		TG_MultiShape* Detach (char *nodeName);
+		TG_MultiShape* Detach (PSTR nodeName);
 		
 		// This function takes the shape named nodeName and all of its children and stops processing
 		// them forever.  Since we can never re-attach a mech arm in the field, this is OK!
-		void StopUsing (char *nodeName);
+		void StopUsing (PSTR nodeName);
 		
  		// Tells me if the passed in nodeName is a child of the parentName.
-		bool isChildOf (char *nodeName, char* parentName);
+		bool isChildOf (PSTR nodeName, char* parentName);
 		
-		char *GetNodeId (long shapeNum)
+		PSTR GetNodeId (long shapeNum)
 		{
 			if ((shapeNum >= 0) && (shapeNum < numTG_Shapes))
 				return (listOfShapes[shapeNum].node->getNodeName());
@@ -499,7 +501,7 @@ class TG_MultiShape
 			return NULL;
 		}
 		
-		long GetNodeNameId (char * nodeId)
+		long GetNodeNameId (PSTR  nodeId)
 		{
 			for (long i=0;i<numTG_Shapes;i++)
 			{
@@ -507,7 +509,7 @@ class TG_MultiShape
 				// Scan through the list of shapes and dig out the number needed.
 				// DO NOT UPDATE THE HEIRARCHY!!!!
 				// This thing may not have updated itself this turn yet!!!
-				if (stricmp(listOfShapes[i].node->myType->getNodeId(),nodeId) == 0)
+				if (_stricmp(listOfShapes[i].node->myType->getNodeId(),nodeId) == 0)
 					return i;
 			}
 
@@ -599,8 +601,8 @@ class TG_AnimateShape
 			destroy();
 		}
 
-		long LoadBinaryCopy (char *fileName);
-		void SaveBinaryCopy (char *fileName);
+		long LoadBinaryCopy (PSTR fileName);
+		void SaveBinaryCopy (PSTR fileName);
 
 		//This function frees all of the RAM allocated by this class and resets vars to initial state.
 		void destroy (void);
@@ -609,7 +611,7 @@ class TG_AnimateShape
 		//It sets up a pointer to the multi-shape so that animation data for each
 		//Node in the Multi-Shape can be loaded.
 		//It mallocs memory.
-		long LoadTGMultiShapeAnimationFromASE (char *filename, TG_TypeMultiShapePtr shape, bool skipIfBinary = false, bool forceMakeBinary = false);
+		long LoadTGMultiShapeAnimationFromASE (PSTR filename, TG_TypeMultiShapePtr shape, bool skipIfBinary = false, bool forceMakeBinary = false);
 
 		//This function copies the pointers to the animation data in this class to the
 		//TG_MultiShape being drawn.  Nothing else happens.


  ================================================
diff --git a/source/mclib/paths.cpp b/source/mclib/paths.cpp
index 6c1eca5..05b4d5e 100755
--- a/source/mclib/paths.cpp
+++ b/source/mclib/paths.cpp
@@ -6,6 +6,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+
 //---------------------------------------------------------------------------
 // Include Files
 #ifndef PATHS_H


  ================================================
diff --git a/source/mclib/pqueue.cpp b/source/mclib/pqueue.cpp
index c9c00eb..21d89af 100755
--- a/source/mclib/pqueue.cpp
+++ b/source/mclib/pqueue.cpp
@@ -12,6 +12,8 @@
 
 //***************************************************************************
 
+#include "stdafx.h"
+
 //--------------
 // Include Files
 


  ================================================
diff --git a/source/mclib/routines.cpp b/source/mclib/routines.cpp
index b8d1cbd..b92381c 100755
--- a/source/mclib/routines.cpp
+++ b/source/mclib/routines.cpp
@@ -7,8 +7,10 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+// #include <stdlib.h>
+
 #include <gameos.hpp>
-#include <stdlib.h>
 
 void memclear(void *Dest,int Length);
 void memfill(void *Dest,int Length);


  ================================================
diff --git a/source/mclib/scale.cpp b/source/mclib/scale.cpp
index 2b2bb1c..e7eedc0 100755
--- a/source/mclib/scale.cpp
+++ b/source/mclib/scale.cpp
@@ -4,6 +4,8 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
+// #include <math.h>
 
 //---------------------------------------------------------------------------
 // Include files
@@ -27,7 +29,6 @@
 #include "camera.h"
 #endif
 
-#include <math.h>
 #include <gameos.hpp>
 
 extern void AG_shape_translate_transform(PANE *globalPane, void *shapeTable,LONG frameNum, LONG hotX, LONG hotY,void *tempBuffer,LONG reverse, LONG scaleUp);


  ================================================
diff --git a/source/mclib/sortlist.cpp b/source/mclib/sortlist.cpp
index f3350cf..1bf889b 100755
--- a/source/mclib/sortlist.cpp
+++ b/source/mclib/sortlist.cpp
@@ -7,6 +7,8 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
+//#include <stdlib.h>
 
 //--------------
 // Include Files
@@ -23,7 +25,6 @@
 #include "heap.h"
 #endif
 
-#include <stdlib.h>
 
 #include <gameos.hpp>
 //***************************************************************************
@@ -45,7 +46,8 @@ long SortList::init (long _numItems) {
 
 void SortList::clear (bool setToMin) {
 
-	for (long i = 0; i < numItems; i++)
+	long i;
+	for (i = 0; i < numItems; i++)
 		list[i].id = i;
 	if (setToMin)
 		for (i = 0; i < numItems; i++)


  ================================================
diff --git a/source/mclib/soundsys.cpp b/source/mclib/soundsys.cpp
index fbd21e7..770907b 100755
--- a/source/mclib/soundsys.cpp
+++ b/source/mclib/soundsys.cpp
@@ -131,8 +131,8 @@ long SoundSystem::init (char *soundFileName)
 		sounds = (SoundBite *)soundHeap->Malloc(sizeof(SoundBite) * numSoundBites);
 		gosASSERT(sounds != NULL);
 		memset(sounds,0,sizeof(SoundBite) * numSoundBites);
-		
-		for (long i=0;i<(long)numSoundBites;i++)
+		long i;
+		for (i=0;i<(long)numSoundBites;i++)
 		{
 			char biteBlock[20];
 			sprintf(biteBlock,"SoundBite%d",i);


  ================================================
diff --git a/source/mclib/stuff/affinematrix.hpp b/source/mclib/stuff/affinematrix.hpp
index 4a348a2..9cbb1dc 100755
--- a/source/mclib/stuff/affinematrix.hpp
+++ b/source/mclib/stuff/affinematrix.hpp
@@ -145,103 +145,127 @@ namespace Stuff {
 			GetLocalForwardInWorld(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_FORWARD_SIGN((*this)(FORWARD_AXIS, X_Axis));
 			v->y = APPLY_FORWARD_SIGN((*this)(FORWARD_AXIS, Y_Axis));
 			v->z = APPLY_FORWARD_SIGN((*this)(FORWARD_AXIS, Z_Axis));
 		}
+		}
 		void
 			GetWorldForwardInLocal(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_FORWARD_SIGN((*this)(X_Axis, FORWARD_AXIS));
 			v->y = APPLY_FORWARD_SIGN((*this)(Y_Axis, FORWARD_AXIS));
 			v->z = APPLY_FORWARD_SIGN((*this)(Z_Axis, FORWARD_AXIS));
 		}
+		}
 
 		void
 			GetLocalBackwardInWorld(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_BACKWARD_SIGN((*this)(BACKWARD_AXIS, X_Axis));
 			v->y = APPLY_BACKWARD_SIGN((*this)(BACKWARD_AXIS, Y_Axis));
 			v->z = APPLY_BACKWARD_SIGN((*this)(BACKWARD_AXIS, Z_Axis));
 		}
+		}
 		void
 			GetWorldBackwardInLocal(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_BACKWARD_SIGN((*this)(X_Axis, BACKWARD_AXIS));
 			v->y = APPLY_BACKWARD_SIGN((*this)(Y_Axis, BACKWARD_AXIS));
 			v->z = APPLY_BACKWARD_SIGN((*this)(Z_Axis, BACKWARD_AXIS));
 		}
+		}
 
 		void
 			GetLocalRightInWorld(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_RIGHT_SIGN((*this)(RIGHT_AXIS, X_Axis));
 			v->y = APPLY_RIGHT_SIGN((*this)(RIGHT_AXIS, Y_Axis));
 			v->z = APPLY_RIGHT_SIGN((*this)(RIGHT_AXIS, Z_Axis));
 		}
+		}
 		void
 			GetWorldRightInLocal(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_RIGHT_SIGN((*this)(X_Axis, RIGHT_AXIS));
 			v->y = APPLY_RIGHT_SIGN((*this)(Y_Axis, RIGHT_AXIS));
 			v->z = APPLY_RIGHT_SIGN((*this)(Z_Axis, RIGHT_AXIS));
 		}
+		}
 
 		void
 			GetLocalLeftInWorld(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_LEFT_SIGN((*this)(LEFT_AXIS, X_Axis));
 			v->y = APPLY_LEFT_SIGN((*this)(LEFT_AXIS, Y_Axis));
 			v->z = APPLY_LEFT_SIGN((*this)(LEFT_AXIS, Z_Axis));
 		}
+		}
 		void
 			GetWorldLeftInLocal(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_LEFT_SIGN((*this)(X_Axis, LEFT_AXIS));
 			v->y = APPLY_LEFT_SIGN((*this)(Y_Axis, LEFT_AXIS));
 			v->z = APPLY_LEFT_SIGN((*this)(Z_Axis, LEFT_AXIS));
 		}
+		}
 
 		void
 			GetLocalUpInWorld(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_UP_SIGN((*this)(UP_AXIS, X_Axis));
 			v->y = APPLY_UP_SIGN((*this)(UP_AXIS, Y_Axis));
 			v->z = APPLY_UP_SIGN((*this)(UP_AXIS, Z_Axis));
 		}
+		}
 		void
 			GetWorldUpInLocal(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_UP_SIGN((*this)(X_Axis, UP_AXIS));
 			v->y = APPLY_UP_SIGN((*this)(Y_Axis, UP_AXIS));
 			v->z = APPLY_UP_SIGN((*this)(Z_Axis, UP_AXIS));
 		}
+		}
 
 		void
 			GetLocalDownInWorld(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_DOWN_SIGN((*this)(DOWN_AXIS, X_Axis));
 			v->y = APPLY_DOWN_SIGN((*this)(DOWN_AXIS, Y_Axis));
 			v->z = APPLY_DOWN_SIGN((*this)(DOWN_AXIS, Z_Axis));
 		}
+		}
 		void
 			GetWorldDownInLocal(Vector3D *v) const
 		{
 			Check_Object(this); Check_Pointer(v);
+			if(v) {
 			v->x = APPLY_DOWN_SIGN((*this)(X_Axis, DOWN_AXIS));
 			v->y = APPLY_DOWN_SIGN((*this)(Y_Axis, DOWN_AXIS));
 			v->z = APPLY_DOWN_SIGN((*this)(Z_Axis, DOWN_AXIS));
 		}
+		}
 
 		//
 		// Matrix Multiplication
@@ -257,13 +281,15 @@ namespace Stuff {
 			Check_Object(&Source2);
 			Verify(this != &Source1);
 			Verify(this != &Source2);
+			(void)Source1;	// 4100
+			(void)Source2;	// 4100
 
 #if USE_ASSEMBLER_CODE
 				Scalar *f = entries;
 				_asm {
-					mov         edx, Source1.entries
+					mov         edx, [edx]Source1.entries
 					push        esi
-					mov         esi, Source2.entries
+					mov         esi, [esi]Source2.entries
 					
 					mov         eax, f
 


  ================================================
diff --git a/source/mclib/stuff/angle.hpp b/source/mclib/stuff/angle.hpp
index 2cbacd2..c2396a4 100755
--- a/source/mclib/stuff/angle.hpp
+++ b/source/mclib/stuff/angle.hpp
@@ -278,6 +278,7 @@ namespace Stuff {
 				{
 					Check_Pointer(this);
 					Check_Object(&radian);
+					(void)radian;	// 4100
 
 				#if USE_ASSEMBLER_CODE
 					Scalar *f = &sine;
@@ -286,7 +287,7 @@ namespace Stuff {
 						push	edx
 
 						mov		ebx, f
-						mov		edx, radian.angle
+						mov		edx, [edx]radian.angle
 
 						fld		dword ptr [edx]
 						fsincos


  ================================================
diff --git a/source/mclib/stuff/armoron.hpp b/source/mclib/stuff/armoron.hpp
index 31408b1..c52147f 100755
--- a/source/mclib/stuff/armoron.hpp
+++ b/source/mclib/stuff/armoron.hpp
@@ -53,10 +53,10 @@ template <class T> T
 		Check_Pointer(source);\
 		Verify((length) <= (available));\
 		Verify(\
-			abs(\
+			(size_t)(abs(\
 				reinterpret_cast<char*>(destination)\
 				 - reinterpret_cast<const char*>(source)\
-			) >= length\
+			)) >= length\
 		);\
 		memcpy(destination, source, length);\
 	} while (0)


  ================================================
diff --git a/source/mclib/stuff/auto_container.hpp b/source/mclib/stuff/auto_container.hpp
index 8e3246e..5a980ed 100755
--- a/source/mclib/stuff/auto_container.hpp
+++ b/source/mclib/stuff/auto_container.hpp
@@ -6,7 +6,7 @@
 #ifndef AUTO_CONTAINER_HPP
 #define AUTO_CONTAINER_HPP
 
-#pragma warning (disable:4786)							// this is necessary to avoid "truncated to 255 characters in debug info" message
+//#pragma warning (disable:4786)							// this is necessary to avoid "truncated to 255 characters in debug info" message
 #include "Auto_Ptr.hpp"
 #include "Noncopyable.hpp"
 


  ================================================
diff --git a/source/mclib/stuff/database.cpp b/source/mclib/stuff/database.cpp
index 3184e77..121aa25 100755
--- a/source/mclib/stuff/database.cpp
+++ b/source/mclib/stuff/database.cpp
@@ -1,7 +1,3 @@
-#include "StuffHeaders.hpp"
-#include "Database.hpp"
-#include <ToolOS.hpp>
-
 //===========================================================================//
 // File:	Database.cpp                                                     //
 // Contents: Database functionality											 //												 
@@ -9,7 +5,10 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-
+#include "stdafx.h"
+#include "stuffheaders.hpp"
+#include "database.hpp"
+#include <toolos.hpp>
 
 //
 // A pointer to this structure is the handle to the database
@@ -768,7 +767,8 @@ void
 	//
 	DWORD offset = sizeof(output_db);
 	OutputRecord* new_record = new_records;
-	for (DWORD i=0; i<Database::e_DataBlockSize; ++i)
+	DWORD i;
+	for (i=0; i<Database::e_DataBlockSize; ++i)
 	{
 		Record* old_record = reinterpret_cast<Record*>(m_dataBase->m_idOffsets[i]);
 		if (old_record)


  ================================================
diff --git a/source/mclib/stuff/hash.hpp b/source/mclib/stuff/hash.hpp
index cf1d691..7e01574 100755
--- a/source/mclib/stuff/hash.hpp
+++ b/source/mclib/stuff/hash.hpp
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include "Stuff.hpp"
-#include "SortedSocket.hpp"
-#include "SortedChain.hpp"
+#include "stuff.hpp"
+#include "sortedsocket.hpp"
+#include "sortedchain.hpp"
 
 namespace GetHashFunctions {
 	inline Stuff::IteratorPosition
@@ -124,7 +124,7 @@ namespace Stuff {
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Hash inlines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	inline void
-		Hash::RemovePlug(Plug *plug)
+		Hash::RemovePlug(Plug* /*plug*/)
 	{
 		STOP((
 			"Hash::RemovePlug - no efficient implementation, use iterator find & remove"
@@ -132,7 +132,7 @@ namespace Stuff {
 	}
 
 	inline bool
-		Hash::IsPlugMember(Plug *plug)
+		Hash::IsPlugMember(Plug* /*plug*/)
 	{
 		STOP((
 			"Hash::IsPlugMember - no efficient implementation, use find"


  ================================================
diff --git a/source/mclib/stuff/matrix.hpp b/source/mclib/stuff/matrix.hpp
index 8f06cbc..7bc4fba 100755
--- a/source/mclib/stuff/matrix.hpp
+++ b/source/mclib/stuff/matrix.hpp
@@ -34,8 +34,7 @@ namespace Stuff {
 	class Matrix4D
 	{
 	public:
-		static const Matrix4D
-			Identity;
+		static const Matrix4D Identity;	// ???
 
 		Scalar
 			entries[16];
@@ -163,13 +162,15 @@ namespace Stuff {
 				Check_Pointer(this);
 				Check_Object(&Source1);
 				Check_Object(&Source2);
+				(void)Source1;
+				(void)Source2;
 
 #if USE_ASSEMBLER_CODE
 				Scalar *f = entries;
 				_asm {
-                    mov         edx, Source1.entries
+                    mov         edx, [edx]Source1.entries
 					push        esi
-					mov         esi, Source2.entries
+					mov         esi, [esi]Source2.entries
 					
 					mov         eax, f
 


  ================================================
diff --git a/source/mclib/stuff/memorystream.hpp b/source/mclib/stuff/memorystream.hpp
index 618bdc0..62593fd 100755
--- a/source/mclib/stuff/memorystream.hpp
+++ b/source/mclib/stuff/memorystream.hpp
@@ -7,7 +7,7 @@
 
 #pragma once
 
-#include "Stuff.hpp"
+#include "stuff.hpp"
 
 namespace Stuff {class MemoryStream;}
 
@@ -45,9 +45,9 @@ namespace Stuff {
 
 	public:
 		static void
-			InitializeClass();
+			InitializeClass(void);
 		static void
-			TerminateClass();
+			TerminateClass(void);
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Construction and testing
@@ -55,23 +55,23 @@ namespace Stuff {
 	public:
 		MemoryStream(
 			void *stream_start,
-			DWORD stream_size,
-			DWORD initial_offset=0
+			size_t stream_size,
+			size_t initial_offset=0
 		);
-		virtual ~MemoryStream();
+		virtual ~MemoryStream(void);
 
 		void
-			TestInstance() const;
+			TestInstance(void) const;
 
 		static bool
-			TestClass();
+			TestClass(void);
 
 	protected:
 		MemoryStream(
 			ClassData *data,
 			void *stream_start,
-			DWORD stream_size,
-			DWORD initial_offset=0
+			size_t stream_size,
+			size_t initial_offset=0
 		);
 
 
@@ -87,21 +87,34 @@ namespace Stuff {
 	//
 	public:
 		virtual void*
-			GetPointer() const
-				{Check_Object(this); return currentPosition;}
-		DWORD
-			GetIndex() const
-				{Check_Object(this); return currentPosition - streamStart;}
-		DWORD
-			GetSize() const
-				{Check_Object(this); return streamSize;}
-
-		DWORD
-			GetBytesUsed() const
-				{Check_Object(this); return currentPosition - streamStart;}
-		virtual DWORD
-			GetBytesRemaining() const
-				{Check_Object(this); return streamSize - GetBytesUsed();}
+			GetPointer(void) const
+		{
+			Check_Object(this); return currentPosition;
+		}
+
+		size_t
+			GetIndex(void) const
+		{
+			Check_Object(this); return currentPosition - streamStart;
+		}
+
+		size_t
+			GetSize(void) const
+		{
+			Check_Object(this); return streamSize;
+		}
+		
+		size_t
+			GetBytesUsed(void) const
+		{
+			Check_Object(this); return currentPosition - streamStart;
+		}
+		
+		virtual size_t
+			GetBytesRemaining(void) const
+		{
+			Check_Object(this); return streamSize - GetBytesUsed();
+		}
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Assignment methods
@@ -111,37 +124,46 @@ namespace Stuff {
 			SetPointer(void *new_pointer)
 				{
 					Check_Pointer(this);
-					currentPosition = Cast_Pointer(BYTE*, new_pointer);
+			currentPosition = Cast_Pointer(PUCHAR, new_pointer);
 					Check_Object(this);
 				}
 		void
 			operator=(void *new_pointer)
-				{SetPointer(new_pointer);}
+		{
+			SetPointer(new_pointer);
+		}
 
 		virtual void
-			SetPointer(DWORD index)
+			SetPointer(size_t index)
 				{
 					Check_Pointer(this);
 					currentPosition = streamStart + index;
 					Check_Object(this);
 				}
 		void
-			operator=(DWORD index)
-				{SetPointer(index);}
+			operator=(size_t index)
+		{
+			SetPointer(index);
+		}
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Stream methods
 	//
 	public:
 		void
-			Rewind()
-				{SetPointer((DWORD) 0U);currentBit = Empty_Bit_Buffer;}
+			Rewind(void)
+		{
+			SetPointer((size_t) 0U);currentBit = Empty_Bit_Buffer;
+		}
 
 		virtual bool
-			AllocateBytes(DWORD count)
-				{return GetBytesRemaining() <= count;}
+			AllocateBytes(size_t count)
+		{
+			return GetBytesRemaining() <= count;
+		}
+		
 		virtual MemoryStream&
-			AdvancePointer(DWORD count)
+			AdvancePointer(size_t count)
 				{
 					Check_Object(this);
 					currentPosition += count;
@@ -152,12 +174,15 @@ namespace Stuff {
 					Check_Object(this);
 					return *this;
 				}
+		
 		MemoryStream&
-			operator+=(DWORD count)
-				{return AdvancePointer(count);}
+			operator+=(size_t count)
+		{
+			return AdvancePointer(count);
+		}
 
 		virtual MemoryStream&
-			RewindPointer(DWORD count)
+			RewindPointer(size_t count)
 				{
 					Check_Object(this);
 					currentPosition -= count;
@@ -169,33 +194,33 @@ namespace Stuff {
 					return *this;
 				}
 		MemoryStream&
-			operator-=(DWORD count)
+			operator-=(size_t count)
 				{return RewindPointer(count);}
 
 		virtual MemoryStream&
 			ReadBytes(
 				void *ptr,
-				DWORD number_of_bytes
+			size_t number_of_bytes
 			);
 		virtual MemoryStream&
 			WriteBytes(
 				const void *ptr,
-				DWORD number_of_bytes
+			size_t number_of_bytes
 			);
 
 		MemoryStream&
 			ReadSwappedBytes(
 				void *ptr,
-				DWORD number_of_bytes
+			size_t number_of_bytes
 			);
 		MemoryStream&
 			WriteSwappedBytes(
 				const void *ptr,
-				DWORD number_of_bytes
+			size_t number_of_bytes
 			);
 
 		virtual int
-			ReadChar();
+			ReadChar(void);
 
 		virtual bool
 			ReadLine(
@@ -206,7 +231,7 @@ namespace Stuff {
 
 		MString
 			ReadString(
-				DWORD size_of_buffer = 512,
+			size_t size_of_buffer = 512,
 				char continuator = '\0'
 			);
 
@@ -224,11 +249,11 @@ namespace Stuff {
 		int
 			currentBit;
 
-		BYTE
+		UCHAR
 			workingBitBuffer;
 
 		MemoryStream&
-			ReadUnsafeBits(void *ptr, DWORD number_of_bits);
+			ReadUnsafeBits(void *ptr, size_t number_of_bits);
 
 	public:
 		MemoryStream&
@@ -238,33 +263,50 @@ namespace Stuff {
 			WriteBit(const bool &bit_value);
 
 		
+		template <typename T>
+		MemoryStream& ReadBits(T *ptr, size_t number_of_bits)
+		{
+			Verify(number_of_bits <= 32);
+			Check_Object(this); Check_Pointer(ptr);
+			if(ptr)*ptr = 0; return ReadUnsafeBits(ptr, number_of_bits);
+		}
+
+#if 0
 		MemoryStream&
-			ReadBits(int *ptr, DWORD number_of_bits)
+			ReadBits(int *ptr, size_t number_of_bits)
 				{
 					Verify(number_of_bits <= 32);
 					Check_Object(this); Check_Pointer(ptr);
-					*ptr = 0; return ReadUnsafeBits(ptr, number_of_bits);
+			if(ptr)*ptr = 0; return ReadUnsafeBits(ptr, number_of_bits);
 				}
 
 		MemoryStream&
-			ReadBits(BYTE *ptr, DWORD number_of_bits)
+			ReadBits(UCHAR *ptr, size_t number_of_bits)
 				{
 					Verify(number_of_bits <= 8);
 					Check_Object(this); Check_Pointer(ptr);
-					*ptr = 0; return ReadUnsafeBits(ptr, number_of_bits);
+			if(ptr)*ptr = 0; return ReadUnsafeBits(ptr, number_of_bits);
 				}
 
 
 		MemoryStream&
-			ReadBits(WORD *ptr, DWORD number_of_bits)
+			ReadBits(USHORT *ptr, size_t number_of_bits)
 				{
 					Verify(number_of_bits <= 16);
 					Check_Object(this); Check_Pointer(ptr);
-					*ptr = 0; return ReadUnsafeBits(ptr, number_of_bits);
+			if(ptr)*ptr = 0; return ReadUnsafeBits(ptr, number_of_bits);
 				}
 
 		MemoryStream&
-			ReadBits(DWORD *ptr, DWORD number_of_bits)
+			ReadBits(ULONG *ptr, size_t number_of_bits)
+		{
+			Verify(number_of_bits <= 32);
+			Check_Object(this); Check_Pointer(ptr);
+			if(ptr)*ptr = 0; return ReadUnsafeBits(ptr, number_of_bits);
+		}
+
+		MemoryStream&
+			ReadBits(size_t *ptr, size_t number_of_bits)
 				{
 					Verify(number_of_bits <= 32);
 					Check_Object(this); Check_Pointer(ptr);
@@ -272,54 +314,49 @@ namespace Stuff {
 				}
 
 		MemoryStream&
-			ReadBits(float *ptr, DWORD number_of_bits)
+			ReadBits(float *ptr, size_t number_of_bits)
 				{
 					Verify(number_of_bits == 32);
 					Check_Object(this); Check_Pointer(ptr);
 					*ptr = 0.0; return ReadUnsafeBits(ptr, number_of_bits);
 				}
 
-
 		MemoryStream&
-			ReadBits(double *ptr, DWORD number_of_bits)
+			ReadBits(double *ptr, size_t number_of_bits)
 				{
 					Verify(number_of_bits == 64);
 					Check_Object(this); Check_Pointer(ptr);
 					*ptr = 0.0; return ReadUnsafeBits(ptr, number_of_bits);
 				}
 
+#endif
 
 		MemoryStream&
-			WriteBits(const void *ptr, DWORD number_of_bits);
-		
-		
-		
-	
+			WriteBits(const void *ptr, size_t number_of_bits);
 		
 		MemoryStream&
-			ReadBitsToScaledInt(int &number, int min, int max,  DWORD number_of_bits);
+			ReadBitsToScaledInt(int &number, int min, int max,  size_t number_of_bits);
 		
 		MemoryStream&
-			WriteScaledIntToBits(const int &number, int min, int max,  DWORD number_of_bits);
+			WriteScaledIntToBits(const int &number, int min, int max,  size_t number_of_bits);
 	
 		MemoryStream&
-			ReadBitsToScaledFloat(float &number, float min, float max,  DWORD number_of_bits);
+			ReadBitsToScaledFloat(float &number, float min, float max,  size_t number_of_bits);
 		
 		MemoryStream&
-			WriteScaledFloatToBits(const float &number, float min, float max,  DWORD number_of_bits);
-
+			WriteScaledFloatToBits(const float &number, float min, float max,  size_t number_of_bits);
 
 		void
-			ByteAlign();
+			ByteAlign(void);
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Protected data
 	//
 	protected:
-		BYTE
+		UCHAR
 			*streamStart,
 			*currentPosition;
-		DWORD
+		size_t
 			streamSize;
 	};
 
@@ -349,7 +386,9 @@ namespace Stuff {
 			MemoryStream &stream,
 			T &output
 		)
-			{return MemoryStreamIO::Read(&stream, &output);}
+	{
+		return MemoryStreamIO::Read(&stream, &output);
+	}
 
 	//--------------------------------------------------------------------------
 	// Insertion operators
@@ -359,12 +398,14 @@ namespace Stuff {
 			MemoryStream &stream,
 			const T &input
 		)
-			{return MemoryStreamIO::Write(&stream, &input);}
+	{
+		return MemoryStreamIO::Write(&stream, &input);
+	}
 
 	inline MemoryStream&
 		operator<<(
 			MemoryStream& stream,
-			const char* input
+		PCSTR  input
 		)
 			{
 				Check_Pointer(input);
@@ -382,19 +423,19 @@ namespace Stuff {
 	// Construction, destruction, and testing
 	//
 	public:
-		DynamicMemoryStream(DWORD stream_size=0);
+		DynamicMemoryStream(size_t stream_size=0);
 		DynamicMemoryStream(
 			void *stream_start,
-			DWORD stream_size,
-			DWORD initial_offset=0
+			size_t stream_size,
+			size_t initial_offset=0
 		);
 		DynamicMemoryStream(const DynamicMemoryStream& otherStream);
-		~DynamicMemoryStream();
+		~DynamicMemoryStream(void);
 
 		void
-			TestInstance() const
+			TestInstance(void) const
 				{
-					Verify((DWORD)(currentPosition - streamStart) <= streamSize);
+			Verify((size_t)(currentPosition - streamStart) <= streamSize);
 					Verify(streamSize <= bufferSize);
 				}
 
@@ -402,15 +443,15 @@ namespace Stuff {
 	// Accessors
 	//
 	public:
-		DWORD
-			GetBufferSize()
+		size_t
+			GetBufferSize(void)
 				{
 					Check_Object(this);
 					return bufferSize;
 				}
 
 		void
-			SetSize(DWORD stream_length)
+			SetSize(size_t stream_length)
 				{
 					Check_Object(this);
 					Verify(stream_length <= bufferSize);
@@ -424,17 +465,17 @@ namespace Stuff {
 		MemoryStream&
 			WriteBytes(
 				const void *ptr,
-				DWORD number_of_bytes
+			size_t number_of_bytes
 			);
 		
 		bool
-			AllocateBytes(DWORD count);
+			AllocateBytes(size_t count);
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Private data
 	//
 	private:
-		DWORD
+		size_t
 			bufferSize;
 		bool
 			ownsStream;
@@ -444,126 +485,196 @@ namespace Stuff {
 
 namespace MemoryStreamIO {
 
+	template<typename T> 
+	inline Stuff::MemoryStream&
+		Read(
+		Stuff::MemoryStream* stream,
+		T *output
+		)
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
+
+	template<typename T> 
+	inline Stuff::MemoryStream&
+		Write(
+		Stuff::MemoryStream* stream,
+		const T *input
+		)
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
+
+#if 0
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
-			char *output
+		bool *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
+
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
-			BYTE *output
+		CHAR *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
 
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
-			short *output
+		UCHAR *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
+
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
-			WORD *output
+		SHORT *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
 
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
-			int *output
+		USHORT *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
+
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
-			bool *output
+		int *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
+
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
 			unsigned *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
 
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
-			long *output
+		LONG *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
+
 	inline Stuff::MemoryStream&
 		Read(
 			Stuff::MemoryStream* stream,
-			DWORD *output
+		size_t *output
 		)
-			{return stream->ReadBytes(output, sizeof(*output));}
+	{
+		return stream->ReadBytes(output, sizeof(*output));
+	}
 
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const char *input
+		const bool *input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
+
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const BYTE *input
+		PCSTR input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
 
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const short *input
+		const PUCHAR input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
+
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const WORD *input
+		const SHORT *input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
 
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const int *input
+		const USHORT *input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
+
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const bool *input
+		const int *input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
+
+	
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
 			const unsigned *input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
 
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const long *input
+		const LONG *input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
+
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const DWORD *input
+		const size_t *input
 		)
-			{return stream->WriteBytes(input, sizeof(*input));}
+	{
+		return stream->WriteBytes(input, sizeof(*input));
+	}
+
+#endif
 
 	inline Stuff::MemoryStream&
 		Write(
 			Stuff::MemoryStream* stream,
-			const char* const* input
+		PCSTR  const *input
 		)
 			{
 				Check_Pointer(*input);


  ================================================
diff --git a/source/mclib/stuff/memorystream_test.cpp b/source/mclib/stuff/memorystream_test.cpp
index 76a4dce..3a24dc8 100755
--- a/source/mclib/stuff/memorystream_test.cpp
+++ b/source/mclib/stuff/memorystream_test.cpp
@@ -55,8 +55,8 @@ bool SingeBitStreamTest(int total_sections_to_write)
 	bool *comp_array_of_bools = new bool[total_sections_to_write];
 	Register_Pointer(comp_array_of_bools);
 
-	
-	for (int i = 0; i < total_sections_to_write; ++i)
+	int i;
+	for (i = 0; i < total_sections_to_write; ++i)
 	{
 		int random = Random::GetLessThan(10);
 
@@ -218,9 +218,8 @@ bool FloatIntBitStreamTest(int total_sections_to_write)
 	MinMaxHolderOf<float> *float_min_max = new MinMaxHolderOf<float>[total_sections_to_write];
 	Register_Pointer(float_min_max);
 
-
-
-	for (int i = 0; i < total_sections_to_write; ++i)
+	int i;
+	for (i = 0; i < total_sections_to_write; ++i)
 	{
 		int random = Random::GetLessThan(10);
 
@@ -393,7 +392,8 @@ bool MultipleBitStreamTest(int total_sections_to_write)
 
 	int total_bit_depth = 0;
 
-	for (int i = 0; i < total_sections_to_write; ++i)
+	int i, byte_count;
+	for (i = 0; i < total_sections_to_write; ++i)
 	{
 		bit_depth[i] = Random::GetLessThan(63) + 1;
 
@@ -503,7 +503,7 @@ bool MultipleBitStreamTest(int total_sections_to_write)
 
 		MString text = "\t---- Src Bit Value : "; 
 
-		for (int byte_count = 0; byte_count < 8; ++byte_count)
+		for (byte_count = 0; byte_count < 8; ++byte_count)
 		{
 			//Test_Assumption(source_byte_array == copy_byte_array);
 


  ================================================
diff --git a/source/mclib/stuff/mstring.hpp b/source/mclib/stuff/mstring.hpp
index c2d5226..1f8c079 100755
--- a/source/mclib/stuff/mstring.hpp
+++ b/source/mclib/stuff/mstring.hpp
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include "Stuff.hpp"
-#include "Hash.hpp"
-#include "Scalar.hpp"
+#include "stuff.hpp"
+#include "hash.hpp"
+#include "scalar.hpp"
 
 namespace Stuff
 {
@@ -20,12 +20,12 @@ namespace Stuff
 #if !defined(Spew)
 	void
 		Spew(
-			const char* group,
+			PCSTR  group,
 			const Stuff::MStringRepresentation& string
 		);
 	void
 		Spew(
-			const char* group,
+			PCSTR  group,
 			const Stuff::MString& string
 		);
 #endif
@@ -73,42 +73,42 @@ namespace Stuff {
 	//
 	void
 		Convert_From_Ascii(
-			const char* str,
+			PCSTR  str,
 			char* value
 		);
 	void
 		Convert_From_Ascii(
-			const char* str,
+			PCSTR  str,
 			BYTE* value
 		);
 	void
 		Convert_From_Ascii(
-			const char* str,
+			PCSTR  str,
 			short* value
 		);
 	void
 		Convert_From_Ascii(
-			const char* str,
+			PCSTR  str,
 			WORD* value
 		);
 	void
 		Convert_From_Ascii(
-			const char* str,
+			PCSTR  str,
 			int* value
 		);
 	void
 		Convert_From_Ascii(
-			const char* str,
+			PCSTR  str,
 			unsigned* value
 		);
 	void
 		Convert_From_Ascii(
-			const char* str,
+			PCSTR  str,
 			long* value
 		);
 	void
 		Convert_From_Ascii(
-			const char* str,
+			PCSTR  str,
 			DWORD* value
 		);
 
@@ -267,7 +267,7 @@ namespace Stuff {
 		#if !defined(Spew)
 			friend void
 				::Spew(
-					const char* group,
+					PCSTR  group,
 					const MStringRepresentation& string
 				);
 		#endif
@@ -464,20 +464,18 @@ namespace Stuff {
 		}
 	}
 
+#if USE_ASSEMBLER_CODE
 	inline IteratorPosition
 		MStringRepresentation::GetHashValue()
 	{
-		//
+
 		// Verify that the IteratorPosition is 32 bits wide
 		// Hash value is first 16 bits of fileID and first 16 bits of recordID
-		//
 		Verify(sizeof(IteratorPosition) == sizeof(DWORD));
-
 		static int andAway[3] = {0x000000ff, 0x0000ffff, 0x00ffffff };
-
 		IteratorPosition ret = 0;
 
-		register i, r, len = stringLength >> 2;
+		register int i, r, len = stringLength >> 2;
 
 		for(i=0;i<len;i++)
 		{
@@ -492,6 +490,8 @@ namespace Stuff {
 		return (ret & 0x7fffffff);
 	}
 
+#endif
+
 	//##########################################################################
 	//############################    MString    ###############################
 	//##########################################################################
@@ -630,7 +630,7 @@ namespace Stuff {
 		#if !defined(Spew)
 			friend void
 				::Spew(
-					const char* group,
+					PCSTR  group,
 					const MString &string
 				);
 		#endif
@@ -867,7 +867,7 @@ namespace Stuff {
 #if !defined(Spew)
 	inline void
 		Spew(
-			const char* group,
+			PCSTR  group,
 			const Stuff::MStringRepresentation &string
 		)
 	{
@@ -877,7 +877,7 @@ namespace Stuff {
 
 	inline void
 		Spew(
-			const char* group,
+			PCSTR  group,
 			const Stuff::MString &string
 		)
 	{


  ================================================
diff --git a/source/mclib/stuff/note.hpp b/source/mclib/stuff/note.hpp
index 99d01fa..9345fd5 100755
--- a/source/mclib/stuff/note.hpp
+++ b/source/mclib/stuff/note.hpp
@@ -63,14 +63,16 @@ namespace Stuff {
 	//
 	public:
 		void
-			GetEntry(const char **contents)
+			GetEntry(PCSTR *contents)
 				{
 					Check_Object(this); Check_Pointer(contents);
-					*contents = m_text;
+			if (contents) *contents = m_text;
 				}
 		void
 			SetEntry(const char *contents)
-				{Check_Object(this); m_text = contents;}
+		{
+			Check_Object(this); m_text = contents;
+		}
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// int access


  ================================================
diff --git a/source/mclib/stuff/obb.hpp b/source/mclib/stuff/obb.hpp
index c083561..bc9a9d7 100755
--- a/source/mclib/stuff/obb.hpp
+++ b/source/mclib/stuff/obb.hpp
@@ -124,7 +124,7 @@ namespace Stuff {
 				_asm {
 					mov         edx, matrix
 					push        esi
-					mov         esi, obb.localToParent
+					mov         esi, [esi]obb.localToParent
 					
 					mov         eax, f
 


  ================================================
diff --git a/source/mclib/stuff/point3d.hpp b/source/mclib/stuff/point3d.hpp
index 7785b1d..1a468db 100755
--- a/source/mclib/stuff/point3d.hpp
+++ b/source/mclib/stuff/point3d.hpp
@@ -21,8 +21,7 @@ namespace Stuff {
 		public Vector3D
 	{
 	public:
-		static const Point3D
-			Identity;
+		static const Point3D Identity;	// ??? strange
 
 		//
 		// Constructors


  ================================================
diff --git a/source/mclib/stuff/rotation.cpp b/source/mclib/stuff/rotation.cpp
index aabb46c..d41a918 100755
--- a/source/mclib/stuff/rotation.cpp
+++ b/source/mclib/stuff/rotation.cpp
@@ -511,9 +511,7 @@ void
 	tableIncrementStepOverOne = 1.0f / increment_step;
 	float cosom = MinCosom;
 
-	
-
-
+	int i;
 	for (int i = 0; i < QuaternionLerpTableSize; ++i)
 	{
 		Verify(cosom >= MinCosom);


  ================================================
diff --git a/source/mclib/stuff/scalar.hpp b/source/mclib/stuff/scalar.hpp
index c0f9803..ceafba7 100755
--- a/source/mclib/stuff/scalar.hpp
+++ b/source/mclib/stuff/scalar.hpp
@@ -113,7 +113,7 @@ namespace Stuff {
 				}
 				return temp;
 #else
-				return static_cast<Scalar>sqrt(f);
+				return static_cast<Scalar>(sqrt(f));
 #endif
 			}
 


  ================================================
diff --git a/source/mclib/stuff/sortedchain.hpp b/source/mclib/stuff/sortedchain.hpp
index 3343c00..cdf0705 100755
--- a/source/mclib/stuff/sortedchain.hpp
+++ b/source/mclib/stuff/sortedchain.hpp
@@ -363,11 +363,15 @@ namespace Stuff {
 		Check_Pointer(ptr1);
 		Check_Pointer(ptr2);
 
+		if (ptr1 && ptr2)
+		{
 		if (*ptr1 == *ptr2)
 			return 0;
 		else
 			return ((*ptr1 > *ptr2) ? 1 : -1);
 	}
+		return 0;
+	}
 
 	template <class T, class V> int
 		SortedChainOf<T, V>::CompareValueToSortedChainLink(
@@ -377,14 +381,19 @@ namespace Stuff {
 	{
 		Check_Pointer(value);
 
+		if (value){
 		V *ptr = Cast_Object(SortedChainLinkOf<V>*, node)->GetValuePointer();
 		Check_Pointer(ptr);
-
+			if (ptr)
+			{
 		if (*Cast_Pointer(const V*, value) == *ptr)
 			return 0;
 		else
 			return (*Cast_Pointer(const V*, value) > *ptr) ? 1 : -1;
 	}
+		}
+		return 0;
+	}
 
 	template <class T, class V> void*
 		SortedChainOf<T, V>::operator new(size_t)


  ================================================
diff --git a/source/mclib/stuff/stuff.cpp b/source/mclib/stuff/stuff.cpp
index fbd67af..40645ef 100755
--- a/source/mclib/stuff/stuff.cpp
+++ b/source/mclib/stuff/stuff.cpp
@@ -2,8 +2,10 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "StuffHeaders.hpp"
+#include "stdafx.h"
+#include "stuffheaders.hpp"
 #include "eh.h"
+#include "trace.cpp"
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 //


  ================================================
diff --git a/source/mclib/stuff/stuff.hpp b/source/mclib/stuff/stuff.hpp
index a04370a..c9ccc86 100755
--- a/source/mclib/stuff/stuff.hpp
+++ b/source/mclib/stuff/stuff.hpp
@@ -7,27 +7,27 @@
 
 #pragma once
 
-#pragma warning(disable: 4018)	// signed/unsigned mismatches
-#pragma warning(disable: 4097)	// typedef synonyms
-#pragma warning(disable: 4100)	// unreferenced parameters
-#pragma warning(disable: 4102)	// unreferenced labels
-#pragma warning(disable: 4127)	// constant comparisons
-#pragma warning(disable: 4130)	// logical operation on string constants
-#pragma warning(disable: 4201)	// nameless structs
-#pragma warning(disable: 4245)	// casting enum to long
-#pragma warning(disable: 4355)	// this used in base initializers
-#pragma warning(disable: 4511)	// no copy constructor
-#pragma warning(disable: 4512)	// no assignment operator
-#pragma warning(disable: 4514)
-#if defined(_ARMOR) && !defined(_DEBUG)
-	#pragma warning(disable: 4700)	// variable used without initialization
-	#pragma warning(disable: 4701)	// variable maybe not initialized
-#endif
-#pragma warning(disable: 4710)	// inline not expanded
-#pragma warning(disable: 4711)	// auto-inline selection
-#pragma warning(disable: 4291)	// exception handlings and new
-
-#pragma warning(push,3)
+//#pragma warning(disable: 4018)	// signed/unsigned mismatches
+//#pragma warning(disable: 4097)	// typedef synonyms
+//#pragma warning(disable: 4100)	// unreferenced parameters
+//#pragma warning(disable: 4102)	// unreferenced labels
+//#pragma warning(disable: 4127)	// constant comparisons
+//#pragma warning(disable: 4130)	// logical operation on string constants
+//#pragma warning(disable: 4201)	// nameless structs
+//#pragma warning(disable: 4245)	// casting enum to long
+//#pragma warning(disable: 4355)	// this used in base initializers
+//#pragma warning(disable: 4511)	// no copy constructor
+//#pragma warning(disable: 4512)	// no assignment operator
+//#pragma warning(disable: 4514)
+//#if defined(_ARMOR) && !defined(_DEBUG)
+//	#pragma warning(disable: 4700)	// variable used without initialization
+//	#pragma warning(disable: 4701)	// variable maybe not initialized
+//#endif
+//#pragma warning(disable: 4710)	// inline not expanded
+//#pragma warning(disable: 4711)	// auto-inline selection
+//#pragma warning(disable: 4291)	// exception handlings and new
+//
+//#pragma warning(push,3)
 
 #include <math.h>
 #include <float.h>
@@ -37,13 +37,17 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <limits.h>
-#pragma warning(pop)
+//#pragma warning(pop)
 
-#pragma warning(push)
-#include <gameOS.hpp>
-#pragma warning(pop)
+//#pragma warning(push)
+#include <gameos.hpp>
+//#pragma warning(pop)
 
+#if _M_IX86
 #define USE_ASSEMBLER_CODE	1
+#else
+#define USE_ASSEMBLER_CODE	0
+#endif
 
 namespace Stuff {
 
@@ -189,40 +193,40 @@ namespace Stuff {
 #define GROUP_STUFF_MEMORY "Stuff::Memory"
 #define GROUP_STUFF_TRACE "Stuff::Trace"
 
-#include "Style.hpp"
-#include "MString.hpp"
-#include "Slot.hpp"
-#include "Chain.hpp"
-#include "SafeChain.hpp"
-#include "SortedChain.hpp"
-#include "Table.hpp"
-#include "Tree.hpp"
-#include "Hash.hpp"
-#include "Angle.hpp"
-#include "Color.hpp"
-#include "ExtentBox.hpp"
-#include "FileStream.hpp"
-#include "FileStreamManager.hpp"
-#include "Line.hpp"
-#include "MArray.hpp"
-#include "MatrixStack.hpp"
-#include "Auto_Ptr.hpp"
-#include "Auto_Container.hpp"
-#include "Noncopyable.hpp"
-#include "Initialized_Ptr.hpp"
-#include "Motion.hpp"
-#include "NotationFile.hpp"
-#include "Page.hpp"
-#include "Note.hpp"
-#include "OBB.hpp"
-#include "Origin.hpp"
-#include "Plane.hpp"
-#include "Point3D.hpp"
-#include "Polar.hpp"
-#include "Random.hpp"
-#include "Sphere.hpp"
-#include "Vector2D.hpp"
-#include "Vector4D.hpp"
-#include "Trace.hpp"
-#include "Average.hpp"
-#include "Database.hpp"
+#include "style.hpp"
+#include "mstring.hpp"
+#include "slot.hpp"
+#include "chain.hpp"
+#include "safechain.hpp"
+#include "sortedchain.hpp"
+#include "table.hpp"
+#include "tree.hpp"
+#include "hash.hpp"
+#include "angle.hpp"
+#include "color.hpp"
+#include "extentbox.hpp"
+#include "filestream.hpp"
+#include "filestreammanager.hpp"
+#include "line.hpp"
+#include "marray.hpp"
+#include "matrixstack.hpp"
+#include "auto_ptr.hpp"
+#include "auto_container.hpp"
+#include "noncopyable.hpp"
+#include "initialized_ptr.hpp"
+#include "motion.hpp"
+#include "notationfile.hpp"
+#include "page.hpp"
+#include "note.hpp"
+#include "obb.hpp"
+#include "origin.hpp"
+#include "plane.hpp"
+#include "point3d.hpp"
+#include "polar.hpp"
+#include "random.hpp"
+#include "sphere.hpp"
+#include "vector2d.hpp"
+#include "vector4d.hpp"
+#include "trace.hpp"
+#include "average.hpp"
+#include "database.hpp"


  ================================================
diff --git a/source/mclib/stuff/stuffheaders.cpp b/source/mclib/stuff/stuffheaders.cpp
index c99fe0d..56b184d 100755
--- a/source/mclib/stuff/stuffheaders.cpp
+++ b/source/mclib/stuff/stuffheaders.cpp
@@ -2,6 +2,6 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "StuffHeaders.hpp"
+#include "stuffheaders.hpp"
 
 // This file does nothing but make the pch file
\ No newline at end of file


  ================================================
diff --git a/source/mclib/stuff/stuffheaders.hpp b/source/mclib/stuff/stuffheaders.hpp
index e5c1a55..1ca4c01 100755
--- a/source/mclib/stuff/stuffheaders.hpp
+++ b/source/mclib/stuff/stuffheaders.hpp
@@ -6,6 +6,6 @@
 
 #pragma once
 
-#include "Stuff.hpp"
+#include "stuff.hpp"
 
 using namespace Stuff;


  ================================================
diff --git a/source/mclib/stuff/trace.cpp b/source/mclib/stuff/trace.cpp
index 76c1de0..8464e8d 100755
--- a/source/mclib/stuff/trace.cpp
+++ b/source/mclib/stuff/trace.cpp
@@ -5,8 +5,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#include "StuffHeaders.hpp"
-#include <ToolOS.hpp>
+#include "stuffheaders.hpp"
+#include <toolos.hpp>
 
 #if defined(TRACE_ENABLED)
 


  ================================================
diff --git a/source/mclib/stuff/tree.hpp b/source/mclib/stuff/tree.hpp
index ba7c66f..03d6930 100755
--- a/source/mclib/stuff/tree.hpp
+++ b/source/mclib/stuff/tree.hpp
@@ -344,10 +344,15 @@ namespace Stuff {
       Check_Pointer(ptr1);
       Check_Pointer(ptr2);
 
+		if (ptr1 && ptr2)
+		{
    	if (*ptr1 == *ptr2)
       	return 0;
       else
       	return ((*ptr1 > *ptr2) ? 1 : -1);
+
+		}
+		return 0;
 	}
 
 	template <class T, class V> int
@@ -361,11 +366,15 @@ namespace Stuff {
 		V *ptr = Cast_Object(TreeNodeOf<V>*, node)->GetValuePointer();
       Check_Pointer(ptr);
 
+		if (value && ptr)
+		{
       if (*Cast_Pointer(const V*, value) == *ptr)
       	return 0;
       else
       	return (*Cast_Pointer(const V*, value) > *ptr) ? 1 : -1;
 	}
+		return 0;
+	}
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TreeIterator ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -478,21 +487,30 @@ namespace Stuff {
 		// Iterator methods (see Iterator for full listing)
 		//--------------------------------------------------------------------
 		//
-		T
-			ReadAndNext()
-				{return (T)ReadAndNextImplementation();}
-		T
-			GetCurrent()
-				{return (T)GetCurrentImplementation();}
-		T
-			GetNth(CollectionSize index)
-				{return (T)GetNthImplementation(index);}
-		T
-			Find(const V &value)
-				{return (T)FindImplementation(&value);}
-		V
-			GetValue()
-         	{return Cast_Object(TreeNodeOf<V>*, currentNode)->GetValue();}
+		T ReadAndNext()
+		{
+			return (T)ReadAndNextImplementation();
+		}
+		
+		T GetCurrent()
+		{
+			return (T)GetCurrentImplementation();
+		}
+		
+		T GetNth(CollectionSize index)
+		{
+			return (T)GetNthImplementation(index);
+		}
+
+		T Find(const V &value)
+		{
+			return (T)FindImplementation(&value);
+		}
+		
+		V GetValue()
+		{
+			return Cast_Object(TreeNodeOf<V>*, currentNode)->GetValue();
+		}
 	};
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~ TreeIteratorOf templates ~~~~~~~~~~~~~~~~~~~~~~~


  ================================================
diff --git a/source/mclib/terrtxm.cpp b/source/mclib/terrtxm.cpp
index 50c0360..4b2bc36 100755
--- a/source/mclib/terrtxm.cpp
+++ b/source/mclib/terrtxm.cpp
@@ -181,7 +181,8 @@ long TerrainTextures::init (char *fileName, char *baseName)
 
 	//-----------------------------------
 	// Read in the Base Terrain Textures.
-	for (long i=0;i<numTypes;i++)
+	long i;
+	for (i=0;i<numTypes;i++)
 	{
 		char blockName[512];
 		sprintf(blockName,"TerrainType%d",i);
@@ -953,7 +954,8 @@ void TerrainTextures::combineOverlayTxm (MemoryPtr dest, long type, long mipLeve
 	//Convert overlay Type to actual overlay Index.
 	long oType = 0;
 	long oIndx = 0;
-	for (long i=0;i<numOverlays;i++)
+	long i;
+	for (i=0;i<numOverlays;i++)
 	{
 		if ((type >= overlays[i].baseTXMIndex) &&
 			(type < (overlays[i].baseTXMIndex + overlays[i].numTextures)))
@@ -1090,7 +1092,8 @@ long TerrainTextures::createTransition (DWORD typeInfo, DWORD overlayInfo)
 		// Search Existing Transitions for this typeInfo.
 		// Does not need to be fast yet.  May not ever since we
 		// only do this on load can be done on Heidi's end.
-		for (long i=0;i<nextTransition;i++)
+		long i;
+		for (i=0;i<nextTransition;i++)
 		{
 			if ((typeInfo == transitions[i].transitionIndex) && 
 				(overlayInfo == transitions[i].overlayIndex))
@@ -1126,12 +1129,12 @@ long TerrainTextures::createTransition (DWORD typeInfo, DWORD overlayInfo)
 				DWORD fileSize = txmFile.fileSize();
 				MemoryPtr fileRAM = (MemoryPtr)malloc(fileSize);
 				long result = txmFile.read(fileRAM,fileSize);
-				if (result != fileSize)
+				if (result != (long)fileSize)
 					STOP(("Read Error with Texture %s",testPath));
 
 				MemoryPtr lzBuffer = (MemoryPtr)malloc(mipSize * mipSize * sizeof(DWORD));
 				long bufferSize = LZDecomp(lzBuffer,fileRAM,fileSize);
-				if (bufferSize != (mipSize * mipSize * sizeof(DWORD)))
+				if (bufferSize != (long)(mipSize * mipSize * sizeof(DWORD)))
 					STOP(("Texture not correct size!"));
 
 				txmFile.close();


  ================================================
diff --git a/source/mclib/terrtxm2.cpp b/source/mclib/terrtxm2.cpp
index 961f67c..bee0ea3 100755
--- a/source/mclib/terrtxm2.cpp
+++ b/source/mclib/terrtxm2.cpp
@@ -222,7 +222,8 @@ void TerrainColorMap::refractalizeBaseMesh (char *fileName, long Threshold, long
 	//Find max and min vertex elevations for scaling below.
 	float maxVertex = land->getTerrainElevation(0,0);
 	float minVertex = maxVertex;
-	for (long y=0;y<Terrain::realVerticesMapSide;y++)
+	long y;
+	for (y=0;y<Terrain::realVerticesMapSide;y++)
 	{
 		for (long x=0;x<Terrain::realVerticesMapSide;x++)
 		{
@@ -264,7 +265,8 @@ void TerrainColorMap::refractalizeBaseMesh (char *fileName, long Threshold, long
 	
 	float *tmpEdge = srcData;
 	MemoryPtr tmpOutput = sourceData;
-	for (long i=0;i<Terrain::realVerticesMapSide * Terrain::realVerticesMapSide;i++)
+	long i;
+	for (i=0;i<Terrain::realVerticesMapSide * Terrain::realVerticesMapSide;i++)
 	{
 		*tmpOutput = (BYTE)CLAMP(*tmpEdge,BLACK_PIXEL,WHITE_PIXEL);
 		tmpOutput++;
@@ -850,7 +852,8 @@ void TerrainColorMap::burnInShadows (bool doBumpPass, char *fileName)
 	}
 	
 	//Smooth out the shadow map to make shadows better.
-	for (long i=pixelWidth;i<((pixelWidth * pixelWidth)-pixelWidth);i++)
+	long i;
+	for (i=pixelWidth;i<((pixelWidth * pixelWidth)-pixelWidth);i++)
 	{
 		if (shadowMap[i] == -1.0f)
 		{
@@ -1255,7 +1258,8 @@ void TerrainColorMap::recalcLight(char *fileName)
 void TerrainColorMap::resetBaseTexture (char *fileName)
 {
 	//First, free up the existing colormap.
-	for (unsigned long i=0;i<numTextures;i++)
+	unsigned long i;
+	for (i=0;i<numTextures;i++)
 	{
 		mcTextureManager->removeTextureNode(textures[i].mcTextureNodeIndex);
 		textures[i].mcTextureNodeIndex = 0xffffffff;


  ================================================
diff --git a/source/mclib/tgainfo.cpp b/source/mclib/tgainfo.cpp
index b12f4fa..67a997d 100755
--- a/source/mclib/tgainfo.cpp
+++ b/source/mclib/tgainfo.cpp
@@ -7,6 +7,8 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
+//#include <string.h>
 
 #ifndef TGAINFO_H
 #include "tgainfo.h"
@@ -14,7 +16,6 @@
 
 #include "EString.h"
 
-#include <string.h>
 #include <gameos.hpp>
 //---------------------------------------------------------------------------
 typedef struct _RGB


  ================================================
diff --git a/source/mclib/tgl.cpp b/source/mclib/tgl.cpp
index 70170e3..f420070 100755
--- a/source/mclib/tgl.cpp
+++ b/source/mclib/tgl.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef TGL_H
 #include "tgl.h"
@@ -769,7 +770,8 @@ long TG_TypeShape::ParseASEFile (BYTE *aseBuffer, char *fileName)
 
 	memset(vertexNormalCount,0,sizeof(long) * numTypeVertices);
 
-	for (long i=0;i<numTypeVertices;i++)
+	long i;
+	for (i=0;i<numTypeVertices;i++)
 	{
 		char numberData[256];
 
@@ -1593,8 +1595,9 @@ long TG_Shape::MultiTransformShape (Stuff::Matrix4D *shapeToClip, Stuff::Point3D
 		return(1);
 
 	lastTurnTransformed = turn;
+	long j;
 
-	for (long j=0;j<numVertices;j++)
+	for (j=0;j<numVertices;j++)
 	{
 		Stuff::Point3D pos = theShape->listOfTypeVertices[j].position;
 		if (shapeScalar > 0.0f)
@@ -2406,7 +2409,7 @@ void TG_Shape::Render (float forceZ, bool isHudElement, BYTE alphaValue, bool is
 		!listOfTriangles ||
 		!listOfVisibleFaces ||
 		!listOfVisibleShadows ||
-		(/*(lastTurnTransformed != (turn-1)) &&*/ (lastTurnTransformed != turn)))
+		(/*(lastTurnTransformed != (turn-1)) &&*/ (lastTurnTransformed != (DWORD)turn)))
 		return;
 
 	if (fogColor != 0xffffffff)
@@ -2570,7 +2573,7 @@ bool TG_Shape::PerPolySelect (float mouseX, float mouseY)
 			!listOfTriangles ||
 			!listOfVisibleFaces ||
 			!listOfVisibleShadows ||
-			((lastTurnTransformed != (turn-1)) /*&& (lastTurnTransformed != turn)*/))
+			((lastTurnTransformed != (DWORD)(turn-1)) /*&& (lastTurnTransformed != turn)*/))
 			return false;
 	}
 	else
@@ -2581,7 +2584,7 @@ bool TG_Shape::PerPolySelect (float mouseX, float mouseY)
 			!listOfTriangles ||
 			!listOfVisibleFaces ||
 			!listOfVisibleShadows ||
-			((lastTurnTransformed != (turn-1)) && (lastTurnTransformed != turn)))
+			((lastTurnTransformed != (DWORD)(turn-1)) && (lastTurnTransformed != (DWORD)turn)))
 			return false;
 	}
 
@@ -3039,7 +3042,7 @@ long TG_Shape::RenderShadows (long startFace)
 		!listOfTriangles ||
 		!listOfVisibleFaces ||
 		!listOfVisibleShadows ||
-		(/*(lastTurnTransformed != (turn-1)) &&*/ (lastTurnTransformed != turn)))
+		(/*(lastTurnTransformed != (turn-1)) &&*/ (lastTurnTransformed != (DWORD)turn)))
 		return startFace;
 
  	if (fogColor != 0xffffffff)


  ================================================
diff --git a/source/mclib/tgl.h b/source/mclib/tgl.h
index 217ba63..a27d442 100755
--- a/source/mclib/tgl.h
+++ b/source/mclib/tgl.h
@@ -26,7 +26,7 @@
 //-------------------------------------------------------------------------------
 // Structs used by layer.
 //
-typedef DWORD* DWORDPtr;
+typedef ULONG* DWORDPtr;
 
 //-------------------------------------------------------------------------------
 // TG_TypeVertex
@@ -36,7 +36,7 @@ typedef struct _TG_TypeVertex
 	//Only changes at load time.
 	Stuff::Point3D	position;				//Position of vertex relative to base position of shape.
 	Stuff::Vector3D normal;					//Vertex Normal
-	DWORD    		aRGBLight;				//Vertex Light and Alpha
+	ULONG    		aRGBLight;				//Vertex Light and Alpha
 
 } TG_TypeVertex;
 
@@ -74,7 +74,7 @@ typedef  TG_ShadowVertex* TG_ShadowVertexPtr;
 // Stores VOLATILE information for the shadow vertices.  These can come from a pool!
 typedef struct _TG_ShadowVertexTemp
 {
-	DWORD    		fRGBFog;				//Vertex Fog and Specular Color.  Needed if shadow is fogged.
+	ULONG    		fRGBFog;				//Vertex Fog and Specular Color.  Needed if shadow is fogged.
 											//Every frame for local light.  Once in a blue moon for infinite light.
 
 	//Changes each call to Transform.
@@ -103,9 +103,9 @@ typedef  TG_UVData* TG_UVDataPtr;
 // This structure stores the information needed to draw the triangle which does NOT change per instance
 typedef struct _TG_TypeTriangle
 {
-	DWORD    		Vertices[3];			//Indices into Vertex List.
-	DWORD    		localTextureHandle;		//Index into texture List.
-	DWORD    		renderStateFlags;		//Flags about render for this face.
+	ULONG    		Vertices[3];			//Indices into Vertex List.
+	ULONG    		localTextureHandle;		//Index into texture List.
+	ULONG    		renderStateFlags;		//Flags about render for this face.
 											//Bit 0 -- backFacing
 	TG_UVData  		uvdata;					//Texture UVs for this face.
 	Stuff::Vector3D faceNormal;				//Normal Vector to face
@@ -120,8 +120,8 @@ typedef TG_TypeTriangle* TG_TypeTrianglePtr;
 // This structure stores the information needed to draw the triangle per instance.
 typedef struct _TG_Triangle
 {
-	DWORD    		aRGBLight[3];			//RGB Light for this triangle's vertices.
-	DWORD    		fRGBLight[3];			//RGB Fog for this triangle's vertices.
+	ULONG    		aRGBLight[3];			//RGB Light for this triangle's vertices.
+	ULONG    		fRGBLight[3];			//RGB Fog for this triangle's vertices.
 } TG_Triangle;
 
 // Texture handle can change from frame to frame. Texture Animation!
@@ -133,7 +133,7 @@ typedef TG_Triangle* TG_TrianglePtr;
 // This structure stores the information needed to draw the shadow triangle.
 typedef struct _TG_ShadowTriangle
 {
-	DWORD    		Vertices[3];			//Indices into Shadow Vertex List.
+	ULONG    		Vertices[3];			//Indices into Shadow Vertex List.
 } TG_ShadowTriangle;
 
 // Texture handle can change from frame to frame. Texture Animation!
@@ -164,12 +164,12 @@ typedef TG_ShadowTriangle* TG_ShadowTrianglePtr;
 // This structure stores the information necessary to light the shape.
 typedef struct _TG_Light
 {
-	DWORD    				lightType;			//Ambient, directional, etc.
+	ULONG    				lightType;			//Ambient, directional, etc.
 	bool					active;				//Should this light be considered on?
 	
 	protected:
-	DWORD    				aRGB;				//Color
-	DWORD					OEMaRGB;
+	ULONG    				aRGB;				//Color
+	ULONG					OEMaRGB;
 	
 	public:
 	float					intensity;			//How Bright
@@ -182,7 +182,7 @@ typedef struct _TG_Light
 	Stuff::Point3D			spotDir;			//Direction of the actual Spotlight to help with shadows, etc.
 	float					maxSpotLength;		//Maximum length spotlight can be from target.
 
-	void init (DWORD lType)
+	void init (ULONG lType)
 	{
 		gosASSERT((lType != TG_LIGHT_NONE) && (lType >= TG_LIGHT_AMBIENT) && (lType <= TG_LIGHT_TERRAIN));
 
@@ -199,12 +199,12 @@ typedef struct _TG_Light
 		active = false;
 	}
 
-	void SetaRGB (DWORD newaRGB)
+	void SetaRGB (ULONG newaRGB)
 	{
 		OEMaRGB = aRGB = newaRGB;
 	}
 
-	DWORD GetaRGB (void)
+	ULONG GetaRGB (void)
 	{
 		return aRGB;
 	}
@@ -233,10 +233,10 @@ typedef struct _TG_Light
 			intensity = 1.0f;
 
 		//Scale aRGB by intensity
-		DWORD r,g,b;
-		r = intensity * ((OEMaRGB >> 16) & 0x000000ff);
-		g = intensity * ((OEMaRGB >> 8) & 0x000000ff);
-		b = intensity * ((OEMaRGB) & 0x000000ff);
+		ULONG r,g,b;
+		r = (ULONG)(intensity * ((OEMaRGB >> 16) & 0x000000ff));
+		g = (ULONG)(intensity * ((OEMaRGB >> 8) & 0x000000ff));
+		b = (ULONG)(intensity * ((OEMaRGB) & 0x000000ff));
 
 		aRGB = (0xff << 24) + (r << 16) + (g << 8) + (b);
 	}
@@ -267,8 +267,8 @@ typedef  TG_Light *TG_LightPtr;
 typedef struct _TG_Texture
 {
 	char				textureName[256];
-	DWORD				mcTextureNodeIndex;
-	DWORD				gosTextureHandle;
+	ULONG				mcTextureNodeIndex;
+	ULONG				gosTextureHandle;
 	bool				textureAlpha;
 } TG_Texture;
 
@@ -278,8 +278,8 @@ typedef TG_Texture* TG_TexturePtr;
 // TG_TinyTexture
 typedef struct _TG_TinyTexture
 {
-	DWORD				mcTextureNodeIndex;
-	DWORD				gosTextureHandle;
+	ULONG				mcTextureNodeIndex;
+	ULONG				gosTextureHandle;
 	bool				textureAlpha;
 } TG_TinyTexture;
 
@@ -291,8 +291,8 @@ class TG_Shape;
 typedef struct _TG_Animation
 {
 	char 						nodeId[TG_NODE_ID];		//Node ID
-	DWORD						shapeId;				//DON'T SCAN EVERY FRAME.  WOW IS IT SLOW!!!!!  Set this first time through and its simple.
-	DWORD						numFrames;				//Number of Frames of animation.
+	ULONG						shapeId;				//DON'T SCAN EVERY FRAME.  WOW IS IT SLOW!!!!!  Set this first time through and its simple.
+	ULONG						numFrames;				//Number of Frames of animation.
 	float 						frameRate;				//Number of Frames Per Second.
 	float						tickRate;				//Number of Ticks Per Second.
 	Stuff::UnitQuaternion		*quat;					//Stores animation offset in Quaternion rotation.
@@ -365,12 +365,12 @@ class TG_TypeNode
 		
 		virtual void destroy (void);
 		
-		char *getNodeId (void)
+		PSTR getNodeId (void)
 		{
 			return nodeId;
 		}
 
-		char *getParentId (void)
+		PSTR getParentId (void)
 		{
 			return parentId;
 		}
@@ -412,7 +412,7 @@ class TG_TypeNode
 		//
 		// NOTE: Only takes the first GEOMOBJECT from the ASE file.  Multi-object
 		// Files will require user intervention to parse!!
-		virtual long ParseASEFile (BYTE *aseBuffer, char *filename)
+		virtual long ParseASEFile (PUCHAR /*aseBuffer*/, PSTR /*filename*/)
 		{
 			return 0;
 		}
@@ -424,7 +424,7 @@ class TG_TypeNode
 		//
 		// NOTE: Only takes the first HELPEROBJECT from the ASE file.  Multi-object
 		// Files will require user intervention to parse!!
-		virtual long MakeFromHelper (BYTE *aseBuffer, char *filename);
+		virtual long MakeFromHelper (PUCHAR aseBuffer, PSTR filename);
 
 		//Function returns 0 if OK.  -1 if file not found or file not ASE Format.		
 		//This function loads the ASE file into the TG_Triangle and TG_Vertex lists.
@@ -432,7 +432,7 @@ class TG_TypeNode
 		//
 		// NOTE: Only takes the first GEOMOBJECT from the ASE file.  Multi-object
 		// Files will require user intervention to parse!!
-		virtual long LoadTGShapeFromASE (char *fileName)
+		virtual long LoadTGShapeFromASE (PSTR /*fileName*/)
 		{
 			return 0;
 		}
@@ -440,7 +440,7 @@ class TG_TypeNode
 		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
 		//This function takes the gosTextureHandle passed in and assigns it to the
 		//textureNum entry of the listOfTextures;
-		virtual long SetTextureHandle (DWORD textureNum, DWORD gosTextureHandle)
+		virtual long SetTextureHandle (ULONG /*textureNum*/, ULONG /*gosTextureHandle*/)
 		{
 			return 0;
 		}
@@ -448,13 +448,13 @@ class TG_TypeNode
 		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
 		//This function takes the gosTextureHandle passed in and assigns it to the
 		//textureNum entry of the listOfTextures;
-		virtual long SetTextureAlpha (DWORD textureNum, bool alphaFlag)
+		virtual long SetTextureAlpha (ULONG /*textureNum*/, bool /*alphaFlag*/)
 		{
 			return 0;
 		}
 
 		//Need this so that Multi-Shapes can let each shape know texture info.
-		virtual void CreateListOfTextures (TG_TexturePtr list, DWORD numTxms)
+		virtual void CreateListOfTextures (TG_TexturePtr /*list*/, ULONG /*numTxms*/)
 		{
 		}
 
@@ -462,15 +462,15 @@ class TG_TypeNode
 		// Creates an instance of this shape for the game to muck with.
 		virtual TG_Shape *CreateFrom (void);
 
-		virtual void SetAlphaTest (bool flag)
+		virtual void SetAlphaTest (bool /*flag*/)
 		{
 		}
 
-		virtual void SetFilter (bool flag)
+		virtual void SetFilter (bool /*flag*/)
 		{
 		}
 
-		virtual void SetLightRGBs (DWORD hPink, DWORD hGreen, DWORD hYellow)
+		virtual void SetLightRGBs (ULONG /*hPink*/, ULONG /*hGreen*/, ULONG /*hYellow*/)
 		{
 		}
 		
@@ -502,17 +502,17 @@ class TG_TypeShape : public TG_TypeNode
 	//-------------
 	//Data Members
 	protected:
-		DWORD					numTypeVertices;			//Number of vertices in Shape
-		DWORD					numTypeTriangles;			//NUmber of triangles in Shape
-		DWORD					numTextures;				//Number of textures in Shape
+		ULONG					numTypeVertices;			//Number of vertices in Shape
+		ULONG					numTypeTriangles;			//NUmber of triangles in Shape
+		ULONG					numTextures;				//Number of textures in Shape
 
 		TG_TypeVertexPtr		listOfTypeVertices;			//Memory holding all vertex data
 		TG_TypeTrianglePtr		listOfTypeTriangles;		//Memory holding all triangle data
 		TG_TinyTexturePtr		listOfTextures;				//List of texture Structures for this shape.
 
-		DWORD					hotPinkRGB;					//Stores the value for this shape to replace hot Pink With
-		DWORD					hotYellowRGB;				//Stores the value for this shape to replace hot Yellow With 
-		DWORD					hotGreenRGB;            	//Stores the value for this shape to replace hot Green With 
+		ULONG					hotPinkRGB;					//Stores the value for this shape to replace hot Pink With
+		ULONG					hotYellowRGB;				//Stores the value for this shape to replace hot Yellow With 
+		ULONG					hotGreenRGB;            	//Stores the value for this shape to replace hot Green With 
 
 		bool					alphaTestOn;				//Decides if we should draw alphaTest On or not!
 		bool					filterOn;					//Decides if we should filter the shape or not!
@@ -566,7 +566,7 @@ class TG_TypeShape : public TG_TypeNode
 		//
 		// NOTE: Only takes the first GEOMOBJECT from the ASE file.  Multi-object
 		// Files will require user intervention to parse!!
-		virtual long ParseASEFile (BYTE *aseBuffer, char *filename);	//filename for error reporting ONLY
+		virtual long ParseASEFile (PUCHAR aseBuffer, PSTR filename);	//filename for error reporting ONLY
 
 		//Function return 0 is OK.  -1 if file is not ASE Format or missing data.
 		//This function simply parses the ASE buffers handed to it.  This allows
@@ -575,7 +575,7 @@ class TG_TypeShape : public TG_TypeNode
 		//
 		// NOTE: Only takes the first HELPEROBJECT from the ASE file.  Multi-object
 		// Files will require user intervention to parse!!
-		virtual long MakeFromHelper (BYTE *aseBuffer, char *filename);
+		virtual long MakeFromHelper (PUCHAR aseBuffer, PSTR filename);
 
 		//Function returns 0 if OK.  -1 if file not found or file not ASE Format.		
 		//This function loads the ASE file into the TG_Triangle and TG_Vertex lists.
@@ -583,20 +583,20 @@ class TG_TypeShape : public TG_TypeNode
 		//
 		// NOTE: Only takes the first GEOMOBJECT from the ASE file.  Multi-object
 		// Files will require user intervention to parse!!
-		virtual long LoadTGShapeFromASE (char *fileName);
+		virtual long LoadTGShapeFromASE (PSTR fileName);
 
 		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
 		//This function takes the gosTextureHandle passed in and assigns it to the
 		//textureNum entry of the listOfTextures;
-		virtual long SetTextureHandle (DWORD textureNum, DWORD gosTextureHandle);
+		virtual long SetTextureHandle (ULONG textureNum, ULONG gosTextureHandle);
 
 		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
 		//This function takes the gosTextureHandle passed in and assigns it to the
 		//textureNum entry of the listOfTextures;
-		virtual long SetTextureAlpha (DWORD textureNum, bool alphaFlag);
+		virtual long SetTextureAlpha (ULONG textureNum, bool alphaFlag);
 
 		//Need this so that Multi-Shapes can let each shape know texture info.
-		virtual void CreateListOfTextures (TG_TexturePtr list, DWORD numTxms);
+		virtual void CreateListOfTextures (TG_TexturePtr list, ULONG numTxms);
 
  		virtual void movePosRelativeCenterNode (void);
 		
@@ -614,7 +614,7 @@ class TG_TypeShape : public TG_TypeNode
 			filterOn = flag;
 		}
 
-		virtual void SetLightRGBs (DWORD hPink, DWORD hGreen, DWORD hYellow)
+		virtual void SetLightRGBs (ULONG hPink, ULONG hGreen, ULONG hYellow)
 		{
 			hotPinkRGB = hPink;
 			hotGreenRGB = hGreen;
@@ -650,10 +650,10 @@ class TG_Shape
 	//Data Members
 	protected:
 		TG_TypeNodePtr			myType;						//Pointer to the instance of the shape.
-		DWORD					numVertices;				//Number of vertices in Shape
-		DWORD					numTriangles;				//NUmber of triangles in Shape
-		DWORD					numVisibleFaces;			//Number of non-backfaced non-clipped faces.
-		DWORD					numVisibleShadows;			//Number of visible Shadow Faces.
+		ULONG					numVertices;				//Number of vertices in Shape
+		ULONG					numTriangles;				//NUmber of triangles in Shape
+		ULONG					numVisibleFaces;			//Number of non-backfaced non-clipped faces.
+		ULONG					numVisibleShadows;			//Number of visible Shadow Faces.
 
 		TG_Vertex *				listOfColors;				//Memory holding all unchanged or rarely changed color data.
 		gos_VERTEX * 			listOfVertices;				//Memory holding all vertex data
@@ -673,8 +673,8 @@ class TG_Shape
 
 		bool					shadowsVisible[MAX_SHADOWS];//Is this shadow worth drawing?
 
-		DWORD					aRGBHighlight;				//Color to add to vertices to make building stand out.
-		DWORD					fogRGB;						//Color to make fog.
+		ULONG					aRGBHighlight;				//Color to add to vertices to make building stand out.
+		ULONG					fogRGB;						//Color to make fog.
 		
 		float					shapeScalar;
 
@@ -684,7 +684,7 @@ class TG_Shape
 		bool					isWindow;
 		bool					isSpotlight;
 
-		DWORD					lastTurnTransformed;
+		ULONG					lastTurnTransformed;
 
 	public:
 		//Matrices used to transform the shapes.
@@ -693,14 +693,14 @@ class TG_Shape
 		static Stuff::Matrix4D			worldToClip;
 		static Stuff::LinearMatrix4D	worldToCamera;
 		static TG_LightPtr				*listOfLights;		//List passed in a transform time
-		static DWORD					numLights;
+		static ULONG					numLights;
 
 		static float					viewMulX;
 		static float					viewAddX;
 		static float					viewMulY;
 		static float					viewAddY;
 
-		static DWORD					fogColor;
+		static ULONG					fogColor;
 		static float					fogFull;
 		static float					fogStart;
 
@@ -711,7 +711,7 @@ class TG_Shape
 
 		static UserHeapPtr 				tglHeap;		//Stores all TGL data so we don't need to go through the FREE merry go round of GOS!
 		
-		static DWORD					lighteningLevel;
+		static ULONG					lighteningLevel;
 
 	//-----------------
 	//Member Functions
@@ -768,16 +768,16 @@ class TG_Shape
 
 		static void SetViewport (float mulX, float mulY, float addX, float addY);
 
-		static void SetFog (DWORD fRGB, float fStart, float fFull);
+		static void SetFog (ULONG fRGB, float fStart, float fFull);
 
 		//This function sets the list of lights used by the TransformShape function
 		//to light the shape.
 		//Function returns 0 if lightList entries are all OK.  -1 otherwise.
 		//
-		long SetLightList (TG_LightPtr *lightList, DWORD nLights);
+		long SetLightList (TG_LightPtr *lightList, ULONG nLights);
 		
 		//This function sets the fog values for the shape.  Straight fog right now.
-		void SetFogRGB (DWORD fRGB);
+		void SetFogRGB (ULONG fRGB);
 
 		//This function does exactly what TranformShape does EXCEPT that the shapeToClip,
 		//Lighting and backface matrices have been calculated in the step above this one.
@@ -801,7 +801,7 @@ class TG_Shape
 		//gos_DrawTriangle.  Does clipping, too!
 		long RenderShadows (long startFace);
 
-		void SetARGBHighLight (DWORD argb)
+		void SetARGBHighLight (ULONG argb)
 		{
 			aRGBHighlight = argb;
 		}
@@ -811,7 +811,7 @@ class TG_Shape
 			lightsOut = lightFlag;
 		}
 		
-		char * getNodeName (void)
+		PSTR  getNodeName (void)
 		{
 			return myType->getNodeId();
 		}
@@ -844,8 +844,8 @@ class TG_VertexPool
 		TG_Vertex 	*tgVertexPool;
 		TG_Vertex 	*nextVertex;
 		
-		DWORD		totalVertices;
-		DWORD		numVertices;
+		ULONG		totalVertices;
+		ULONG		numVertices;
 		
 	public:
 		TG_VertexPool (void)
@@ -866,7 +866,7 @@ class TG_VertexPool
 			totalVertices = numVertices = 0;
 		}
 		
-		void init (DWORD maxVertices)
+		void init (ULONG maxVertices)
 		{
 			tgVertexPool = (TG_VertexPtr)TG_Shape::tglHeap->Malloc(sizeof(TG_Vertex) * maxVertices);
 			gosASSERT(tgVertexPool != NULL);
@@ -883,7 +883,7 @@ class TG_VertexPool
 			numVertices = 0;
 		}
 		
-		TG_VertexPtr getColorsFromPool (DWORD numRequested)
+		TG_VertexPtr getColorsFromPool (ULONG numRequested)
 		{
 			TG_VertexPtr result = NULL;
 			numVertices += numRequested;
@@ -903,8 +903,8 @@ class TG_GOSVertexPool
 		gos_VERTEX 	*gVertexPool;
 		gos_VERTEX 	*nextVertex;
 		
-		DWORD		totalVertices;
-		DWORD		numVertices;
+		ULONG		totalVertices;
+		ULONG		numVertices;
 		
 	public:
 		TG_GOSVertexPool (void)
@@ -925,7 +925,7 @@ class TG_GOSVertexPool
 			totalVertices = numVertices = 0;
 		}
 		
-		void init (DWORD maxVertices)
+		void init (ULONG maxVertices)
 		{
 			gVertexPool = (gos_VERTEX *)TG_Shape::tglHeap->Malloc(sizeof(gos_VERTEX) * maxVertices);
 			gosASSERT(gVertexPool != NULL);
@@ -942,7 +942,7 @@ class TG_GOSVertexPool
 			numVertices = 0;
 		}
 		
-		gos_VERTEX * getVerticesFromPool (DWORD numRequested)
+		gos_VERTEX * getVerticesFromPool (ULONG numRequested)
 		{
 			gos_VERTEX* result = NULL;
 			numVertices += numRequested;
@@ -962,8 +962,8 @@ class TG_TrianglePool
 		TG_Triangle *trianglePool;
 		TG_Triangle	*nextTriangle;
 		
-		DWORD		totalTriangles;
-		DWORD		numTriangles;
+		ULONG		totalTriangles;
+		ULONG		numTriangles;
 		
 	public:
 		TG_TrianglePool (void)
@@ -984,7 +984,7 @@ class TG_TrianglePool
 			totalTriangles = numTriangles = 0;
 		}
 		
-		void init (DWORD maxTriangles)
+		void init (ULONG maxTriangles)
 		{
 			trianglePool = (TG_Triangle *)TG_Shape::tglHeap->Malloc(sizeof(TG_Triangle) * maxTriangles);
 			gosASSERT(trianglePool != NULL);
@@ -1001,7 +1001,7 @@ class TG_TrianglePool
 			numTriangles = 0;
 		}
 		
-		TG_Triangle * getTrianglesFromPool (DWORD numRequested)
+		TG_Triangle * getTrianglesFromPool (ULONG numRequested)
 		{
 			TG_Triangle* result = NULL;
 			numTriangles += numRequested;
@@ -1021,8 +1021,8 @@ class TG_ShadowPool
 		TG_ShadowVertexTemp 	*tVertexPool;
 		TG_ShadowVertexTemp 	*nextVertex;
 		
-		DWORD					totalVertices;
-		DWORD					numVertices;
+		ULONG					totalVertices;
+		ULONG					numVertices;
 		
 	public:
 		TG_ShadowPool (void)
@@ -1043,7 +1043,7 @@ class TG_ShadowPool
 			totalVertices = numVertices = 0;
 		}
 		
-		void init (DWORD maxVertices)
+		void init (ULONG maxVertices)
 		{
 			tVertexPool = (TG_ShadowVertexTempPtr)TG_Shape::tglHeap->Malloc(sizeof(TG_ShadowVertexTemp) * maxVertices);
 			gosASSERT(tVertexPool != NULL);
@@ -1060,7 +1060,7 @@ class TG_ShadowPool
 			numVertices = 0;
 		}
 		
-		TG_ShadowVertexTempPtr getShadowsFromPool (DWORD numRequested)
+		TG_ShadowVertexTempPtr getShadowsFromPool (ULONG numRequested)
 		{
 			TG_ShadowVertexTempPtr result = NULL;
 			numVertices += numRequested;
@@ -1077,11 +1077,11 @@ class TG_ShadowPool
 class TG_DWORDPool
 {
 	protected:
-		DWORD 	*triPool;
-		DWORD	*nextTri;
+		ULONG 	*triPool;
+		ULONG	*nextTri;
 		
-		DWORD	totalTriangles;
-		DWORD	numTriangles;
+		ULONG	totalTriangles;
+		ULONG	numTriangles;
 		
 	public:
 		TG_DWORDPool (void)
@@ -1102,9 +1102,9 @@ class TG_DWORDPool
 			totalTriangles = numTriangles = 0;
 		}
 		
-		void init (DWORD maxTriangles)
+		void init (ULONG maxTriangles)
 		{
-			triPool = (DWORD *)TG_Shape::tglHeap->Malloc(sizeof(DWORD) * maxTriangles);
+			triPool = (ULONG *)TG_Shape::tglHeap->Malloc(sizeof(ULONG) * maxTriangles);
 			gosASSERT(triPool != NULL);
 			
 			nextTri = triPool;
@@ -1119,9 +1119,9 @@ class TG_DWORDPool
 			numTriangles = 0;
 		}
 		
-		DWORD * getFacesFromPool (DWORD numRequested)
+		ULONG * getFacesFromPool (ULONG numRequested)
 		{
-			DWORD* result = NULL;
+			ULONG* result = NULL;
 			numTriangles += numRequested;
 			if (numTriangles < totalTriangles)
 			{


  ================================================
diff --git a/source/mclib/tglpp.cpp b/source/mclib/tglpp.cpp
index c31c6ca..64d6689 100755
--- a/source/mclib/tglpp.cpp
+++ b/source/mclib/tglpp.cpp
@@ -2,6 +2,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+
 #include "tgl.h"
 
 extern bool InEditor;


  ================================================
diff --git a/source/mclib/timing.cpp b/source/mclib/timing.cpp
index 4710fc8..aaea0d6 100755
--- a/source/mclib/timing.cpp
+++ b/source/mclib/timing.cpp
@@ -4,6 +4,10 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
+//#include <windows.h>
+//#include <winbase.h>
+//#include <math.h>
 
 //----------------------------------------------------------------------------------
 // Include Files
@@ -11,10 +15,6 @@
 #include "timing.h"
 #endif
 
-#include <windows.h>
-#include <winbase.h>
-
-#include <math.h>
 
 //----------------------------------------------------------------------------------
 long	turn = 0;


  ================================================
diff --git a/source/mclib/txmmgr.cpp b/source/mclib/txmmgr.cpp
index 1c61900..f3fc85a 100755
--- a/source/mclib/txmmgr.cpp
+++ b/source/mclib/txmmgr.cpp
@@ -11,6 +11,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef TXMMGR_H
 #include "txmmgr.h"
@@ -100,7 +101,8 @@ void MC_TextureManager::start (void)
 	masterTextureNodes = (MC_TextureNode *)systemHeap->Malloc(nodeRAM);
 	gosASSERT(masterTextureNodes != NULL);
 
-	for (long i=0;i<MC_MAXTEXTURES;i++)
+	long i;
+	for (i=0;i<MC_MAXTEXTURES;i++)
 		masterTextureNodes[i].init();
 		
 	//-------------------------------------------
@@ -342,8 +344,9 @@ void MC_TextureManager::removeTextureNode (DWORD textureNode)
 //----------------------------------------------------------------------
 void MC_TextureManager::removeTexture (DWORD gosHandle)
 {
+	long i;
 	//-----------------------------------------------------------
-	for (long i=0;i<MC_MAXTEXTURES;i++)
+	for (i=0;i<MC_MAXTEXTURES;i++)
 	{
 		if ((masterTextureNodes[i].gosTextureHandle == gosHandle))
 		{
@@ -376,10 +379,11 @@ bool MC_TextureManager::flushCache (void)
 	bool cacheNotFull = false;
 	totalCacheMisses++;
 	currentUsedTextures = 0;
+	long i;
 	
 	//Count ACTUAL number of textures being used.
 	// ALSO can't count on turn being right.  Logistics does not update unless simple Camera is up!!
-	for (long i=0;i<MC_MAXTEXTURES;i++)
+	for (i=0;i<MC_MAXTEXTURES;i++)
 	{
 		if ((masterTextureNodes[i].gosTextureHandle != CACHED_OUT_HANDLE) &&
 			(masterTextureNodes[i].gosTextureHandle != 0xffffffff))
@@ -513,7 +517,8 @@ void MC_TextureManager::renderLists (void)
 		gos_SetRenderState( gos_State_Fog, 0);
 	}
 	
-	for (long i=0;i<nextAvailableVertexNode;i++)
+	long i;
+	for (i=0;i<nextAvailableVertexNode;i++)
 	{
 		if ((masterVertexNodes[i].flags & MC2_DRAWSOLID) &&
 			(masterVertexNodes[i].vertices))
@@ -1164,7 +1169,7 @@ DWORD MC_TextureManager::textureInstanceExists (const char *textureFullPathName,
 	{
 		if (masterTextureNodes[i].nodeName)
 		{
-			if (stricmp(masterTextureNodes[i].nodeName,textureFullPathName) == 0)
+			if (_stricmp(masterTextureNodes[i].nodeName,textureFullPathName) == 0)
 			{
 				if (uniqueInstance == masterTextureNodes[i].uniqueInstance)
 				{
@@ -1194,7 +1199,7 @@ DWORD MC_TextureManager::loadTexture (const char *textureFullPathName, gos_Textu
 	// Is this texture already Loaded?
 	for (i=0;i<MC_MAXTEXTURES;i++)
 	{
-		if (masterTextureNodes[i].nodeName && (stricmp(masterTextureNodes[i].nodeName,textureFullPathName) == 0))
+		if (masterTextureNodes[i].nodeName && (_stricmp(masterTextureNodes[i].nodeName,textureFullPathName) == 0))
 		{
 			if (uniqueInstance == masterTextureNodes[i].uniqueInstance)
 			{
@@ -1328,7 +1333,7 @@ long MC_TextureManager::saveTexture (DWORD textureIndex, const char *textureFull
 			//------------------------------------------
 			// Badboys are now LZ Compressed in texture cache.
 			long origSize = LZDecomp(MC_TextureManager::lzBuffer2,(MemoryPtr)masterTextureNodes[textureIndex].textureData,masterTextureNodes[textureIndex].lzCompSize);
-			if (origSize != (masterTextureNodes[textureIndex].width & 0x0fffffff))
+			if (origSize != (long)(masterTextureNodes[textureIndex].width & 0x0fffffff))
 				STOP(("Decompressed to different size from original!  Txm:%s  Width:%d  DecompSize:%d",masterTextureNodes[textureIndex].nodeName,(masterTextureNodes[textureIndex].width & 0x0fffffff),origSize));
 
 			if (origSize >= MAX_LZ_BUFFER_SIZE)
@@ -1392,7 +1397,7 @@ DWORD MC_TextureNode::get_gosTextureHandle (void)	//If texture is not in VidRAM,
 			// Badboys are now LZ Compressed in texture cache.
 			// Uncompress, then memcpy.
 			long origSize = LZDecomp(MC_TextureManager::lzBuffer2,(MemoryPtr)textureData,lzCompSize);
-			if (origSize != (width & 0x0fffffff))
+			if (origSize != (long)(width & 0x0fffffff))
 				STOP(("Decompressed to different size from original!  Txm:%s  Width:%d  DecompSize:%d",nodeName,(width & 0x0fffffff),origSize));
 
 			if (origSize >= MAX_LZ_BUFFER_SIZE)


  ================================================
diff --git a/source/mclib/txmmgr.h b/source/mclib/txmmgr.h
index 87f3734..af275f3 100755
--- a/source/mclib/txmmgr.h
+++ b/source/mclib/txmmgr.h
@@ -499,7 +499,7 @@ class MC_TextureManager
 						}
 						#endif
 
-						memcpy(vertices,data,sizeof(gos_VERTEX) * 3);
+						if(vertices) memcpy(vertices,data,sizeof(gos_VERTEX) * 3);
 						vertices += 3;
 					}
 					
@@ -512,9 +512,11 @@ class MC_TextureManager
 					
 					#if defined( _DEBUG) || defined(_ARMOR)
 					gos_VERTEX * oldVertices = vertices;
-					gos_VERTEX * oldStart = (masterTextureNodes[nodeId].vertexData2->vertices + masterTextureNodes[nodeId].vertexData2->numVertices);
-					#endif
+					gos_VERTEX * oldStart = (masterTextureNodes[nodeId].vertexData2->vertices + 
+						masterTextureNodes[nodeId].vertexData2->numVertices);
+					(void)oldVertices;(void)oldStart;	// 4189
 					gosASSERT(oldVertices < oldStart);
+#endif
 
 					if (!vertices && !masterTextureNodes[nodeId].vertexData2->vertices)
 					{
@@ -548,7 +550,7 @@ class MC_TextureManager
 						}
 						#endif
 						
-						memcpy(vertices,data,sizeof(gos_VERTEX) * 3);
+						if(vertices) memcpy(vertices,data,sizeof(gos_VERTEX) * 3);
 						vertices += 3;
 					}
 					
@@ -562,9 +564,9 @@ class MC_TextureManager
 					#if defined(_DEBUG) || defined(_ARMOR)
 					gos_VERTEX * oldVertices = vertices;
 					gos_VERTEX * oldStart = (masterTextureNodes[nodeId].vertexData3->vertices + masterTextureNodes[nodeId].vertexData3->numVertices);
-					#endif
+					(void)oldVertices;(void)oldStart;	// 4189
 					gosASSERT(oldVertices < oldStart);
-
+#endif
 					if (!vertices && !masterTextureNodes[nodeId].vertexData3->vertices)
 					{
 						masterTextureNodes[nodeId].vertexData3->currentVertex =
@@ -597,7 +599,7 @@ class MC_TextureManager
 						}
 						#endif
 						
-						memcpy(vertices,data,sizeof(gos_VERTEX) * 3);
+						if(vertices) memcpy(vertices,data, sizeof(gos_VERTEX) * 3);
 						vertices += 3;
 					}
 					


  ================================================
diff --git a/source/mclib/userinput.cpp b/source/mclib/userinput.cpp
index a9c5923..64dcb33 100755
--- a/source/mclib/userinput.cpp
+++ b/source/mclib/userinput.cpp
@@ -8,6 +8,9 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
+//#include <windows.h>
+//#include <math.h>
 
 #ifndef USERINPUT_H
 #include "userinput.h"
@@ -37,10 +40,7 @@
 #include "txmmgr.h"
 #endif
 
-#include <windows.h>
-
 #include <stuff\stuff.hpp>
-#include <math.h>
 
 //---------------------------------------------------------------------------
 UserInput *userInput = NULL;


  ================================================
diff --git a/source/mclib/utilities.cpp b/source/mclib/utilities.cpp
index 3df0a5e..17ae54a 100755
--- a/source/mclib/utilities.cpp
+++ b/source/mclib/utilities.cpp
@@ -12,7 +12,7 @@ Utilities.cpp			: Implementation of the Utilities component.
 #include "McLib.h"
 
 
-#pragma warning(disable:4514)
+//#pragma warning(disable:4514)
 
 void drawRect( const GUI_RECT& area, unsigned long color )
 {


  ================================================
diff --git a/source/mclib/vport.cpp b/source/mclib/vport.cpp
index c343296..2c8c35f 100755
--- a/source/mclib/vport.cpp
+++ b/source/mclib/vport.cpp
@@ -5,6 +5,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mclib/weaponfx.cpp b/source/mclib/weaponfx.cpp
index 3a52496..aec89c3 100755
--- a/source/mclib/weaponfx.cpp
+++ b/source/mclib/weaponfx.cpp
@@ -4,6 +4,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/ablmc2.cpp b/source/mechcmd2/ablmc2.cpp
index a29385e..0602985 100755
--- a/source/mechcmd2/ablmc2.cpp
+++ b/source/mechcmd2/ablmc2.cpp
@@ -1,6 +1,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //----------------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/actor.cpp b/source/mechcmd2/actor.cpp
index 59a31bb..412d570 100755
--- a/source/mechcmd2/actor.cpp
+++ b/source/mechcmd2/actor.cpp
@@ -5,6 +5,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Include files


  ================================================
diff --git a/source/mechcmd2/actor.h b/source/mechcmd2/actor.h
index eb6b3f4..17de802 100755
--- a/source/mechcmd2/actor.h
+++ b/source/mechcmd2/actor.h
@@ -22,9 +22,9 @@
 #include "apprtype.h"
 #endif
 
-#ifndef TGATXM_H
-#include "tgatxm.h"
-#endif
+//#ifndef TGATXM_H
+//#include "tgatxm.h"
+//#endif
 
 
 //***********************************************************************


  ================================================
diff --git a/source/mechcmd2/artlry.cpp b/source/mechcmd2/artlry.cpp
index 51a3990..f9e77ae 100755
--- a/source/mechcmd2/artlry.cpp
+++ b/source/mechcmd2/artlry.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/attributemeter.cpp b/source/mechcmd2/attributemeter.cpp
index cb1ba20..1fafbce 100755
--- a/source/mechcmd2/attributemeter.cpp
+++ b/source/mechcmd2/attributemeter.cpp
@@ -4,6 +4,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include "AttributeMeter.h"
 #include "IniFile.h"
@@ -59,6 +60,8 @@ void AttributeMeter::render()
 
 void AttributeMeter::render( long xOffset, long yOffset )
 {
+	int i;
+
 	if ( !bShow )
 		return; 
 
@@ -85,7 +88,7 @@ void AttributeMeter::render( long xOffset, long yOffset )
 	long color = colorMin;
 
 	tmpRect.bottom += skipWidth;
-	for ( int i = 0; i < nBarCount; i++ )
+	for ( i = 0; i < nBarCount; i++ )
 	{
 		drawRect( tmpRect, color );
 		color = interpolateColor( colorMin, colorMax, ((float)i)/(float)numBars );


  ================================================
diff --git a/source/mechcmd2/bldng.cpp b/source/mechcmd2/bldng.cpp
index c765dd9..d5c734b 100755
--- a/source/mechcmd2/bldng.cpp
+++ b/source/mechcmd2/bldng.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_h
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/carnage.cpp b/source/mechcmd2/carnage.cpp
index e776013..4037613 100755
--- a/source/mechcmd2/carnage.cpp
+++ b/source/mechcmd2/carnage.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"
@@ -901,7 +902,7 @@ void Carnage::init (bool create, ObjectTypePtr _type)
 		info.explosion.chunkSize = ((ExplosionType *)_type)->chunkSize;
 		info.explosion.timer = ((ExplosionType *)_type)->delayUntilCollidable; 
 			
-		if (stricmp(weaponEffects->GetEffectName(effectId),"NONE") != 0)
+		if (_stricmp(weaponEffects->GetEffectName(effectId),"NONE") != 0)
 		{
 			//--------------------------------------------------------------
 			// We need to create the GOSFX we need for this explosion here.


  ================================================
diff --git a/source/mechcmd2/chatwindow.cpp b/source/mechcmd2/chatwindow.cpp
index 542e69d..8da9b0f 100755
--- a/source/mechcmd2/chatwindow.cpp
+++ b/source/mechcmd2/chatwindow.cpp
@@ -4,6 +4,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include "ChatWindow.h"
 #include "Mclib.h"


  ================================================
diff --git a/source/mechcmd2/chatwindow.h b/source/mechcmd2/chatwindow.h
index b6454ca..e162f49 100755
--- a/source/mechcmd2/chatwindow.h
+++ b/source/mechcmd2/chatwindow.h
@@ -6,9 +6,9 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
-#ifndef LOGISTICSSCREEN_H
-#include "LogisticsScreen.h"
-#endif
+//#ifndef LOGISTICSSCREEN_H
+//#include "logisticsscreen.h"
+//#endif
 
 //*************************************************************************************************
 


  ================================================
diff --git a/source/mechcmd2/collsn.cpp b/source/mechcmd2/collsn.cpp
index 273c110..6719bbb 100755
--- a/source/mechcmd2/collsn.cpp
+++ b/source/mechcmd2/collsn.cpp
@@ -6,6 +6,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 // Include Files
 #ifndef MCLIB_H


  ================================================
diff --git a/source/mechcmd2/comndr.cpp b/source/mechcmd2/comndr.cpp
index d9b7a3d..719d6ab 100755
--- a/source/mechcmd2/comndr.cpp
+++ b/source/mechcmd2/comndr.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/componentlistbox.cpp b/source/mechcmd2/componentlistbox.cpp
index dd911af..4e7a6f4 100755
--- a/source/mechcmd2/componentlistbox.cpp
+++ b/source/mechcmd2/componentlistbox.cpp
@@ -5,6 +5,7 @@ ComponentListBox.cpp			: Implementation of the ComponentListBox component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "ComponentListBox.h"
 #include "LogisticsVariant.h"
@@ -153,7 +154,7 @@ void ComponentListItem::assignAnimation( FitIniFile& file, int whichChild, char
   		file.readIdString("Animation", tmpAnimName, 31);
 		for ( int i = 0; i < COMP_ANIMATION_COUNT; i++ )
 		{
-			if ( stricmp( animNames[i], tmpAnimName ) == 0 )
+			if ( _stricmp( animNames[i], tmpAnimName ) == 0 )
 			{
 				s_templateItem->pChildAnims[whichChild] = &s_templateItem->animations[i];
 				break;
@@ -489,7 +490,7 @@ void ComponentIconListBox::addSortedItem( ComponentListItem* pItem )
 			return;
 		}
 		else if ( size == tmpSize && 
-			stricmp( pItem->getComponent()->getName(), pTmp->getName() ) < 0 )
+			_stricmp( pItem->getComponent()->getName(), pTmp->getName() ) < 0 )
 		{
 			InsertItem( pItem, i );
 			return;


  ================================================
diff --git a/source/mechcmd2/contact.cpp b/source/mechcmd2/contact.cpp
index 14dff29..956fc53 100755
--- a/source/mechcmd2/contact.cpp
+++ b/source/mechcmd2/contact.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"
@@ -239,11 +240,11 @@ float SensorSystem::getRange (void)
 }
 
 //---------------------------------------------------------------------------
-
-void SensorSystem::setSkill (long newSkill) {
-
-	skill = newSkill;
-}
+// moved to header
+//void SensorSystem::setSkill (long newSkill) {
+//
+//	skill = newSkill;
+//}
 
 //---------------------------------------------------------------------------
 


  ================================================
diff --git a/source/mechcmd2/contact.h b/source/mechcmd2/contact.h
index 3b050e1..ae40276 100755
--- a/source/mechcmd2/contact.h
+++ b/source/mechcmd2/contact.h
@@ -67,7 +67,8 @@ class ContactInfo {
 		}
 
 		void init (void) {
-			for (long i = 0; i < MAX_TEAMS; i++) {
+			long i;
+			for (i = 0; i < MAX_TEAMS; i++) {
 				contactStatus[i] = CONTACT_NONE;
 				//allContactStatus[i] = CONTACT_NONE;
 				contactCount[i] = 0;
@@ -139,7 +140,7 @@ class SensorSystem {
 		long					masterIndex;
 		GameObjectPtr			owner;
 		float					range;
-		long					skill;
+		ULONG					skill;
 		bool					broken;
 		bool					notShutdown;
 		bool					hasLOSCapability;
@@ -195,7 +196,10 @@ class SensorSystem {
 
 		float getEffectiveRange (void);
 
-		void setSkill (long newSkill);
+		void setSkill (ULONG newSkill)
+		{
+			skill = newSkill;
+		}
 
 		long getSkill (void) {
 			return(skill);


  ================================================
diff --git a/source/mechcmd2/controlgui.cpp b/source/mechcmd2/controlgui.cpp
index 96d93fb..9716f32 100755
--- a/source/mechcmd2/controlgui.cpp
+++ b/source/mechcmd2/controlgui.cpp
@@ -4,6 +4,7 @@ controlGui.cpp			: Implementation of the controlGui component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "controlGui.h"
 #include "Team.h"


  ================================================
diff --git a/source/mechcmd2/debugging.cpp b/source/mechcmd2/debugging.cpp
index 06d157f..084f689 100755
--- a/source/mechcmd2/debugging.cpp
+++ b/source/mechcmd2/debugging.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef DEBUGGING_H
 #include "debugging.h"


  ================================================
diff --git a/source/mechcmd2/dw.cpp b/source/mechcmd2/dw.cpp
index a216609..98e9521 100755
--- a/source/mechcmd2/dw.cpp
+++ b/source/mechcmd2/dw.cpp
@@ -1,6 +1,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include <windows.h>
 #include <stdio.h>


  ================================================
diff --git a/source/mechcmd2/fastshp.cpp b/source/mechcmd2/fastshp.cpp
index e0e26b6..4479f3f 100755
--- a/source/mechcmd2/fastshp.cpp
+++ b/source/mechcmd2/fastshp.cpp
@@ -1,6 +1,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef DSTD_H
 #include "dstd.h"


  ================================================
diff --git a/source/mechcmd2/forcegroupbar.cpp b/source/mechcmd2/forcegroupbar.cpp
index 0c8aa3e..ac6e9a7 100755
--- a/source/mechcmd2/forcegroupbar.cpp
+++ b/source/mechcmd2/forcegroupbar.cpp
@@ -5,6 +5,7 @@ ForceGroupBar.cpp			: Implementation of the ForceGroupBar component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "ForceGroupBar.h"
 #include "MechIcon.h"


  ================================================
diff --git a/source/mechcmd2/gamecam.cpp b/source/mechcmd2/gamecam.cpp
index 9e36b55..b23dfaa 100755
--- a/source/mechcmd2/gamecam.cpp
+++ b/source/mechcmd2/gamecam.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/gameobj.cpp b/source/mechcmd2/gameobj.cpp
index b977690..46f3911 100755
--- a/source/mechcmd2/gameobj.cpp
+++ b/source/mechcmd2/gameobj.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/gameobj.h b/source/mechcmd2/gameobj.h
index 8e456c6..a739d88 100755
--- a/source/mechcmd2/gameobj.h
+++ b/source/mechcmd2/gameobj.h
@@ -1,4 +1,3 @@
-
 //---------------------------------------------------------------------------
 //
 //	gameobj.h -- File contains the Basic Game Object definition
@@ -9,6 +8,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#pragma once
+
 #ifndef GAMEOBJ_H
 #define GAMEOBJ_H
 
@@ -378,7 +379,8 @@ class GameObject {
 		virtual void renderShadows (void) {
 		}
 
-		virtual void updateDebugWindow (GameDebugWindow* debugWindow) {
+		virtual void updateDebugWindow (GameDebugWindow* /*debugWindow*/)
+		{
 		}
 
 		virtual AppearancePtr getAppearance (void) {
@@ -442,11 +444,13 @@ class GameObject {
 		
 		virtual void init (bool create, ObjectTypePtr _type);
 
-		virtual long init (FitIniFile* objProfile) {
+		virtual long init (FitIniFile* /*objProfile*/)
+		{
 			return(NO_ERR);
 		}
 
-		bool isMover (void) {
+		bool isMover (void)
+		{
 			return((objectClass == BATTLEMECH) || (objectClass == GROUNDVEHICLE) || (objectClass == ELEMENTAL) || (objectClass == MOVER));
 		}
 
@@ -454,15 +458,19 @@ class GameObject {
 			return((objectClass == BATTLEMECH));
 		}
 
-		virtual long calcHitLocation (GameObjectPtr attacker, long weaponIndex, long attackSource, long attackType) {
+		virtual long calcHitLocation (GameObjectPtr /*attacker*/, long /*weaponIndex*/, long /*attackSource*/, long /*attackType*/)
+		{
 			return(-1);
 		}
 
-		virtual long handleWeaponHit (WeaponShotInfoPtr shotInfo, bool addMultiplayChunk = false) {
+		virtual long handleWeaponHit (WeaponShotInfoPtr /*shotInfo*/, bool addMultiplayChunk = false)
+		{
+			addMultiplayChunk;
 			return(NO_ERR);
 		}
 
-		virtual void setFireHandle (GameObjectHandle handle) {
+		virtual void setFireHandle (GameObjectHandle /*handle*/) 
+		{
 		}
 
 		virtual void killFire (void) {
@@ -482,41 +490,49 @@ class GameObject {
 			return d_vertexNum;
 		}
 		
-		virtual long setTeamId (long _teamId, bool setup) {
+		virtual long setTeamId (long /*_teamId*/, bool /*setup*/)
+		{
 			return(NO_ERR);
 		}
 
-		virtual TeamPtr getTeam (void) {
+		virtual TeamPtr getTeam (void)
+		{
 			return(NULL);
 		}
 
-		virtual long setTeam (TeamPtr _team) {
+		virtual long setTeam (TeamPtr /*_team*/)
+		{
 			return(NO_ERR);
 		}
 
-		virtual bool isFriendly (TeamPtr team) {
+		virtual bool isFriendly (TeamPtr /*team*/)
+		{
 			return(false);
 		}
 
-		virtual bool isEnemy (TeamPtr team) {
+		virtual bool isEnemy (TeamPtr /*team*/)
+		{
 			return(false);
 		}
 
-		virtual bool isNeutral (TeamPtr team) {
+		virtual bool isNeutral (TeamPtr /*team*/)
+		{
 			return(true);
 		}
 
-		virtual Stuff::Vector3D getPosition (void) {
+		virtual Stuff::Vector3D getPosition (void)
+		{
 			return(position);
 		}
 
-		virtual Stuff::Vector3D getLOSPosition (void) {
+		virtual Stuff::Vector3D getLOSPosition (void)
+		{
 			return(position);
 		}
 
 		virtual Stuff::Vector3D relativePosition (float angle, float distance, unsigned long flags);
 		
-		virtual Stuff::Vector3D getPositionFromHS (long weaponType) 
+		virtual Stuff::Vector3D getPositionFromHS (long /*weaponType*/) 
 		{
 			//-----------------------------------------
 			// No hot spots with regular game objects.
@@ -526,27 +542,34 @@ class GameObject {
 		
 		virtual void setPosition (const Stuff::Vector3D& newPosition, bool calcPositions = true);
 		
-		virtual void setTerrainPosition (const Stuff::Vector3D& position, 
-			const Stuff::Vector2DOf<long>& numbers){}
+		virtual void setTerrainPosition (const Stuff::Vector3D& /*position*/, 
+			const Stuff::Vector2DOf<long>& /*numbers*/)
+		{
+		}
 
-		virtual Stuff::Vector3D getVelocity (void) {
+		virtual Stuff::Vector3D getVelocity (void) 
+		{
 			Stuff::Vector3D result;
 			result.Zero();
 			return(result);
 		}
 		
-		virtual Stuff::Vector4D getScreenPos (long whichOne) {
+		virtual Stuff::Vector4D getScreenPos (long /*whichOne*/)
+		{
 			return(screenPos);
 		}
 		
-		virtual void setVelocity (Stuff::Vector3D &newVelocity) {
+		virtual void setVelocity (Stuff::Vector3D& /*newVelocity*/)
+		{
 		}
 
-		virtual float getSpeed (void) {
+		virtual float getSpeed (void)
+		{
 			return(0.0);
 		}
 
-		virtual long getMoveLevel (void) {
+		virtual long getMoveLevel (void)
+		{
 			return(0);
 		}
 
@@ -560,11 +583,11 @@ class GameObject {
 			rotation = rot;
 		}
 
-		virtual void rotate (float angle)
+		virtual void rotate (float /*angle*/)
 		{
 		}
 
-		virtual void rotate (float yaw, float pitch)
+		virtual void rotate (float /*yaw*/, float /*pitch*/)
 		{
 		}
 		
@@ -578,11 +601,13 @@ class GameObject {
 			return(rotationVec);
 		}
 		
-		virtual bool calcAdjacentAreaCell (long moveLevel, long areaID, long& adjRow, long& adjCol) {
+		virtual bool calcAdjacentAreaCell (long /*moveLevel*/, long /*areaID*/, long& /*adjRow*/, long& /*adjCol*/)
+		{
 			return(false);
 		}
 
-		unsigned char getStatus (void) {
+		unsigned char getStatus (void) 
+		{
 			return(status);
 		}
 
@@ -590,63 +615,75 @@ class GameObject {
 		void setStatus (long newStatus, bool forceStatus = false) 
 		{
 			if (((status != OBJECT_STATUS_DESTROYED) && (status != OBJECT_STATUS_DISABLED)) || forceStatus)
-				status = newStatus;
+				status = (UCHAR)newStatus;
 
 			if (newStatus == OBJECT_STATUS_DESTROYED)
-				status = newStatus;
+				status = (UCHAR)newStatus;
 		}
 
-		virtual bool isCrippled (void) {
+		virtual bool isCrippled (void)
+		{
 			return(false);
 		}
 
-		virtual bool isDisabled (void) {
+		virtual bool isDisabled (void)
+		{
 			return((status == OBJECT_STATUS_DISABLED) || (status == OBJECT_STATUS_DESTROYED));
 		}
 
-		virtual bool isDestroyed (void) {
+		virtual bool isDestroyed (void)
+		{
 			return(status == OBJECT_STATUS_DESTROYED);
 		}
 
-		virtual float getDamage (void) {
+		virtual float getDamage (void)
+		{
 			return(0.0);
 		}
 
-		virtual void setDamage (float newDamage) {
+		virtual void setDamage (float /*newDamage*/)
+		{
 		}
 
-		virtual float getDamageLevel (void) {
+		virtual float getDamageLevel (void)
+		{
 			return(0.0);
 		}
 
-		virtual long getContacts (long* contactList, long contactCriteria, long sortType) {
+		virtual long getContacts (long* /*contactList*/, long /*contactCriteria*/, long /*sortType*/)
+		{
 			return(0);
 		}
 
-		bool getTangible (void) {
+		bool getTangible (void)
+		{
 			return((flags & OBJECT_FLAG_TANGIBLE) != 0);
 		}
 		
-		void setTangible (bool set) {
+		void setTangible (bool set)
+		{
 			if (set)
 				flags |= OBJECT_FLAG_TANGIBLE;
 			else
 				flags &= (OBJECT_FLAG_TANGIBLE ^ 0xFFFFFFFF);
 		}
 		
-		virtual void setCommanderId (long _commanderId) {
+		virtual void setCommanderId (long /*_commanderId*/)
+		{
 		}
 
-		virtual MechWarriorPtr getPilot (void) {
+		virtual MechWarriorPtr getPilot (void)
+		{
 			return(NULL);
 		}
 
-		virtual long getCommanderId (void) {
+		virtual long getCommanderId (void)
+		{
 			return(-1);
 		}
 
 
-		virtual long write (FilePtr objFile)
+		virtual long write (FilePtr /*objFile*/)
 		{
 			return NO_ERR;
 		}
@@ -657,7 +694,8 @@ class GameObject {
 
 		virtual long cellDistanceFrom (GameObjectPtr obj);
 
-		virtual void calcLineOfSightNodes (void) {
+		virtual void calcLineOfSightNodes (void)
+		{
 		}
 
 		virtual long getLineOfSightNodes (long eyeCellRow, long eyeCellCol, long* cells);
@@ -675,7 +713,7 @@ class GameObject {
 			return(GameObject::relFacingTo(goal));
 		}
 
-		virtual long openStatusWindow (long x, long y, long w, long h) 
+		virtual long openStatusWindow (long /*x*/, long /*y*/, long /*w*/, long /*h*/) 
 		{
 			return(NO_ERR);
 		}
@@ -714,7 +752,8 @@ class GameObject {
 			return(false);
 		}
 
-		virtual bool isCaptureable (long capturingTeamID) {
+		virtual bool isCaptureable (long /*capturingTeamID*/)
+		{
 			return(false);
 		}
 
@@ -742,7 +781,7 @@ class GameObject {
 			return false;
 		}
 
-		virtual void setPowerSupply (GameObjectPtr power)
+		virtual void setPowerSupply (GameObjectPtr /*power*/)
 		{
 		
 		}
@@ -963,63 +1002,78 @@ class GameObject {
 			collisionFreeFromWID = objWID;
 		}
 
-		virtual GameObjectWatchID getCollisionFreeFromWID (void) {
+		virtual GameObjectWatchID getCollisionFreeFromWID (void)
+		{
 			return(collisionFreeFromWID);
 		}
 
 #ifdef USE_COLLISION
-		virtual GameObjectHandle getCollisionFreeFromObject (void) {
+		virtual GameObjectHandle getCollisionFreeFromObject (void)
+		{
 			return(...);
 		}
 #endif
 
-		virtual void setCollisionFreeTime (float time) {
+		virtual void setCollisionFreeTime (float time)
+		{
 			collisionFreeTime = time;
 		}
 
-		virtual float getCollisionFreeTime (void) {
+		virtual float getCollisionFreeTime (void)
+		{
 			return(collisionFreeTime);
 		}
 
-		virtual void damageObject (float dmgAmount) {
+		virtual void damageObject (float /*dmgAmount*/)
+		{
 			//damage += dmgAmount;
 		}
 		
-		virtual void setExplDmg (float newDmg) {
+		virtual void setExplDmg (float newDmg)
+		{
 			explDamage = newDmg;
 		}
 		
-		virtual void setExplRad (float newRad) {
+		virtual void setExplRad (float newRad)
+		{
 			explRadius = newRad;
 		}
 		
-		virtual float getExplDmg (void) {
+		virtual float getExplDmg (void) 
+		{
 			return(explDamage);
 		}
 
-		virtual void setSensorRange (float range) {
+		virtual void setSensorRange (float /*range*/)
+		{
 		}
 
-		virtual bool hasActiveProbe (void) {
+		virtual bool hasActiveProbe (void)
+		{
 			return(false);
 		}
 
-		virtual float getEcmRange (void) {
+		virtual float getEcmRange (void)
+		{
 			return(0.0);
 		}
 
-		virtual bool hasNullSignature (void) {
+		virtual bool hasNullSignature (void)
+		{
 			return(false);
 		}
 
-		virtual void setSalvage (SalvageItemPtr newSalvage) {
+		virtual void setSalvage (SalvageItemPtr /*newSalvage*/)
+		{
 		}
 				
-		virtual SalvageItemPtr getSalvage (void) {
+		virtual SalvageItemPtr getSalvage (void)
+		{
 			return(NULL);
 		}
 		
-		virtual long getWindowsVisible (void) {
+		virtual long getWindowsVisible (void)
+		{
 			return(windowsVisible);
 		}
 		
@@ -1027,23 +1081,28 @@ class GameObject {
 
 		virtual long kill (void);
 
-		virtual bool isMarine(void) {
+		virtual bool isMarine(void)
+		{
 			return(false);
 		}
 
-		virtual float getRefitPoints(void) {
+		virtual float getRefitPoints(void)
+		{
 			return(0.0);
 		}
 
-		virtual bool burnRefitPoints(float pointsToBurn) {
+		virtual bool burnRefitPoints(float /*pointsToBurn*/)
+		{
 			return(false);
 		}
 
-		virtual float getRecoverPoints(void) {
+		virtual float getRecoverPoints(void)
+		{
 			return(0.0);
 		}
 
-		virtual bool burnRecoverPoints(float pointsToBurn) {
+		virtual bool burnRecoverPoints(float /*pointsToBurn*/)
+		{
 			return(false);
 		}
 
@@ -1055,8 +1114,9 @@ class GameObject {
 			return(maxCV);
 		}
 		
-		virtual void setCurCV (long newCV) {
-			curCV = newCV;
+		virtual void setCurCV (long newCV)
+		{
+			curCV = (short)newCV;
 		}
 
 		virtual long getThreatRating (void) {
@@ -1113,7 +1173,7 @@ class GameObject {
 			return NULL;
 		}
 
-		virtual void setParentId (DWORD pId)
+		virtual void setParentId (DWORD /*pId*/)
 		{
 			//Do Nothing.  Most of the time, this is OK!
 		}
@@ -1131,7 +1191,7 @@ class GameObject {
 			return false;
 		}
 		
-		virtual void setOnGUI (bool onGui)
+		virtual void setOnGUI (bool /*onGui*/)
 		{
 		}
 		


  ================================================
diff --git a/source/mechcmd2/gamesound.cpp b/source/mechcmd2/gamesound.cpp
index 5ac62dc..882bd37 100755
--- a/source/mechcmd2/gamesound.cpp
+++ b/source/mechcmd2/gamesound.cpp
@@ -6,6 +6,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Include files
@@ -47,7 +48,8 @@ void GameSoundSystem::purgeSoundSystem (void)
 	// dump the Radio Message Queue.
 	messagesInQueue = 0;
 	wholeMsgDone = true;
-	for (long i=0;i<MAX_QUEUED_MESSAGES;i++)
+	long i;
+	for (i=0;i<MAX_QUEUED_MESSAGES;i++)
 		queue[i] = NULL;
 
 	generalAlarmTimer = 0.0f;


  ================================================
diff --git a/source/mechcmd2/gametacmap.cpp b/source/mechcmd2/gametacmap.cpp
index fce109a..304e439 100755
--- a/source/mechcmd2/gametacmap.cpp
+++ b/source/mechcmd2/gametacmap.cpp
@@ -4,6 +4,7 @@ gameTacMap.cpp			: Implementation of the gameTacMap component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "gameTacMap.h"
 #include "team.h"


  ================================================
diff --git a/source/mechcmd2/gate.cpp b/source/mechcmd2/gate.cpp
index bc50bab..314e53f 100755
--- a/source/mechcmd2/gate.cpp
+++ b/source/mechcmd2/gate.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/goal.cpp b/source/mechcmd2/goal.cpp
index 03dfc8c..9c5b08e 100755
--- a/source/mechcmd2/goal.cpp
+++ b/source/mechcmd2/goal.cpp
@@ -1,6 +1,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef GOAL_H
 #include "goal.h"


  ================================================
diff --git a/source/mechcmd2/group.cpp b/source/mechcmd2/group.cpp
index 561f3a4..f83ca2c 100755
--- a/source/mechcmd2/group.cpp
+++ b/source/mechcmd2/group.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/gvehicl.cpp b/source/mechcmd2/gvehicl.cpp
index d587a3c..5d35520 100755
--- a/source/mechcmd2/gvehicl.cpp
+++ b/source/mechcmd2/gvehicl.cpp
@@ -4,6 +4,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/infowindow.cpp b/source/mechcmd2/infowindow.cpp
index a4eaaa9..5afd60e 100755
--- a/source/mechcmd2/infowindow.cpp
+++ b/source/mechcmd2/infowindow.cpp
@@ -5,6 +5,7 @@ InfoWindow.cpp			: Implementation of the InfoWindow component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "InfoWindow.h"
 #include "MCLib.h"


  ================================================
diff --git a/source/mechcmd2/keyboardref.cpp b/source/mechcmd2/keyboardref.cpp
index dde93fe..8442df4 100755
--- a/source/mechcmd2/keyboardref.cpp
+++ b/source/mechcmd2/keyboardref.cpp
@@ -5,6 +5,7 @@ KeyboardRef.cpp			: Implementation of the KeyboardRef component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "KeyboardRef.h"
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/light.cpp b/source/mechcmd2/light.cpp
index 4a0044f..002ae27 100755
--- a/source/mechcmd2/light.cpp
+++ b/source/mechcmd2/light.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/loadscreen.cpp b/source/mechcmd2/loadscreen.cpp
index 25ba93b..f57b789 100755
--- a/source/mechcmd2/loadscreen.cpp
+++ b/source/mechcmd2/loadscreen.cpp
@@ -5,6 +5,7 @@ LoadScreen.cpp			: Implementation of the LoadScreen component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include <windows.h>
 #include <ddraw.h>


  ================================================
diff --git a/source/mechcmd2/logistics.cpp b/source/mechcmd2/logistics.cpp
index 7c57f88..95678da 100755
--- a/source/mechcmd2/logistics.cpp
+++ b/source/mechcmd2/logistics.cpp
@@ -6,6 +6,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //----------------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/logisticscomponent.cpp b/source/mechcmd2/logisticscomponent.cpp
index 75ae57e..3fc1242 100755
--- a/source/mechcmd2/logisticscomponent.cpp
+++ b/source/mechcmd2/logisticscomponent.cpp
@@ -5,6 +5,7 @@ LogisticsComponent.cpp			: Implementation of the LogisticsComponent component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "LogisticsComponent.h"
 #include <gameos.hpp>
@@ -87,9 +88,10 @@ int LogisticsComponent::init( char* dataLine )
 
 	// the type
 	extractString( pLine, pBuffer, 1024 );
-	for ( int i = 0; i < NUM_COMPONENT_FORMS; ++i )
+	int i;
+	for ( i = 0; i < NUM_COMPONENT_FORMS; ++i )
 	{
-		if ( 0 == stricmp( ComponentFormString[i], pBuffer ) )
+		if ( 0 == _stricmp( ComponentFormString[i], pBuffer ) )
 		{
 			Type = i;
 			break;
@@ -128,17 +130,17 @@ int LogisticsComponent::init( char* dataLine )
 
 	// we need to figure out where things can go
 	extractString( pLine, pBuffer, 1024 );
-	bHead = stricmp( pBuffer, "Yes" ) ? false : true;
+	bHead = _stricmp( pBuffer, "Yes" ) ? false : true;
 	
 	extractString( pLine, pBuffer, 1024 );
-	bTorso = stricmp( pBuffer, "Yes" ) ? false : true;
+	bTorso = _stricmp( pBuffer, "Yes" ) ? false : true;
 	
 	// ignore the next 4 columns
 	for ( i = 0; i < 4; ++i )
 		extractString( pLine, pBuffer, 1024 );
 	
 	extractString( pLine, pBuffer, 1024 );
-	bLegs = stricmp( pBuffer, "Yes" ) ? false : true;
+	bLegs = _stricmp( pBuffer, "Yes" ) ? false : true;
 	
 	// ignore the next 4 columns
 	for ( i = 0; i < 4; ++i )
@@ -181,7 +183,8 @@ int LogisticsComponent::extractString( char*& pFileLine, char* pBuffer, int buff
 {
 	*pBuffer = 0;
 
-	for ( int i = 0; i < 512; ++i )
+	int i;
+	for ( i = 0; i < 512; ++i )
 	{
 		if ( pFileLine[i] == '\n' )
 			break;
@@ -246,7 +249,7 @@ bool LogisticsComponent::compare( LogisticsComponent* second, int type )
 			return second->heat > heat;
 			break;
 		case NAME:
-			return stricmp( name, second->name ) > 0;
+			return _stricmp( name, second->name ) > 0;
 			break;
 		case RANGE:
 			return second->damage > damage;


  ================================================
diff --git a/source/mechcmd2/logisticsdata.cpp b/source/mechcmd2/logisticsdata.cpp
index efe8abd..0a7d687 100755
--- a/source/mechcmd2/logisticsdata.cpp
+++ b/source/mechcmd2/logisticsdata.cpp
@@ -5,6 +5,7 @@ LogisticsData.cpp			: Implementation of the LogisticsData component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "LogisticsData.h"
 #include "file.h"
@@ -260,7 +261,7 @@ void LogisticsData::initVariants()
 		if ( retVal != 0 )
 			break;
 
-		if ( stricmp( tmpStr, "VEHICLE" ) == 0 )
+		if ( _stricmp( tmpStr, "VEHICLE" ) == 0 )
 		{
 			float scale;
 			variantFile.readFloat( i, 11, scale );
@@ -272,7 +273,7 @@ void LogisticsData::initVariants()
 			i++;
 			continue;
 		}
-		if ( stricmp( tmpStr, "MECH" ) != 0 )
+		if ( _stricmp( tmpStr, "MECH" ) != 0 )
 		{
 		
 			float scale;
@@ -514,11 +515,12 @@ int LogisticsData::removeVariant( const char* varName )
 		return -1;
 
 	LogisticsVariant* pVar = 0;
+	VARIANT_LIST::EIterator vIter;
 
 	if ( currentlyModifiedMech->getName() == varName || oldVariant->getName() == varName )
 		return -1;
 
-	for ( VARIANT_LIST::EIterator vIter = variants.Begin(); !vIter.IsDone(); vIter++ )
+	for ( vIter = variants.Begin(); !vIter.IsDone(); vIter++ )
 	{
 		if ( (*vIter)->getName().Compare( varName, 0 ) == 0 )
 		{
@@ -567,7 +569,7 @@ LogisticsVariant* LogisticsData::getVariant( int ID )
 {
 	for ( VARIANT_LIST::EIterator iter = variants.Begin(); !iter.IsDone(); iter++ )
 	{
-		if ( (*iter)->getID() == (ID & 0x00ffffff) )
+		if ( (*iter)->getID() == (unsigned long)(ID & 0x00ffffff) )
 		{
 			return *iter;
 		}
@@ -923,8 +925,9 @@ const char*	LogisticsData::getBestPilot( long mechWeight )
 #endif
 
 	long count = counter;
+	int i;
 
-	for ( int i = 1; i < count; ++i )
+	for ( i = 1; i < count; ++i )
 	{
 		LogisticsPilot* cur = pPilots[i];
 		for ( int j = 0; j < i; ++j )
@@ -1148,7 +1151,8 @@ long	LogisticsData::load( FitIniFile& file )
 	char tmp[64];
 
 	// load variants
-	for ( int i = 0; i < variantCount; i++ )
+	int i;
+	for ( i = 0; i < variantCount; i++ )
 	{
 		sprintf( tmp, "Variant%ld", i );
 		file.seekBlock( tmp );
@@ -1440,7 +1444,8 @@ void LogisticsData::removeMechFromInventory( const char* mechName, const char* p
 LogisticsPilot*	LogisticsData::getPilot( const char* pilotName )
 {
 	// look for available ones first
-	for( PILOT_LIST::EIterator iter = pilots.Begin(); !iter.IsDone(); iter++ )
+	PILOT_LIST::EIterator iter;
+	for( iter = pilots.Begin(); !iter.IsDone(); iter++ )
 	{
 		if ( (*iter).isAvailable() )
 		{
@@ -1489,7 +1494,8 @@ long LogisticsData::updateAvailability()
 	int newMechAvailableCount = 0;
 	int oldPilotAvailableCount = 0;
 	int newPilotAvailableCount= 0;
-	for ( PILOT_LIST::EIterator pIter = pilots.Begin(); !pIter.IsDone(); pIter++ )
+	PILOT_LIST::EIterator pIter;
+	for ( pIter = pilots.Begin(); !pIter.IsDone(); pIter++ )
 	{
 		if ( (*pIter).bAvailable )
 			oldPilotAvailableCount++;
@@ -1522,7 +1528,8 @@ long LogisticsData::updateAvailability()
 
 	bool bAll = 0;
 	file.readIdBoolean( "AllComponents", bAll );
-	for ( int i = 0; i < 255; i++ )
+	int i;
+	for ( i = 0; i < 255; i++ )
 	{
 		if ( bAll )
 			available[i] = 1;
@@ -1539,7 +1546,8 @@ long LogisticsData::updateAvailability()
 	}
 
 	// go through comonent list, and set 'em
-	for ( COMPONENT_LIST::EIterator cIter = components.Begin(); !cIter.IsDone(); cIter++ )
+	COMPONENT_LIST::EIterator cIter;
+	for ( cIter = components.Begin(); !cIter.IsDone(); cIter++ )
 	{
 		if ( available[(*cIter).getID()] || bAll )
 		{
@@ -1555,7 +1563,8 @@ long LogisticsData::updateAvailability()
 
 
 	// reset all variants to unavailable
-	for ( VARIANT_LIST::EIterator vIter = variants.Begin(); !vIter.IsDone(); vIter++ )
+	VARIANT_LIST::EIterator vIter;
+	for ( vIter = variants.Begin(); !vIter.IsDone(); vIter++ )
 	{
 		if ( (*vIter)->isAvailable()  && !((*vIter)->getID() >> 16 ))
 			oldMechAvailableCount++;
@@ -1596,7 +1605,7 @@ long LogisticsData::updateAvailability()
 			EString mechName = (*vIter)->getFileName();
 			char realName[1024];
 			_splitpath( mechName, NULL, NULL, realName, NULL );
-			if ( stricmp( realName, chassisFileName ) == 0 )
+			if ( _stricmp( realName, chassisFileName ) == 0 )
 			{
 				componentCount = 255;
 				bool bRight = true;
@@ -1705,7 +1714,8 @@ void LogisticsData::appendAvailability(const char* pFileName, bool* availableArr
 	char pilotName[255];
 	char tmp[256];
 	file.seekBlock( "Pilots" );
-	for ( int i = 0; i < 255; i++ )
+	int i;
+	for ( i = 0; i < 255; i++ )
 	{
 		sprintf( tmp, "Pilot%ld", i );
 		if ( NO_ERR != file.readIdString( tmp, pilotName, 254 ) )
@@ -1738,7 +1748,7 @@ void LogisticsData::appendAvailability(const char* pFileName, bool* availableArr
 			EString mechName = (*vIter)->getFileName();
 			char realName[255];
 			_splitpath( mechName, NULL, NULL, realName, NULL );
-			if ( stricmp( realName, chassisFileName ) == 0 )
+			if ( _stricmp( realName, chassisFileName ) == 0 )
 			{
 				long componentCount = 255;
 				long componentArray[256];
@@ -2075,11 +2085,11 @@ int LogisticsData::acceptMechModifications( const char* name )
 	// Doing it by count does not crash and has the added advantage of being easy to debug!
 	// I suspect ESI going south again.  Probably a compiler option...
 
-	// 05/04 HKG, actually, if you increment vIter after deleteing it, it still won't work
+	// 05/04 HKG, actually, if you increment vIter after deleting it, it still won't work
 
 	// Good Point.  As you can see, it was pretty late when I "fixed" this!
-	long numVariants = variants.Count();
-	long i=0;
+	//long numVariants = variants.Count();
+	//long i=0;
 	for ( VARIANT_LIST::EIterator vIter = variants.Begin(); !vIter.IsDone();  )
 	{
 		if ( (*vIter)->getName().Compare( name, 0 ) == 0 )
@@ -2476,7 +2486,7 @@ LogisticsVehicle*	LogisticsData::getVehicle( const char* pName )
 	for ( VEHICLE_LIST::EIterator vIter = vehicles.Begin(); !vIter.IsDone(); vIter++ )
 	{
 		cLoadString( (*vIter)->getNameID(), tmpStr, 255 );
-		if ( stricmp( tmpStr, pName ) == 0 )
+		if ( _stricmp( tmpStr, pName ) == 0 )
 		{
 			return *vIter;
 		}


  ================================================
diff --git a/source/mechcmd2/logisticsdialog.cpp b/source/mechcmd2/logisticsdialog.cpp
index 90589d1..2b337b8 100755
--- a/source/mechcmd2/logisticsdialog.cpp
+++ b/source/mechcmd2/logisticsdialog.cpp
@@ -5,6 +5,7 @@ LogisticsDialog.cpp			: Implementation of the LogisticsDialog component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "LogisticsDialog.h"
 #include "aButton.h"
@@ -1256,7 +1257,7 @@ void LogisticsVariantDialog::initTranscript()
 	{
 		do
 		{
-			if ((findResult.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 && stricmp( findResult.cFileName, "transcript.txt" ) != 0 )
+			if ((findResult.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 && _stricmp( findResult.cFileName, "transcript.txt" ) != 0 )
 			{
 				aAnimTextListItem* pEntry = new aAnimTextListItem(IDS_DIALOG_LIST_FONT);
 				*pEntry = s_instance->templateItem;


  ================================================
diff --git a/source/mechcmd2/logisticsmech.cpp b/source/mechcmd2/logisticsmech.cpp
index 7cb4e76..7307f61 100755
--- a/source/mechcmd2/logisticsmech.cpp
+++ b/source/mechcmd2/logisticsmech.cpp
@@ -5,6 +5,7 @@ LogisticsMech.cpp			: Implementation of the LogisticsMech component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "LogisticsMech.h"
 #include "LogisticsData.h"


  ================================================
diff --git a/source/mechcmd2/logisticsmechdisplay.cpp b/source/mechcmd2/logisticsmechdisplay.cpp
index 9c65c2f..0e17ee0 100755
--- a/source/mechcmd2/logisticsmechdisplay.cpp
+++ b/source/mechcmd2/logisticsmechdisplay.cpp
@@ -5,6 +5,7 @@ LogisticsMechDisplay.cpp			: Implementation of the LogisticsMechDisplay componen
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "LogisticsMechDisplay.h"
 #include "LogisticsMech.h"


  ================================================
diff --git a/source/mechcmd2/logisticsmechicon.cpp b/source/mechcmd2/logisticsmechicon.cpp
index a510783..18d4215 100755
--- a/source/mechcmd2/logisticsmechicon.cpp
+++ b/source/mechcmd2/logisticsmechicon.cpp
@@ -4,6 +4,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include "LogisticsMechIcon.h"
 #include "MechIcon.h"


  ================================================
diff --git a/source/mechcmd2/logisticsmissioninfo.cpp b/source/mechcmd2/logisticsmissioninfo.cpp
index 2a67504..0139563 100755
--- a/source/mechcmd2/logisticsmissioninfo.cpp
+++ b/source/mechcmd2/logisticsmissioninfo.cpp
@@ -5,6 +5,8 @@ LogisticsMissionInfo.cpp			: Implementation of the LogisticsMissionInfo componen
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
+
 #include "McLib.h"
 
 #include "LogisticsMissionInfo.h"
@@ -389,7 +391,8 @@ long LogisticsMissionInfo::load( FitIniFile& file )
 
 	long numberCompleted = 0;
 
-	for ( int i = 0; i < count; i++ )
+	int i;
+	for ( i = 0; i < count; i++ )
 	{
 		long cnt = 0;
 		sprintf( header, "Mission%ld", i );
@@ -651,7 +654,7 @@ long LogisticsMissionInfo::setNextMission( const char* missionName )
 		MISSION_LIST::EIterator iter = pGroup->infos.Begin();
 		while( !iter.IsDone() )
 		{
-			if ( stricmp( (*iter)->fileName, missionName ) == 0 )
+			if ( _stricmp( (*iter)->fileName, missionName ) == 0 )
 			{
 				bFound = 1;
 			


  ================================================
diff --git a/source/mechcmd2/logisticspilot.cpp b/source/mechcmd2/logisticspilot.cpp
index 2d00653..57f19d2 100755
--- a/source/mechcmd2/logisticspilot.cpp
+++ b/source/mechcmd2/logisticspilot.cpp
@@ -5,6 +5,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include "McLib.h"
 #include "LogisticsPilot.h"
@@ -185,7 +186,8 @@ long LogisticsPilot::save( FitIniFile& file, long which )
 	file.writeIdBoolean( "Dead", bDead );
 
 	char buffer[64];
-	for ( int i = 0; i < MAX_MEDAL; i++ )
+	int i;
+	for ( i = 0; i < MAX_MEDAL; i++ )
 	{
 		sprintf( buffer, "Medal%ld", i );
 		file.writeIdBoolean( buffer, medals[i] );
@@ -222,7 +224,8 @@ long LogisticsPilot::load( FitIniFile& file )
 	file.readIdBoolean( "Dead", bDead );
 
 	char buffer[64];
-	for ( int i = 0; i < MAX_MEDAL; i++ )
+	int i;
+	for ( i = 0; i < MAX_MEDAL; i++ )
 	{
 		sprintf( buffer, "Medal%ld", i );
 		file.readIdBoolean( buffer, medals[i] );


  ================================================
diff --git a/source/mechcmd2/logisticspilotlistbox.cpp b/source/mechcmd2/logisticspilotlistbox.cpp
index c472524..0ba2c46 100755
--- a/source/mechcmd2/logisticspilotlistbox.cpp
+++ b/source/mechcmd2/logisticspilotlistbox.cpp
@@ -5,6 +5,7 @@ LogisticsPilotListBox.cpp			: Implementation of the LogisticsPilotListBox compon
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "LogisticsPilotListBox.h"
 #include "LogisticsPilot.h"


  ================================================
diff --git a/source/mechcmd2/logisticsvariant.cpp b/source/mechcmd2/logisticsvariant.cpp
index de7631e..6f6bcb7 100755
--- a/source/mechcmd2/logisticsvariant.cpp
+++ b/source/mechcmd2/logisticsvariant.cpp
@@ -5,6 +5,7 @@ LogisticsVariant.cpp			: Implementation of the LogisticsVariant component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "LogisticsVariant.h"
 #include "mclib.h"
@@ -347,8 +348,8 @@ int LogisticsVariant::init( CSVFile* file, LogisticsChassis* pChassis, int Varia
 	long yLocs[128];
 	memset( pComps, 0, sizeof( LogisticsComponent* ) * 128 );
 	long componentCount = 0;
-	
-	for ( int i =26; i < 97; i++ )
+	int i, j, k;
+	for ( i =26; i < 97; i++ )
 	{
 		long componentID;
 		if ( NO_ERR == file->readLong( offset + i, 5, componentID ) && componentID != 0xff )
@@ -363,9 +364,9 @@ int LogisticsVariant::init( CSVFile* file, LogisticsChassis* pChassis, int Varia
 		}
 	}
 
-	for ( int j = 4; j > 0; j-- )
+	for ( j = 4; j > 0; j-- )
 	{
-		for ( int k = 3; k >0; k-- )
+		for ( k = 3; k >0; k-- )
 		{
 			for ( i = 0; i < componentCount; i++ )
 			{
@@ -387,10 +388,7 @@ int LogisticsVariant::init( CSVFile* file, LogisticsChassis* pChassis, int Varia
 
 	}
 
-	
 	return 0;
-
-
 }
 
 bool LogisticsVariant::addComponent( int idFromFitFile, long& x, long& y )
@@ -947,7 +945,8 @@ int			LogisticsVariant::getOptimalRangeString( long& color ) const
 
 	float maxDamage = -1.f;
 
-	for ( int i = 0; i < componentCount; i++ )
+	int i;
+	for ( i = 0; i < componentCount; i++ )
 	{
 		if ( components[i].component->isWeapon() )
 		{
@@ -980,7 +979,7 @@ bool		LogisticsVariant::allComponentsAvailable() const
 {
 
 	// 06/05/01 hack, we wan't to hide this atlas for the whole game.
-	if ( stricmp( "Renard's Atlas", variantName ) == 0 )
+	if ( _stricmp( "Renard's Atlas", variantName ) == 0 )
 		return 0;
 
 	for ( int i = 0; i < componentCount; i++ )
@@ -996,7 +995,7 @@ bool		LogisticsVariant::allComponentsAvailable() const
 void		LogisticsVariant::setAvailable( bool available ) 
 { 
 	// 06/05/01 hack, we wan't to hide this atlas for the whole game.
-	if ( stricmp( "Renard's Atlas", variantName ) == 0 )
+	if ( _stricmp( "Renard's Atlas", variantName ) == 0 )
 		availableToUser = 0;
 
 	else
@@ -1039,7 +1038,8 @@ void LogisticsVehicle::init( FitIniFile& file )
 	baseArmor = 0;
 
 	unsigned char pts;
-	for ( int i = 0; i < 5; i++ )
+	int i;
+	for ( i = 0; i < 5; i++ )
 	{
 		file.seekBlock( parts[i] );
 		file.readIdUChar( "MaxArmorPoints", pts );


  ================================================
diff --git a/source/mechcmd2/logisticsvariant.h b/source/mechcmd2/logisticsvariant.h
index 8deb00b..24802cf 100755
--- a/source/mechcmd2/logisticsvariant.h
+++ b/source/mechcmd2/logisticsvariant.h
@@ -16,7 +16,7 @@ class FitIniFile;
 
 #include "EString.h"
 
-#pragma warning (disable:4514)
+//#pragma warning (disable:4514)
 
 
 enum LOGISTICS_COMPONENT_LOCATION


  ================================================
diff --git a/source/mechcmd2/logmain.cpp b/source/mechcmd2/logmain.cpp
index 95e5159..9d54495 100755
--- a/source/mechcmd2/logmain.cpp
+++ b/source/mechcmd2/logmain.cpp
@@ -5,6 +5,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //-----------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/mainmenu.cpp b/source/mechcmd2/mainmenu.cpp
index ed84ace..de97534 100755
--- a/source/mechcmd2/mainmenu.cpp
+++ b/source/mechcmd2/mainmenu.cpp
@@ -5,6 +5,7 @@ MainMenu.cpp			: Implementation of the MainMenu component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include <windows.h>
 #include <ddraw.h>
@@ -506,7 +507,7 @@ void MainMenu::update()
 			strcpy( name, savePath );
 			strcat( name, LogisticsSaveDialog::instance()->getFileName() );
 			int index = strlen( name ) - 4;
-			if ( stricmp( &name[index], ".fit" ) !=0 ) 
+			if ( _stricmp( &name[index], ".fit" ) !=0 ) 
 				strcat( name, ".fit" );
 
 			


  ================================================
diff --git a/source/mechcmd2/mc2movie.cpp b/source/mechcmd2/mc2movie.cpp
index 7829238..f21e63d 100755
--- a/source/mechcmd2/mc2movie.cpp
+++ b/source/mechcmd2/mc2movie.cpp
@@ -1,6 +1,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MC2MOVIE_H
 #include "mc2movie.h"


  ================================================
diff --git a/source/mechcmd2/mech.cpp b/source/mechcmd2/mech.cpp
index 5da1cff..ebf619b 100755
--- a/source/mechcmd2/mech.cpp
+++ b/source/mechcmd2/mech.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/mechbayscreen.cpp b/source/mechcmd2/mechbayscreen.cpp
index 5e8ddb9..5c58d9b 100755
--- a/source/mechcmd2/mechbayscreen.cpp
+++ b/source/mechcmd2/mechbayscreen.cpp
@@ -4,6 +4,7 @@ MechBayScreen.cpp			: Implementation of the MechBayScreen component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MechBayScreen.h"
 #include "LogisticsMech.h"


  ================================================
diff --git a/source/mechcmd2/mechcmd2.cpp b/source/mechcmd2/mechcmd2.cpp
index f310304..500578f 100755
--- a/source/mechcmd2/mechcmd2.cpp
+++ b/source/mechcmd2/mechcmd2.cpp
@@ -5,6 +5,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //-----------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/mechicon.cpp b/source/mechcmd2/mechicon.cpp
index 40fe5b1..518f74d 100755
--- a/source/mechcmd2/mechicon.cpp
+++ b/source/mechcmd2/mechicon.cpp
@@ -5,6 +5,7 @@ MechIcon.cpp			: Implementation of the MechIcon component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MechIcon.h"
 #include "Mover.h"


  ================================================
diff --git a/source/mechcmd2/mechicon.h b/source/mechcmd2/mechicon.h
index 9d83246..a2cf6fb 100755
--- a/source/mechcmd2/mechicon.h
+++ b/source/mechcmd2/mechicon.h
@@ -132,7 +132,7 @@ protected:
 
 
 		friend class ForceGroupBar;
-		friend void TerminateGameEngine(void);
+		friend void __stdcall TerminateGameEngine(void);
 
 		bool	bDrawBack;
 


  ================================================
diff --git a/source/mechcmd2/mechlabscreen.cpp b/source/mechcmd2/mechlabscreen.cpp
index 8796d78..23b02a3 100755
--- a/source/mechcmd2/mechlabscreen.cpp
+++ b/source/mechcmd2/mechlabscreen.cpp
@@ -5,6 +5,7 @@ MechLabScreen.cpp			: Implementation of the MechLabScreen component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MechLabScreen.h"
 #include "IniFile.h"


  ================================================
diff --git a/source/mechcmd2/mechlistbox.cpp b/source/mechcmd2/mechlistbox.cpp
index 6f25f98..80c050a 100755
--- a/source/mechcmd2/mechlistbox.cpp
+++ b/source/mechcmd2/mechlistbox.cpp
@@ -5,6 +5,7 @@ MechListBox.cpp			: Implementation of the MechListBox component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MechListBox.h"
 #include "LogisticsMech.h"


  ================================================
diff --git a/source/mechcmd2/mechlopedia.cpp b/source/mechcmd2/mechlopedia.cpp
index 5086540..29cc365 100755
--- a/source/mechcmd2/mechlopedia.cpp
+++ b/source/mechcmd2/mechlopedia.cpp
@@ -5,6 +5,7 @@ Mechlopedia.cpp			: Implementation of the Mechlopedia component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "Mechlopedia.h"
 #include "iniFile.h"
@@ -275,6 +276,7 @@ void Mechlopedia::MechScreen::init()
 void Mechlopedia::MechScreen::begin()
 {
 	// need to fill that list box
+	int i, j;
 	if ( bIsVehicle )
 	{
 		textObjects[1].setText( IDS_VEHICLE_STATS );
@@ -286,10 +288,10 @@ void Mechlopedia::MechScreen::begin()
 		int copterCount = 256;
 		LogisticsData::instance->getHelicopters( pCopters, copterCount );
 
-		for ( int i = 1; i < count; ++i )
+		for ( i = 1; i < count; ++i )
 		{
 			const LogisticsVehicle* cur = pVehicles[i];
-			for ( int j = 0; j < i; ++j )
+			for ( j = 0; j < i; ++j )
 			{
 				if ( cur->getNameID() == pVehicles[j]->getNameID() && j != i )
 				{
@@ -300,10 +302,6 @@ void Mechlopedia::MechScreen::begin()
 			}
 		}
 
-		
-
-		
-
 		groupListBox->removeAllItems( true );
 		for ( i = 0; i < count; i++ )
 		{
@@ -316,10 +314,10 @@ void Mechlopedia::MechScreen::begin()
 			pEntry->resize( groupListBox->width() - groupListBox->getScrollBarWidth() - 18, pEntry->height() );
 			bool bFound = 0;
 
-			for ( int j = 0; j < groupListBox->GetItemCount(); j++ )
+			for ( j = 0; j < groupListBox->GetItemCount(); j++ )
 			{
 				aTextListItem* pItem = (aTextListItem*)groupListBox->GetItem( j );
-				if ( stricmp( name, pItem->getText() ) < 0 )
+				if ( _stricmp( name, pItem->getText() ) < 0 )
 				{
 					groupListBox->InsertItem( pEntry, j );
 					bFound = true;
@@ -339,10 +337,10 @@ void Mechlopedia::MechScreen::begin()
 				pEntry->height() );
 
 			bool bFound = 0;
-			for ( int j = 0; j < groupListBox->GetItemCount(); j++ )
+			for ( j = 0; j < groupListBox->GetItemCount(); j++ )
 			{
 				aTextListItem* pItem = (aTextListItem*)groupListBox->GetItem( j );
-				if ( stricmp( pCopters[i]->getName(), pItem->getText() ) < 0 )
+				if ( _stricmp( pCopters[i]->getName(), pItem->getText() ) < 0 )
 				{
 					groupListBox->InsertItem( pEntry, j );
 					bFound = true;
@@ -361,12 +359,12 @@ void Mechlopedia::MechScreen::begin()
 		const LogisticsVariant* pChassis[256];
 		LogisticsData::instance->getEncyclopediaMechs( pChassis, count );
 
-		for ( int i = 1; i < count; ++i )
+		for ( i = 1; i < count; ++i )
 		{
 			const LogisticsVariant* cur = pChassis[i];
-			for ( int j = 0; j <= i; ++j )
+			for ( j = 0; j <= i; ++j )
 			{
-				if ( stricmp( cur->getName(), pChassis[j]->getName() ) < 0  )
+				if ( _stricmp( cur->getName(), pChassis[j]->getName() ) < 0  )
 				{
 					for ( int l = i-1; l >= j; l-- )
 					{
@@ -700,7 +698,7 @@ int __cdecl sortWeapon( const void* pW1, const void* pW2 )
 	LogisticsComponent* p1 = *(LogisticsComponent**)pW1;
 	LogisticsComponent* p2 = *(LogisticsComponent**)pW2;
 
-	return stricmp( p1->getName(), p2->getName() );
+	return _stricmp( p1->getName(), p2->getName() );
 
 }
 
@@ -1111,7 +1109,7 @@ void Mechlopedia::BuildingScreen::begin()
 		bool bFound = 0;
 		for ( int j = 0; j < groupListBox->GetItemCount(); j++ )
 		{
-			if ( stricmp(  str, ((aTextListItem*)groupListBox->GetItem( j ))->getText() ) < 0 )
+			if ( _stricmp(  str, ((aTextListItem*)groupListBox->GetItem( j ))->getText() ) < 0 )
 			{
 				MechlopediaListItem* pItem = new MechlopediaListItem();
 				pItem->setText( str );


  ================================================
diff --git a/source/mechcmd2/mechpurchasescreen.cpp b/source/mechcmd2/mechpurchasescreen.cpp
index a8d0c09..644c40d 100755
--- a/source/mechcmd2/mechpurchasescreen.cpp
+++ b/source/mechcmd2/mechpurchasescreen.cpp
@@ -5,6 +5,7 @@ MechPurchaseScreen.cpp			: Implementation of the MechPurchaseScreen component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MechPurchaseScreen.h"
 #include "mcLib.h"


  ================================================
diff --git a/source/mechcmd2/mission.cpp b/source/mechcmd2/mission.cpp
index bb61513..e3d957f 100755
--- a/source/mechcmd2/mission.cpp
+++ b/source/mechcmd2/mission.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //----------------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/mission2.cpp b/source/mechcmd2/mission2.cpp
index 40eed28..84b5e3c 100755
--- a/source/mechcmd2/mission2.cpp
+++ b/source/mechcmd2/mission2.cpp
@@ -5,6 +5,7 @@ mission2.cpp			: The parts of mission.cpp that we need for the mech viewer
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "mission.h"
 
@@ -97,6 +98,7 @@ void Mission::initBareMinimum()
 {
 
 	long result = 0;
+	result;
 
 	if ( !mcTextureManager )
 	{


  ================================================
diff --git a/source/mechcmd2/missionbegin.cpp b/source/mechcmd2/missionbegin.cpp
index e2a0d5e..7d19f59 100755
--- a/source/mechcmd2/missionbegin.cpp
+++ b/source/mechcmd2/missionbegin.cpp
@@ -4,6 +4,7 @@ MissionBegin.cpp			: Implementation of the MissionBegin component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MissionBegin.h"
 #include "McLib.h"


  ================================================
diff --git a/source/mechcmd2/missionbriefingscreen.cpp b/source/mechcmd2/missionbriefingscreen.cpp
index edcdcae..8d23273 100755
--- a/source/mechcmd2/missionbriefingscreen.cpp
+++ b/source/mechcmd2/missionbriefingscreen.cpp
@@ -2,6 +2,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #include "MissionBriefingScreen.h"
 #include "MechBayScreen.h"


  ================================================
diff --git a/source/mechcmd2/missiongui.cpp b/source/mechcmd2/missiongui.cpp
index 481fbc6..613e9c5 100755
--- a/source/mechcmd2/missiongui.cpp
+++ b/source/mechcmd2/missiongui.cpp
@@ -21,6 +21,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //--------------------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/missionresults.cpp b/source/mechcmd2/missionresults.cpp
index 3beaa50..8c7c4ba 100755
--- a/source/mechcmd2/missionresults.cpp
+++ b/source/mechcmd2/missionresults.cpp
@@ -5,6 +5,7 @@ MissionResults.cpp			: Implementation of the MissionResults component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MissionResults.h"
 #include "McLib.h"


  ================================================
diff --git a/source/mechcmd2/missionselectionscreen.cpp b/source/mechcmd2/missionselectionscreen.cpp
index 50c0668..961a737 100755
--- a/source/mechcmd2/missionselectionscreen.cpp
+++ b/source/mechcmd2/missionselectionscreen.cpp
@@ -5,6 +5,7 @@ MissionSelectionScreen.cpp			: Implementation of the MissionSelectionScreen comp
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MissionSelectionScreen.h"
 #include "MechBayScreen.h"


  ================================================
diff --git a/source/mechcmd2/movemgr.cpp b/source/mechcmd2/movemgr.cpp
index c08b3d8..eb8b6a8 100755
--- a/source/mechcmd2/movemgr.cpp
+++ b/source/mechcmd2/movemgr.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/mover.cpp b/source/mechcmd2/mover.cpp
index 5021261..47c1e53 100755
--- a/source/mechcmd2/mover.cpp
+++ b/source/mechcmd2/mover.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_h
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/mpaddaiplayer.cpp b/source/mechcmd2/mpaddaiplayer.cpp
index 39a4dbc..6bb75f1 100755
--- a/source/mechcmd2/mpaddaiplayer.cpp
+++ b/source/mechcmd2/mpaddaiplayer.cpp
@@ -5,6 +5,7 @@ MPAddAIPlayer.cpp			: Implementation of the MPAddAIPlayer component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPAddAIPlayer.h"
 #include "prefs.h"


  ================================================
diff --git a/source/mechcmd2/mpconnectiontype.cpp b/source/mechcmd2/mpconnectiontype.cpp
index 712d267..3745446 100755
--- a/source/mechcmd2/mpconnectiontype.cpp
+++ b/source/mechcmd2/mpconnectiontype.cpp
@@ -5,6 +5,7 @@ MPConnectionType.cpp			: Implementation of the MPConnectionType component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPConnectionType.h"
 #include "prefs.h"


  ================================================
diff --git a/source/mechcmd2/mpdirecttcpip.cpp b/source/mechcmd2/mpdirecttcpip.cpp
index e0f4896..b944798 100755
--- a/source/mechcmd2/mpdirecttcpip.cpp
+++ b/source/mechcmd2/mpdirecttcpip.cpp
@@ -5,6 +5,7 @@ MPDirectTcpip.cpp			: Implementation of the MPDirectTcpip component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPDirectTcpip.h"
 #include "prefs.h"


  ================================================
diff --git a/source/mechcmd2/mpgamebrowser.cpp b/source/mechcmd2/mpgamebrowser.cpp
index 04062a3..3e88e4a 100755
--- a/source/mechcmd2/mpgamebrowser.cpp
+++ b/source/mechcmd2/mpgamebrowser.cpp
@@ -5,6 +5,7 @@ MPGameBrowser.cpp			: Implementation of the MPGameBrowser component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPGameBrowser.h"
 #include "prefs.h"
@@ -369,7 +370,7 @@ void MPGameBrowser::update()
 			{
 
 				aGameListItem* pItem = (aGameListItem*)gameList.GetItem( j );
-				int res = stricmp( pItem->getText( sortOrder ), items[i].getText( sortOrder ) );
+				int res = _stricmp( pItem->getText( sortOrder ), items[i].getText( sortOrder ) );
 				if ( (bSortUpward && res > 0) || (!bSortUpward && res < 0) )
 				{
 					gameList.InsertItem( &items[i], j );


  ================================================
diff --git a/source/mechcmd2/mphostgame.cpp b/source/mechcmd2/mphostgame.cpp
index 6364c4c..07a8919 100755
--- a/source/mechcmd2/mphostgame.cpp
+++ b/source/mechcmd2/mphostgame.cpp
@@ -5,6 +5,7 @@ MPHostGame.cpp			: Implementation of the MPHostGame component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPHostGame.h"
 #include "prefs.h"


  ================================================
diff --git a/source/mechcmd2/mploadmap.cpp b/source/mechcmd2/mploadmap.cpp
index 4ace00f..7775c73 100755
--- a/source/mechcmd2/mploadmap.cpp
+++ b/source/mechcmd2/mploadmap.cpp
@@ -5,6 +5,7 @@ MPLoadMap.cpp			: Implementation of the MPLoadMap component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPLoadMap.h"
 #include "prefs.h"


  ================================================
diff --git a/source/mechcmd2/mpparameterscreen.cpp b/source/mechcmd2/mpparameterscreen.cpp
index 4a89419..77a5d81 100755
--- a/source/mechcmd2/mpparameterscreen.cpp
+++ b/source/mechcmd2/mpparameterscreen.cpp
@@ -6,6 +6,7 @@ MPParameterScreen.cpp			: Implementation of the MPParameterScreen component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPParameterScreen.h"
 #include "prefs.h"


  ================================================
diff --git a/source/mechcmd2/mpprefs.cpp b/source/mechcmd2/mpprefs.cpp
index 4dadc0e..94336ef 100755
--- a/source/mechcmd2/mpprefs.cpp
+++ b/source/mechcmd2/mpprefs.cpp
@@ -5,6 +5,7 @@ mpprefs.cpp			: Implementation of the mpprefs component.ef
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "mpprefs.h"
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/mpsetuparea.cpp b/source/mechcmd2/mpsetuparea.cpp
index e00eb17..d590f87 100755
--- a/source/mechcmd2/mpsetuparea.cpp
+++ b/source/mechcmd2/mpsetuparea.cpp
@@ -5,6 +5,7 @@ MPSetupArea.cpp			: Implementation of the MPSetupArea component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPSetupArea.h"
 #include "prefs.h"


  ================================================
diff --git a/source/mechcmd2/mpstats.cpp b/source/mechcmd2/mpstats.cpp
index 22eb77a..0327620 100755
--- a/source/mechcmd2/mpstats.cpp
+++ b/source/mechcmd2/mpstats.cpp
@@ -5,6 +5,7 @@ MPStats.cpp			: Implementation of the MPStats component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "MPStats.h"
 #include "..\resource.h"


  ================================================
diff --git a/source/mechcmd2/multplyr.cpp b/source/mechcmd2/multplyr.cpp
index 7553f42..06922d4 100755
--- a/source/mechcmd2/multplyr.cpp
+++ b/source/mechcmd2/multplyr.cpp
@@ -5,6 +5,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/multplyr.h b/source/mechcmd2/multplyr.h
index a8c2047..67aef4b 100755
--- a/source/mechcmd2/multplyr.h
+++ b/source/mechcmd2/multplyr.h
@@ -325,7 +325,7 @@ typedef struct _CompressedMech {
 
 #pragma pack(1)
 
-#pragma warning (disable : 4200)
+//#pragma warning (disable : 4200)
 
 //------------------------------------------------------------------------------------------
 
@@ -1278,7 +1278,7 @@ class MCMSG_PassValue {
 };
 */
 
-#pragma warning (default : 4200)
+//#pragma warning (default : 4200)
 
 #pragma pack()
 


  ================================================
diff --git a/source/mechcmd2/objective.cpp b/source/mechcmd2/objective.cpp
index 2a7a086..d4270c2 100755
--- a/source/mechcmd2/objective.cpp
+++ b/source/mechcmd2/objective.cpp
@@ -5,6 +5,7 @@ Objective.cpp			: Implementation of the Objective component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "terrain.h"
 


  ================================================
diff --git a/source/mechcmd2/objective.h b/source/mechcmd2/objective.h
index aee88a9..81614b1 100755
--- a/source/mechcmd2/objective.h
+++ b/source/mechcmd2/objective.h
@@ -1,5 +1,3 @@
-#ifndef OBJECTIVE_H
-#define OBJECTIVE_H
 /*************************************************************************************************\
 Objective.h			: Interface for the Objective component.
 //---------------------------------------------------------------------------//
@@ -7,6 +5,11 @@ Objective.h			: Interface for the Objective component.
 //===========================================================================//
 \*************************************************************************************************/
 
+#pragma once
+
+#ifndef OBJECTIVE_H
+#define OBJECTIVE_H
+
 #include "elist.h"
 #include "EString.h"
 #include "tchar.h"
@@ -177,8 +180,8 @@ public:
 	void Alignment(int alignment) { m_alignment = alignment; }
 	virtual condition_species_type Species() = 0;
 	virtual bool Init() { return true; }
-	virtual bool Read( FitIniFile* missionFile ) { return true; }
-	virtual bool Save( FitIniFile* file ) { return true; }
+	virtual bool Read( FitIniFile* /*missionFile */) { return true; }
+	virtual bool Save( FitIniFile* /*file*/ ) { return true; }
 	virtual objective_status_type Status() = 0;
 	virtual EString Description() = 0;
 	virtual EString InstanceDescription() { EString retval; return retval; }


  ================================================
diff --git a/source/mechcmd2/objmgr.cpp b/source/mechcmd2/objmgr.cpp
index 3ec7b03..4b705f4 100755
--- a/source/mechcmd2/objmgr.cpp
+++ b/source/mechcmd2/objmgr.cpp
@@ -8,6 +8,7 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 // Include Files
+#include "stdafx.h"
 
 //=============
 #ifndef MCLIB_H


  ================================================
diff --git a/source/mechcmd2/objtype.cpp b/source/mechcmd2/objtype.cpp
index bb255b8..dcdf9c2 100755
--- a/source/mechcmd2/objtype.cpp
+++ b/source/mechcmd2/objtype.cpp
@@ -5,6 +5,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/optionsarea.cpp b/source/mechcmd2/optionsarea.cpp
index 2e53438..a46dc1e 100755
--- a/source/mechcmd2/optionsarea.cpp
+++ b/source/mechcmd2/optionsarea.cpp
@@ -5,6 +5,7 @@ OptionsArea.cpp			: Implementation of the OptionsArea component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "OptionsArea.h"
 #include "prefs.h"


  ================================================
diff --git a/source/mechcmd2/optionsscreenwrapper.cpp b/source/mechcmd2/optionsscreenwrapper.cpp
index 7ba947c..44e6b76 100755
--- a/source/mechcmd2/optionsscreenwrapper.cpp
+++ b/source/mechcmd2/optionsscreenwrapper.cpp
@@ -5,6 +5,7 @@ OptionsScreenWrapper.cpp			: Implementation of the OptionsScreenWrapper componen
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "OptionsScreenWrapper.h"
 #include "McLib.h"


  ================================================
diff --git a/source/mechcmd2/pausewindow.cpp b/source/mechcmd2/pausewindow.cpp
index 4b4a215..5f608c0 100755
--- a/source/mechcmd2/pausewindow.cpp
+++ b/source/mechcmd2/pausewindow.cpp
@@ -5,6 +5,7 @@ PauseWindow.cpp			: Implementation of the PauseWindow component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "PauseWindow.h"
 #include "controlGui.h"
@@ -241,7 +242,7 @@ void PauseWindow::update()
 	_splitpath(campaignName,NULL,NULL,campName,NULL);
 	if ( MPlayer || 
 		LogisticsData::instance->isSingleMission() ||
-		(stricmp("tutorial",campName) == 0))
+		(_stricmp("tutorial",campName) == 0))
 	{
 		buttons[ SAVE ].disable( true );
 		buttons[ LOAD ].disable( true );


  ================================================
diff --git a/source/mechcmd2/pilotreadyscreen.cpp b/source/mechcmd2/pilotreadyscreen.cpp
index 2b87046..fd1f3c4 100755
--- a/source/mechcmd2/pilotreadyscreen.cpp
+++ b/source/mechcmd2/pilotreadyscreen.cpp
@@ -4,6 +4,7 @@ PilotReadyScreen.cpp			: Implementation of the PilotReadyScreen component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "PilotReadyScreen.h"
 #include "LogisticsMech.h"


  ================================================
diff --git a/source/mechcmd2/pilotreviewarea.cpp b/source/mechcmd2/pilotreviewarea.cpp
index 28a74f6..77faf1a 100755
--- a/source/mechcmd2/pilotreviewarea.cpp
+++ b/source/mechcmd2/pilotreviewarea.cpp
@@ -5,6 +5,7 @@ SalvageMechArea.cpp			: Implementation of the SalvageMechArea component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "PilotReviewArea.h"
 #include "IniFile.h"


  ================================================
diff --git a/source/mechcmd2/prefs.cpp b/source/mechcmd2/prefs.cpp
index 4ff7696..bc83567 100755
--- a/source/mechcmd2/prefs.cpp
+++ b/source/mechcmd2/prefs.cpp
@@ -2,6 +2,8 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+#include "stdafx.h"
+
 #include <io.h> // for _chmod()
 
 #include "prefs.h"
@@ -57,7 +59,8 @@ CPrefs::CPrefs() {
 	fullScreen = false;
 	gammaLevel = 0;
 	useLeftRightMouseProfile = true; // if false, use old style commands
-	for ( int i = 0; i < 10; i++ )
+	int i;
+	for ( i = 0; i < 10; i++ )
 		playerName[i][0] = 0;
 
 	for (i = 0; i < 10; i++ )
@@ -484,12 +487,13 @@ void CPrefs::setNewName( const char* pNewName )
 	if ( !pNewName )
 		return;
 	// check and see if this name is already in here
-	for ( int i = 0; i < 10; i++ )
+	int i, j;
+	for ( i = 0; i < 10; i++ )
 	{
-		if ( !stricmp( pNewName, playerName[i] ) )
+		if ( !_stricmp( pNewName, playerName[i] ) )
 		{
 			// found the same one so now we just shuffle
-			for ( int j = i; j < 9; j++ )
+			for ( j = i; j < 9; j++ )
 			{
 				strcpy( playerName[j], playerName[j+1] );
 			}
@@ -522,12 +526,13 @@ void CPrefs::setNewIP( const char* pNewIP )
 	if ( !pNewIP )
 		return;
 	// check and see if this name is already in here
-	for ( int i = 0; i < 10; i++ )
+	int i, j;
+	for ( i = 0; i < 10; i++ )
 	{
-		if ( !stricmp( pNewIP, ipAddresses[i] ) )
+		if ( !_stricmp( pNewIP, ipAddresses[i] ) )
 		{
 			// found the same one so now we just shuffle
-			for ( int j = i; j < 9; j++ )
+			for ( j = i; j < 9; j++ )
 			{
 				strcpy( ipAddresses[j], ipAddresses[j+1] );
 			}
@@ -554,12 +559,13 @@ void CPrefs::setNewUnit( const char* pNewUnit )
 	if ( !pNewUnit )
 		return;
 // check and see if this name is already in here
-	for ( int i = 0; i < 10; i++ )
+	int i, j;
+	for ( i = 0; i < 10; i++ )
 	{
-		if ( !stricmp( pNewUnit, unitName[i] ) )
+		if ( !_stricmp( pNewUnit, unitName[i] ) )
 		{
 			// found the same one so now we just shuffle
-			for ( int j = i; j < 9; j++ )
+			for ( j = i; j < 9; j++ )
 			{
 				strcpy( unitName[j], unitName[j+1] );
 			}


  ================================================
diff --git a/source/mechcmd2/radio.cpp b/source/mechcmd2/radio.cpp
index 53efac1..c21df44 100755
--- a/source/mechcmd2/radio.cpp
+++ b/source/mechcmd2/radio.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //------------------------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/salvagemecharea.cpp b/source/mechcmd2/salvagemecharea.cpp
index 27944d5..5cc6c51 100755
--- a/source/mechcmd2/salvagemecharea.cpp
+++ b/source/mechcmd2/salvagemecharea.cpp
@@ -5,6 +5,7 @@ SalvageMechArea.cpp			: Implementation of the SalvageMechArea component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "SalvageMechArea.h"
 #include "IniFile.h"


  ================================================
diff --git a/source/mechcmd2/saveload.cpp b/source/mechcmd2/saveload.cpp
index 45f443b..ee83a25 100755
--- a/source/mechcmd2/saveload.cpp
+++ b/source/mechcmd2/saveload.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //----------------------------------------------------------------------------------
 // Include Files
@@ -666,7 +667,7 @@ void Mission::load (const char *loadFileName)
 	const char *cmpName = campaignName.Data();
 
 	/*
-	if (stricmp(campName,cmpName) != 0)
+	if (_stricmp(campName,cmpName) != 0)
 	{
 		char msg[2048];
 		cLoadString(IDS_QUICKSAVE_CAMPAIGN_WRONG,msg,2047);


  ================================================
diff --git a/source/mechcmd2/simplecamera.cpp b/source/mechcmd2/simplecamera.cpp
index ac5254e..5e629df 100755
--- a/source/mechcmd2/simplecamera.cpp
+++ b/source/mechcmd2/simplecamera.cpp
@@ -4,6 +4,8 @@ SimpleCamera.cpp	: Implementation of the SimpleCamera component.
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
+
 #include "SimpleCamera.h"
 #include "appear.h"
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/simplecomponentlistbox.cpp b/source/mechcmd2/simplecomponentlistbox.cpp
index dc5115d..4206884 100755
--- a/source/mechcmd2/simplecomponentlistbox.cpp
+++ b/source/mechcmd2/simplecomponentlistbox.cpp
@@ -5,6 +5,7 @@ SimpleComponentListBox.cpp			: Implementation of the SimpleComponentListBox comp
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 \*************************************************************************************************/
+#include "stdafx.h"
 
 #include "SimpleComponentListBox.h"
 #include "..\resource.h"
@@ -91,16 +92,17 @@ void ComponentListBox::setComponents( long componentCount, LogisticsComponent**
 		long colors[4] = { 0xff6E7C00, 0xff005392, 0xffA21600, 0xffc29b00};
 //		long headerColors[4] = { 0xFFC8E100, 0xff0091FF, 0xFFFF0000, 0xffFF8A00 };
 
-		for ( int i = 0; i < 4; i++ ) // do short, medium long
+		int i, j , k;
+		for ( i = 0; i < 4; i++ ) // do short, medium long
 		{
 			memset( finalList, 0, sizeof( long ) * 64 );
 			memset( finalListCount, 0, sizeof( long ) * 64 );
-			for ( int j = 0; j < componentCount; j++ )
+			for ( j = 0; j < componentCount; j++ )
 			{
 				if ( components[j]->getRangeType() == (LogisticsComponent::WEAPON_RANGE)i ) // short, med, long
 				{
 					bool bFound = 0;
-					for ( int k = 0; k < 64; k++ )
+					for ( k = 0; k < 64; k++ )
 					{
 						if ( finalList[k] == components[j])
 						{
@@ -132,7 +134,7 @@ void ComponentListBox::setComponents( long componentCount, LogisticsComponent**
 //				AddItem( textItem );
 
 				// add each componet
-				for( int j = 0; j < 64; j++ )
+				for( j = 0; j < 64; j++ )
 				{
 					if ( !finalList[j] )
 						break;


  ================================================
diff --git a/source/mechcmd2/tacordr.cpp b/source/mechcmd2/tacordr.cpp
index 485218b..7133b28 100755
--- a/source/mechcmd2/tacordr.cpp
+++ b/source/mechcmd2/tacordr.cpp
@@ -7,6 +7,7 @@
 //								TACORDR.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
 #ifndef MCLIB
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/tacordr.h b/source/mechcmd2/tacordr.h
index 38a9b63..53580ca 100755
--- a/source/mechcmd2/tacordr.h
+++ b/source/mechcmd2/tacordr.h
@@ -324,8 +324,9 @@ class TacticalOrder {
 
 		long getGroup (long commanderID, MoverPtr* moverList, MoverPtr* point, long sortType = 0);
 
-		void setStage (long newStage) {
-			stage = newStage;
+		void setStage (long newStage)
+		{
+			stage = (char)newStage;
 		}
 
 		GameObjectPtr getTarget (void);


  ================================================
diff --git a/source/mechcmd2/team.cpp b/source/mechcmd2/team.cpp
index a3b91ba..3ee824c 100755
--- a/source/mechcmd2/team.cpp
+++ b/source/mechcmd2/team.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//*
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/terrobj.cpp b/source/mechcmd2/terrobj.cpp
index d729b8c..3657c3c 100755
--- a/source/mechcmd2/terrobj.cpp
+++ b/source/mechcmd2/terrobj.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2/trigger.cpp b/source/mechcmd2/trigger.cpp
index 83f137d..400ff93 100755
--- a/source/mechcmd2/trigger.cpp
+++ b/source/mechcmd2/trigger.cpp
@@ -1,6 +1,7 @@
 //===========================================================================//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef TRIGGER_H
 #include "trigger.h"


  ================================================
diff --git a/source/mechcmd2/turret.cpp b/source/mechcmd2/turret.cpp
index 645be26..fb3ba9b 100755
--- a/source/mechcmd2/turret.cpp
+++ b/source/mechcmd2/turret.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"


  ================================================
diff --git a/source/mechcmd2/vfxshape.cpp b/source/mechcmd2/vfxshape.cpp
index 133ce06..53ae7a6 100755
--- a/source/mechcmd2/vfxshape.cpp
+++ b/source/mechcmd2/vfxshape.cpp
@@ -8,6 +8,7 @@
 
 //---------------------------------------------------------------------------
 // Include files
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"
@@ -17,9 +18,9 @@
 #include "vfxshape.h"
 #endif
 
-#ifndef SPRTMGR_H
-#include "sprtmgr.h"
-#endif
+//#ifndef SPRTMGR_H
+//#include "sprtmgr.h"
+//#endif
 
 #ifndef APPRTYPE_H
 #include "apprtype.h"


  ================================================
diff --git a/source/mechcmd2/warrior.cpp b/source/mechcmd2/warrior.cpp
index 69fcdf8..f71a09f 100755
--- a/source/mechcmd2/warrior.cpp
+++ b/source/mechcmd2/warrior.cpp
@@ -7,6 +7,7 @@
 //								WARRIOR.CPP
 //
 //***************************************************************************
+#include "stdafx.h"
 
 #ifndef MCLIB_H
 #include "mclib.h"
@@ -8502,7 +8503,7 @@ bool MechWarrior::warriorInUse (char *warriorName)
 {
 	for (long i=0; i < numWarriors;i++)
 	{
-		if (stricmp(MechWarrior::warriorList[i]->name,warriorName) == 0)
+		if (_stricmp(MechWarrior::warriorList[i]->name,warriorName) == 0)
 			return true;
 	}
 


  ================================================
diff --git a/source/mechcmd2/warrior.h b/source/mechcmd2/warrior.h
index 2ec50d7..4bd1def 100755
--- a/source/mechcmd2/warrior.h
+++ b/source/mechcmd2/warrior.h
@@ -1030,11 +1030,12 @@ class MechWarrior {
 			return(rank);
 		}
 
-		long getSkill (long skillId) {
+		ULONG getSkill (ULONG skillId)
+		{
 			return(skills[skillId]);
 		}
 
-		void setSkill (long skillId, long skillValue)
+		void setSkill (ULONG skillId, long skillValue)
 		{
 			if (skillId > 0 && skillId < NUM_SKILLS)
 				skills[skillId] = skillValue;


  ================================================
diff --git a/source/mechcmd2/weaponbolt.cpp b/source/mechcmd2/weaponbolt.cpp
index 2e54f2c..a7890c1 100755
--- a/source/mechcmd2/weaponbolt.cpp
+++ b/source/mechcmd2/weaponbolt.cpp
@@ -7,6 +7,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //---------------------------------------------------------------------------
 // Include Files
@@ -2468,7 +2469,7 @@ void WeaponBolt::init (bool create, ObjectTypePtr _type)
 	//----------------------------------------------
 	// Get a texture Handle from the textureManager
 	// Assume ALPHA!
-	if (((WeaponBoltTypePtr)_type)->textureName && stricmp(((WeaponBoltTypePtr)_type)->textureName,"NONE") != 0)
+	if (((WeaponBoltTypePtr)_type)->textureName && _stricmp(((WeaponBoltTypePtr)_type)->textureName,"NONE") != 0)
 	{
 		char tPath[1024];
 		sprintf(tPath,"%s128\\",tglPath);


  ================================================
diff --git a/source/mechcmd2/weather.cpp b/source/mechcmd2/weather.cpp
index 35d3784..3122b5b 100755
--- a/source/mechcmd2/weather.cpp
+++ b/source/mechcmd2/weather.cpp
@@ -6,6 +6,7 @@
 //---------------------------------------------------------------------------//
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
+#include "stdafx.h"
 
 //----------------------------------------------------------------------------------
 // Include Files


  ================================================
diff --git a/source/mechcmd2_vc8.sln b/source/mechcmd2_vc8.sln
old mode 100644
new mode 100755
index 1cab1ef..bf6d50f
--- a/source/mechcmd2_vc8.sln
+++ b/source/mechcmd2_vc8.sln
@@ -1,123 +1,163 @@
 Microsoft Visual Studio Solution File, Format Version 9.00
 # Visual Studio 2005
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GUI", "build.vs\gui_vc8.vcproj", "{97985315-F026-4AB8-A765-2DBE7B78CC6C}"
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Applications", "Applications", "{84922EB1-5A83-4BD3-8A24-8570551BCA10}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MCLib", "build.vs\mclib_vc8.vcproj", "{09582E8D-FAA3-4A07-AB43-74C33436CDDF}"
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "DLLs", "DLLs", "{B573172F-59DA-4A1D-A894-BA32C8F068EF}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MLR", "build.vs\mlr_vc8.vcproj", "{6CFC313D-C849-4753-8EAA-3244D0515C7A}"
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Libraries", "Libraries", "{E9E993DF-D613-4091-A6EF-2B166ED87A4F}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MechCmd2", "build.vs\mechcmd2_vc8.vcproj", "{8FA46A42-5363-4C71-90D8-1106203F0DC7}"
-	ProjectSection(ProjectDependencies) = postProject
-		{97985315-F026-4AB8-A765-2DBE7B78CC6C} = {97985315-F026-4AB8-A765-2DBE7B78CC6C}
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A} = {6CFC313D-C849-4753-8EAA-3244D0515C7A}
-		{FDA65357-68F7-4567-89C0-A4D15FB27CDB} = {FDA65357-68F7-4567-89C0-A4D15FB27CDB}
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF} = {09582E8D-FAA3-4A07-AB43-74C33436CDDF}
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA} = {14F6019A-43EA-41FF-BE5D-24D54425B7AA}
-		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A} = {CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ablt", "build.vs\ablt_vc8.vcproj", "{533EB470-9743-48C3-A77F-1490873B7CBB}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Stuff", "build.vs\stuff_vc8.vcproj", "{14F6019A-43EA-41FF-BE5D-24D54425B7AA}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "aseconv", "build.vs\aseconv_vc8.vcproj", "{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Viewer", "build.vs\viewer_vc8.vcproj", "{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}"
-	ProjectSection(ProjectDependencies) = postProject
-		{97985315-F026-4AB8-A765-2DBE7B78CC6C} = {97985315-F026-4AB8-A765-2DBE7B78CC6C}
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A} = {6CFC313D-C849-4753-8EAA-3244D0515C7A}
-		{FDA65357-68F7-4567-89C0-A4D15FB27CDB} = {FDA65357-68F7-4567-89C0-A4D15FB27CDB}
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF} = {09582E8D-FAA3-4A07-AB43-74C33436CDDF}
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA} = {14F6019A-43EA-41FF-BE5D-24D54425B7AA}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "editor", "build.vs\editor_vc8.vcproj", "{61FF0D0E-7063-4843-A009-A764F7AD72D4}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ablt", "build.vs\ablt_vc8.vcproj", "{533EB470-9743-48C3-A77F-1490873B7CBB}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "gosfx", "build.vs\gosfx_vc8.vcproj", "{FDA65357-68F7-4567-89C0-A4D15FB27CDB}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "aseconv", "build.vs\aseconv_vc8.vcproj", "{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}"
-	ProjectSection(ProjectDependencies) = postProject
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A} = {6CFC313D-C849-4753-8EAA-3244D0515C7A}
-		{FDA65357-68F7-4567-89C0-A4D15FB27CDB} = {FDA65357-68F7-4567-89C0-A4D15FB27CDB}
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF} = {09582E8D-FAA3-4A07-AB43-74C33436CDDF}
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA} = {14F6019A-43EA-41FF-BE5D-24D54425B7AA}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "gui", "build.vs\gui_vc8.vcproj", "{97985315-F026-4AB8-A765-2DBE7B78CC6C}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "gosFX", "build.vs\gosfx_vc8.vcproj", "{FDA65357-68F7-4567-89C0-A4D15FB27CDB}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mlr", "build.vs\mlr_vc8.vcproj", "{6CFC313D-C849-4753-8EAA-3244D0515C7A}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "stuff", "build.vs\stuff_vc8.vcproj", "{14F6019A-43EA-41FF-BE5D-24D54425B7AA}"
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mc2res", "build.vs\mc2res_vc8.vcproj", "{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EditorMFC", "build.vs\editor_vc8.vcproj", "{61FF0D0E-7063-4843-A009-A764F7AD72D4}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mclib", "build.vs\mclib_vc8.vcproj", "{09582E8D-FAA3-4A07-AB43-74C33436CDDF}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mechcmd2", "build.vs\mechcmd2_vc8.vcproj", "{8FA46A42-5363-4C71-90D8-1106203F0DC7}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "gameos", "build.vs\gameos_vc8.vcproj", "{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "viewer", "build.vs\viewer_vc8.vcproj", "{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Config", "Config", "{DE2F4131-38FF-4205-94C8-6032A0BC76C2}"
+	ProjectSection(SolutionItems) = preProject
+		initial_preparations.txt = initial_preparations.txt
+		..\LICENSE = ..\LICENSE
+		..\original_source.txt = ..\original_source.txt
+		..\README.md = ..\README.md
+	EndProjectSection
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Win32 = Debug|Win32
-		Profile|Win32 = Profile|Win32
+		Debug|x64 = Debug|x64
 		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Debug|Win32.ActiveCfg = Debug|Win32
-		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Debug|Win32.Build.0 = Debug|Win32
-		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Profile|Win32.ActiveCfg = Profile|Win32
-		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Profile|Win32.Build.0 = Profile|Win32
-		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Release|Win32.ActiveCfg = Release|Win32
-		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Release|Win32.Build.0 = Release|Win32
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Debug|Win32.ActiveCfg = Debug|Win32
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Debug|Win32.Build.0 = Debug|Win32
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Profile|Win32.ActiveCfg = Profile|Win32
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Profile|Win32.Build.0 = Profile|Win32
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Release|Win32.ActiveCfg = Release|Win32
-		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Release|Win32.Build.0 = Release|Win32
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Debug|Win32.Build.0 = Debug|Win32
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Profile|Win32.ActiveCfg = Profile|Win32
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Profile|Win32.Build.0 = Profile|Win32
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Release|Win32.ActiveCfg = Release|Win32
-		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Release|Win32.Build.0 = Release|Win32
-		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Debug|Win32.ActiveCfg = Debug|Win32
-		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Debug|Win32.Build.0 = Debug|Win32
-		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Profile|Win32.ActiveCfg = Profile|Win32
-		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Profile|Win32.Build.0 = Profile|Win32
-		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Release|Win32.ActiveCfg = Release|Win32
-		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Release|Win32.Build.0 = Release|Win32
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Debug|Win32.Build.0 = Debug|Win32
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Profile|Win32.ActiveCfg = Profile|Win32
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Profile|Win32.Build.0 = Profile|Win32
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Release|Win32.ActiveCfg = Release|Win32
-		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Release|Win32.Build.0 = Release|Win32
-		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Debug|Win32.ActiveCfg = Debug|Win32
-		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Debug|Win32.Build.0 = Debug|Win32
-		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Profile|Win32.ActiveCfg = Profile|Win32
-		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Profile|Win32.Build.0 = Profile|Win32
-		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Release|Win32.ActiveCfg = Release|Win32
-		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Release|Win32.Build.0 = Release|Win32
 		{533EB470-9743-48C3-A77F-1490873B7CBB}.Debug|Win32.ActiveCfg = Debug|Win32
 		{533EB470-9743-48C3-A77F-1490873B7CBB}.Debug|Win32.Build.0 = Debug|Win32
-		{533EB470-9743-48C3-A77F-1490873B7CBB}.Profile|Win32.ActiveCfg = Release|Win32
-		{533EB470-9743-48C3-A77F-1490873B7CBB}.Profile|Win32.Build.0 = Release|Win32
+		{533EB470-9743-48C3-A77F-1490873B7CBB}.Debug|x64.ActiveCfg = Debug|x64
+		{533EB470-9743-48C3-A77F-1490873B7CBB}.Debug|x64.Build.0 = Debug|x64
 		{533EB470-9743-48C3-A77F-1490873B7CBB}.Release|Win32.ActiveCfg = Release|Win32
 		{533EB470-9743-48C3-A77F-1490873B7CBB}.Release|Win32.Build.0 = Release|Win32
+		{533EB470-9743-48C3-A77F-1490873B7CBB}.Release|x64.ActiveCfg = Release|x64
+		{533EB470-9743-48C3-A77F-1490873B7CBB}.Release|x64.Build.0 = Release|x64
 		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Debug|Win32.ActiveCfg = Debug|Win32
 		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Debug|Win32.Build.0 = Debug|Win32
-		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Profile|Win32.ActiveCfg = Profile|Win32
-		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Profile|Win32.Build.0 = Profile|Win32
+		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Debug|x64.ActiveCfg = Debug|x64
+		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Debug|x64.Build.0 = Debug|x64
 		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Release|Win32.ActiveCfg = Release|Win32
 		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Release|Win32.Build.0 = Release|Win32
+		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Release|x64.ActiveCfg = Release|x64
+		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE}.Release|x64.Build.0 = Release|x64
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Debug|Win32.ActiveCfg = Debug|Win32
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Debug|Win32.Build.0 = Debug|Win32
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Debug|x64.ActiveCfg = Debug|x64
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Debug|x64.Build.0 = Debug|x64
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Release|Win32.ActiveCfg = Release|Win32
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Release|Win32.Build.0 = Release|Win32
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Release|x64.ActiveCfg = Release|x64
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Release|x64.Build.0 = Release|x64
 		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Debug|Win32.ActiveCfg = Debug|Win32
 		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Debug|Win32.Build.0 = Debug|Win32
-		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Profile|Win32.ActiveCfg = Profile|Win32
-		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Profile|Win32.Build.0 = Profile|Win32
+		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Debug|x64.ActiveCfg = Debug|x64
+		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Debug|x64.Build.0 = Debug|x64
 		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Release|Win32.ActiveCfg = Release|Win32
 		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Release|Win32.Build.0 = Release|Win32
+		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Release|x64.ActiveCfg = Release|x64
+		{FDA65357-68F7-4567-89C0-A4D15FB27CDB}.Release|x64.Build.0 = Release|x64
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Debug|Win32.ActiveCfg = Debug|Win32
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Debug|Win32.Build.0 = Debug|Win32
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Debug|x64.ActiveCfg = Debug|x64
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Debug|x64.Build.0 = Debug|x64
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Release|Win32.ActiveCfg = Release|Win32
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Release|Win32.Build.0 = Release|Win32
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Release|x64.ActiveCfg = Release|x64
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C}.Release|x64.Build.0 = Release|x64
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Debug|Win32.Build.0 = Debug|Win32
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Debug|x64.ActiveCfg = Debug|x64
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Debug|x64.Build.0 = Debug|x64
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Release|Win32.ActiveCfg = Release|Win32
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Release|Win32.Build.0 = Release|Win32
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Release|x64.ActiveCfg = Release|x64
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A}.Release|x64.Build.0 = Release|x64
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Debug|Win32.ActiveCfg = Debug|Win32
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Debug|Win32.Build.0 = Debug|Win32
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Debug|x64.ActiveCfg = Debug|x64
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Debug|x64.Build.0 = Debug|x64
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Release|Win32.ActiveCfg = Release|Win32
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Release|Win32.Build.0 = Release|Win32
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Release|x64.ActiveCfg = Release|x64
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA}.Release|x64.Build.0 = Release|x64
 		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Debug|Win32.ActiveCfg = Debug|Win32
 		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Debug|Win32.Build.0 = Debug|Win32
-		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Profile|Win32.ActiveCfg = Profile|Win32
-		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Profile|Win32.Build.0 = Profile|Win32
+		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Debug|x64.ActiveCfg = Debug|x64
+		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Debug|x64.Build.0 = Debug|x64
 		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Release|Win32.ActiveCfg = Release|Win32
 		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Release|Win32.Build.0 = Release|Win32
-		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Debug|Win32.ActiveCfg = Debug|Win32
-		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Debug|Win32.Build.0 = Debug|Win32
-		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Profile|Win32.ActiveCfg = Profile|Win32
-		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Profile|Win32.Build.0 = Profile|Win32
-		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Release|Win32.ActiveCfg = Release|Win32
-		{61FF0D0E-7063-4843-A009-A764F7AD72D4}.Release|Win32.Build.0 = Release|Win32
+		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Release|x64.ActiveCfg = Release|x64
+		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A}.Release|x64.Build.0 = Release|x64
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Debug|Win32.ActiveCfg = Debug|Win32
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Debug|Win32.Build.0 = Debug|Win32
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Debug|x64.ActiveCfg = Debug|x64
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Debug|x64.Build.0 = Debug|x64
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Release|Win32.ActiveCfg = Release|Win32
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Release|Win32.Build.0 = Release|Win32
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Release|x64.ActiveCfg = Release|x64
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF}.Release|x64.Build.0 = Release|x64
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Debug|Win32.Build.0 = Debug|Win32
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Debug|x64.ActiveCfg = Debug|x64
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Debug|x64.Build.0 = Debug|x64
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Release|Win32.ActiveCfg = Release|Win32
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Release|Win32.Build.0 = Release|Win32
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Release|x64.ActiveCfg = Release|x64
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7}.Release|x64.Build.0 = Release|x64
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}.Debug|Win32.ActiveCfg = Debug|Win32
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}.Debug|Win32.Build.0 = Debug|Win32
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}.Debug|x64.ActiveCfg = Debug|x64
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}.Debug|x64.Build.0 = Debug|x64
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}.Release|Win32.ActiveCfg = Release|Win32
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}.Release|Win32.Build.0 = Release|Win32
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}.Release|x64.ActiveCfg = Release|x64
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B}.Release|x64.Build.0 = Release|x64
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Debug|Win32.Build.0 = Debug|Win32
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Debug|x64.ActiveCfg = Debug|x64
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Debug|x64.Build.0 = Debug|x64
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Release|Win32.ActiveCfg = Release|Win32
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Release|Win32.Build.0 = Release|Win32
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Release|x64.ActiveCfg = Release|x64
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666}.Release|x64.Build.0 = Release|x64
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
 	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{533EB470-9743-48C3-A77F-1490873B7CBB} = {84922EB1-5A83-4BD3-8A24-8570551BCA10}
+		{8D87B501-FAB3-4468-A67E-72CE3F4D21AE} = {84922EB1-5A83-4BD3-8A24-8570551BCA10}
+		{61FF0D0E-7063-4843-A009-A764F7AD72D4} = {84922EB1-5A83-4BD3-8A24-8570551BCA10}
+		{D6A172C0-ACCD-4F05-BADA-D8DEBD36B666} = {84922EB1-5A83-4BD3-8A24-8570551BCA10}
+		{97985315-F026-4AB8-A765-2DBE7B78CC6C} = {B573172F-59DA-4A1D-A894-BA32C8F068EF}
+		{CFE8A9D5-80DF-4ACC-B91F-64AB2167BC3A} = {B573172F-59DA-4A1D-A894-BA32C8F068EF}
+		{09582E8D-FAA3-4A07-AB43-74C33436CDDF} = {B573172F-59DA-4A1D-A894-BA32C8F068EF}
+		{8FA46A42-5363-4C71-90D8-1106203F0DC7} = {B573172F-59DA-4A1D-A894-BA32C8F068EF}
+		{B4EA2124-2ABF-442E-9B3E-0E503A4DAF8B} = {B573172F-59DA-4A1D-A894-BA32C8F068EF}
+		{FDA65357-68F7-4567-89C0-A4D15FB27CDB} = {E9E993DF-D613-4091-A6EF-2B166ED87A4F}
+		{6CFC313D-C849-4753-8EAA-3244D0515C7A} = {E9E993DF-D613-4091-A6EF-2B166ED87A4F}
+		{14F6019A-43EA-41FF-BE5D-24D54425B7AA} = {E9E993DF-D613-4091-A6EF-2B166ED87A4F}
+	EndGlobalSection
 EndGlobal


  ================================================
diff --git a/source/tools/aseconv/ase2tgl.cpp b/source/tools/aseconv/ase2tgl.cpp
index f2ef36a..27b3974 100755
--- a/source/tools/aseconv/ase2tgl.cpp
+++ b/source/tools/aseconv/ase2tgl.cpp
@@ -2,6 +2,15 @@
 // Copyright (C) Microsoft Corporation. All rights reserved.                 //
 //===========================================================================//
 
+// ..\..\mclib\$(ConfigurationName)\mclib.lib
+// ..\..\gameos\lib\$(ConfigurationName)\gameos.lib
+// ..\..\gameos\lib\$(ConfigurationName)\dllplatform.lib
+// ..\..\gameos\lib\$(ConfigurationName)\mfcplatform.lib
+// ..\..\mclib\gosfx\$(ConfigurationName)\gosfx.lib
+// ..\..\mclib\mlr\$(ConfigurationName)\mlr.lib
+// ..\..\mclib\stuff\$(ConfigurationName)\stuff.lib
+// ..\..\gameos\lib\$(ConfigurationName)\zlib.lib
+
 #include "stdafx.h"
 
 #include "version.h" 


  ================================================
diff --git a/source/viewer/view.cpp b/source/viewer/view.cpp
index f366565..2b8107f 100755
--- a/source/viewer/view.cpp
+++ b/source/viewer/view.cpp
@@ -4,21 +4,27 @@
 // Viewer.cpp : Defines the class behaviors for the application.
 //
 
+#include "stdafx.h"
 
-#ifndef VERSION_H
-#include "version.h"
-#endif
+//#ifndef VIEWER
+//#define VIEWER
+//#endif
+//
+
+//#ifndef VERSION_H
+//#include "version.h"
+//#endif
 
-#include <GameOS.hpp>
-#include <ToolOS.hpp>
+#include <gameos.hpp>
+#include <toolos.hpp>
 
 #include "..\resource.h"
 #include "mclib.h"
-#include "GameSound.h"
+#include "gamesound.h"
 #include <windows.h>
 #include "mission.h"
-#include "Mechlopedia.h"
-#include "LogisticsData.h"
+#include "mechlopedia.h"
+#include "logisticsdata.h"
 #include "prefs.h"
 
 CPrefs prefs;
@@ -280,6 +286,7 @@ void __stdcall InitializeGameEngine()
 		gosASSERT(systemBlockResult == NO_ERR);
 		{
 			long result = systemFile.readIdULong("systemHeapSize",systemHeapSize);
+			result;
 			gosASSERT(result == NO_ERR);
 		}
 
